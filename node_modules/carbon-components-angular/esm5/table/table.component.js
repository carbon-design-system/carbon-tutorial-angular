/**
 *
 * carbon-angular v0.0.0 | table.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Component, ApplicationRef, Input, Output, EventEmitter, ElementRef, TemplateRef, HostBinding } from "@angular/core";
import { Subscription, fromEvent } from "rxjs";
import { TableModel } from "./table-model.class";
import { TableHeaderItem } from "./table-header-item.class";
import { TableItem } from "./table-item.class";
import { getFocusElementList, tabbableSelectorIgnoreTabIndex } from "carbon-components-angular/common";
import { I18n } from "carbon-components-angular/i18n";
import { merge } from "carbon-components-angular/utils";
import { DataGridInteractionModel } from "./data-grid-interaction-model.class";
import { TableDomAdapter } from "./table-adapter.class";
/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/components-table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<ibm-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table [model]="model"></ibm-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <ibm-table [model]="model">No data.</ibm-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <ibm-pagination [model]="model" (selectPage)="selectPage($event)"></ibm-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=components-table--basic</example-url>
 */
var Table = /** @class */ (function () {
    /**
     * Creates an instance of Table.
     */
    function Table(elementRef, applicationRef, i18n) {
        this.elementRef = elementRef;
        this.applicationRef = applicationRef;
        this.i18n = i18n;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading table.
         */
        this.skeleton = false;
        /**
         * Setting sortable to false will disable all headers including headers which are sortable. Is is
         * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
         */
        this.sortable = true;
        this.noBorder = true;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Distance (in px) from the bottom that view has to reach before
         * `scrollLoad` event is emitted.
         */
        this.scrollLoadDistance = 0;
        /**
         * Set to `true` to enable users to resize columns.
         *
         * Works for columns with width set in pixels.
         *
         */
        this.columnsResizable = false;
        /**
         * Set to `true` to enable users to drag and drop columns.
         *
         * Changing the column order in table changes table model. Be aware of it when you add additional data
         * to the model.
         *
         */
        this.columnsDraggable = false;
        /**
         * Set to `false` to remove table rows (zebra) stripes.
         */
        this.striped = true;
        /**
         * Set to `true` to stick the header to the top of the table
         */
        this.stickyHeader = false;
        /**
         * Emits an index of the column that wants to be sorted.
         *
         * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
         * into the model.
         *
         * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
         * to sort the table. This is what you typically want if you're using a backend query to get the sorted
         * data or want to sort data across multiple pages.
         *
         * Usage:
         *
         * ```typescript
         * @Component({
         * 	selector: "app-table",
         * 	template: `
         * 		<ibm-table
         * 			[model]="model"
         * 			(sort)="simpleSort($event)">
         * 			No data.
         * 		</ibm-table>
         * 	`
         * })
         * export class TableApp implements OnInit, OnChanges {
         * 	@Input() model = new TableModel();
         *
         * 	ngOnInit() {
         * 		this.model.header = [
         * 			new TableHeaderItem({ data: "Name" }),
         * 			new TableHeaderItem({ data: "hwer" })
         * 		];
         *
         * 		this.model.data = [
         * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
         * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
         * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
         * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
         * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
         * 		];
         * 	}
         *
         * 	simpleSort(index: number) {
         * 		// this function does a simple sort, which is the default for the table and if that's
         * 		// all you want, you don't need to do this.
         *
         * 		// here you can query your backend and update the model.data based on the result
         * 		if (this.model.header[index].sorted) {
         * 			// if already sorted flip sorting direction
         * 			this.model.header[index].ascending = this.model.header[index].descending;
         * 		}
         * 		this.model.sort(index);
         * 	}
         * }
         * ```
         */
        this.sort = new EventEmitter();
        /**
         * Emits if all rows are selected.
         *
         * @param model
         */
        this.selectAll = new EventEmitter();
        /**
         * Emits if all rows are deselected.
         *
         * @param model
         */
        this.deselectAll = new EventEmitter();
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        /**
         * Emits when table requires more data to be loaded.
         */
        this.scrollLoad = new EventEmitter();
        /**
         * Controls if all checkboxes are viewed as selected.
         */
        this.selectAllCheckbox = false;
        /**
         * Controls the indeterminate state of the header checkbox.
         */
        this.selectAllCheckboxSomeSelected = false;
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this._isDataGrid = false;
        // flag to prevent getters/setters from querying the view before it's fully instantiated
        this.isViewReady = false;
        this.subscriptions = new Subscription();
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
        this._sortDescendingLabel = this.i18n.getOverridable("TABLE.SORT_DESCENDING");
        this._sortAscendingLabel = this.i18n.getOverridable("TABLE.SORT_ASCENDING");
        this._checkboxHeaderLabel = this.i18n.getOverridable("TABLE.CHECKBOX_HEADER");
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._endOfDataText = this.i18n.getOverridable("TABLE.END_OF_DATA");
        this._scrollTopText = this.i18n.getOverridable("TABLE.SCROLL_TOP");
        this._filterTitle = this.i18n.getOverridable("TABLE.FILTER");
    }
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    Table.skeletonModel = function (rowCount, columnCount) {
        var model = new TableModel();
        var header = new Array();
        var data = new Array();
        var row = new Array();
        for (var i = 0; i < columnCount; i++) {
            header.push(new TableHeaderItem());
            row.push(new TableItem());
        }
        for (var i = 0; i < rowCount - 1; i++) {
            data.push(row);
        }
        model.header = header;
        model.data = data;
        return model;
    };
    Table.setTabIndex = function (element, index) {
        var focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 1) {
            focusElementList[1].tabIndex = index;
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].tabIndex = index;
        }
        else {
            element.tabIndex = index;
        }
    };
    Table.focus = function (element) {
        var focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);
        if (element.firstElementChild && element.firstElementChild.classList.contains("bx--table-sort") && focusElementList.length > 1) {
            focusElementList[1].focus();
        }
        else if (focusElementList.length > 0) {
            focusElementList[0].focus();
        }
        else {
            element.focus();
        }
    };
    Object.defineProperty(Table.prototype, "model", {
        get: function () {
            return this._model;
        },
        /**
         * `TableModel` with data the table is to display.
         */
        set: function (m) {
            var _this = this;
            if (this._model) {
                this.subscriptions.unsubscribe();
                // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions
                // from being added for some reason. When a new model is set, none of the subscriptions would exist.
                this.subscriptions = new Subscription();
            }
            this._model = m;
            var rowsChange = this._model.rowsSelectedChange.subscribe(function () { return _this.updateSelectAllCheckbox(); });
            var dataChange = this._model.dataChange.subscribe(function () {
                if (_this.isDataGrid) {
                    _this.resetTabIndex();
                }
                _this.updateSelectAllCheckbox();
            });
            this.subscriptions.add(rowsChange);
            this.subscriptions.add(dataChange);
            if (this.isDataGrid) {
                var expandedChange = this._model.rowsExpandedChange.subscribe(function () {
                    // Allows the expanded row to have a focus state when it exists in the DOM
                    setTimeout(function () {
                        var expandedRows = _this.elementRef.nativeElement.querySelectorAll(".bx--expandable-row:not(.bx--parent-row)");
                        Array.from(expandedRows).forEach(function (row) {
                            if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {
                                row.firstElementChild.tabIndex = -1;
                            }
                        });
                    });
                });
                this.subscriptions.add(expandedChange);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "isDataGrid", {
        get: function () {
            return this._isDataGrid;
        },
        /**
         * Set to `true` for a data grid with keyboard interactions.
         */
        set: function (value) {
            this._isDataGrid = value;
            if (this.isViewReady) {
                if (value) {
                    this.enableDataGridInteractions();
                }
                else {
                    this.disableDataGridInteractions();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "expandButtonAriaLabel", {
        get: function () {
            return this._expandButtonAriaLabel.value;
        },
        set: function (value) {
            this._expandButtonAriaLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "sortDescendingLabel", {
        get: function () {
            return this._sortDescendingLabel.value;
        },
        set: function (value) {
            this._sortDescendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "sortAscendingLabel", {
        get: function () {
            return this._sortAscendingLabel.value;
        },
        set: function (value) {
            this._sortAscendingLabel.override(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "translations", {
        /**
         * Expects an object that contains some or all of:
         * ```
         * {
         *		"FILTER": "Filter",
         *		"END_OF_DATA": "You've reached the end of your content",
         *		"SCROLL_TOP": "Scroll to top",
         *		"CHECKBOX_HEADER": "Select all rows",
         *		"CHECKBOX_ROW": "Select row"
         * }
         * ```
         */
        set: function (value) {
            var valueWithDefaults = merge(this.i18n.getMultiple("TABLE"), value);
            this._filterTitle.override(valueWithDefaults.FILTER);
            this._endOfDataText.override(valueWithDefaults.END_OF_DATA);
            this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);
            this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);
            this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "noData", {
        get: function () {
            return !this.model.data ||
                this.model.data.length === 0 ||
                this.model.data.length === 1 && this.model.data[0].length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Table.prototype.ngAfterViewInit = function () {
        this.isViewReady = true;
        if (this.isDataGrid) {
            this.enableDataGridInteractions();
        }
    };
    Table.prototype.ngOnDestroy = function () {
        this.subscriptions.unsubscribe();
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
    };
    Table.prototype.enableDataGridInteractions = function () {
        // if we have an `interactioModel` we've already enabled datagrid
        if (this.interactionModel) {
            return;
        }
        var table = this.elementRef.nativeElement.querySelector("table");
        var tableAdapter = new TableDomAdapter(table);
        var keydownEventStream = fromEvent(table, "keydown");
        var clickEventStream = fromEvent(table, "click");
        this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);
        this.positionSubscription = this.interactionModel.position.subscribe(function (event) {
            var _a = tslib_1.__read(event.current, 2), currentRow = _a[0], currentColumn = _a[1];
            var _b = tslib_1.__read(event.previous, 2), previousRow = _b[0], previousColumn = _b[1];
            var currentElement = tableAdapter.getCell(currentRow, currentColumn);
            Table.setTabIndex(currentElement, 0);
            // if the model has just initialized don't focus or reset anything
            if (previousRow === -1 || previousColumn === -1) {
                return;
            }
            // Make the previous cell unfocusable (if it's not the current)
            if (previousRow !== currentRow || previousColumn !== currentColumn) {
                var previousElement = tableAdapter.getCell(previousRow, previousColumn);
                Table.setTabIndex(previousElement, -1);
            }
            Table.focus(currentElement);
        });
        // call this after assigning `this.interactionModel` since it depends on it
        this.resetTabIndex();
    };
    Table.prototype.disableDataGridInteractions = function () {
        // unsubscribe first so we don't cause the focus to fly around
        if (this.positionSubscription) {
            this.positionSubscription.unsubscribe();
        }
        // undo tab indexing (also resets the model)
        this.resetTabIndex(0);
        // null out the model ref
        this.interactionModel = null;
    };
    Table.prototype.onSelectAll = function () {
        this.model.selectAll(true);
        this.selectAll.emit(this.model);
    };
    Table.prototype.onDeselectAll = function () {
        this.model.selectAll(false);
        this.deselectAll.emit(this.model);
    };
    Table.prototype.onSelectRow = function (event) {
        // check for the existence of the selectedRowIndex property
        if (Object.keys(event).includes("selectedRowIndex")) {
            if (this.enableSingleSelect) {
                this.model.selectAll(false);
            }
            this.model.selectRow(event.selectedRowIndex, true);
            this.selectRow.emit(event);
        }
        else {
            this.model.selectRow(event.deselectedRowIndex, false);
            this.deselectRow.emit(event);
        }
    };
    Table.prototype.onRowClick = function (index) {
        this.rowClick.emit(index);
    };
    Table.prototype.updateSelectAllCheckbox = function () {
        var selectedRowsCount = this.model.selectedRowsCount();
        if (selectedRowsCount <= 0) {
            // reset select all checkbox if nothing selected
            this.selectAllCheckbox = false;
            this.selectAllCheckboxSomeSelected = false;
        }
        else if (selectedRowsCount < this.model.data.length) {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = true;
        }
        else {
            this.selectAllCheckbox = true;
            this.selectAllCheckboxSomeSelected = false;
        }
    };
    Table.prototype.resetTabIndex = function (newTabIndex) {
        var _this = this;
        if (newTabIndex === void 0) { newTabIndex = -1; }
        // ensure the view is ready for the reset before we preform the actual reset
        setTimeout(function () {
            // reset all the tabIndexes we can find
            var focusElementList = getFocusElementList(_this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);
            if (focusElementList) {
                focusElementList.forEach(function (tabbable) {
                    tabbable.tabIndex = newTabIndex;
                });
            }
            // reset interaction model positions and tabIndexes
            if (_this.interactionModel) {
                _this.interactionModel.resetTabIndexes(newTabIndex);
            }
        });
    };
    Table.prototype.columnResizeStart = function (event, column) {
        var _this = this;
        this.columnResizeWidth = parseInt(column.style.width, 10);
        this.columnResizeMouseX = event.clientX;
        event.preventDefault();
        this.mouseMoveSubscription = fromEvent(document.body, "mousemove").subscribe(function (event) {
            _this.columnResizeProgress(event, column);
        });
        this.mouseUpSubscription = fromEvent(document.body, "mouseup").subscribe(function (event) {
            _this.columnResizeEnd(event, column);
        });
    };
    Table.prototype.columnResizeProgress = function (event, column) {
        var move = event.clientX - this.columnResizeMouseX;
        column.style.width = this.columnResizeWidth + move + "px";
    };
    Table.prototype.columnResizeEnd = function (event, column) {
        this.mouseMoveSubscription.unsubscribe();
        this.mouseUpSubscription.unsubscribe();
    };
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    Table.prototype.onScroll = function (event) {
        var distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;
        if (distanceFromBottom <= this.scrollLoadDistance) {
            this.scrollLoad.emit(this.model);
        }
        else {
            this.model.isEnd = false;
        }
    };
    Table.prototype.columnDragStart = function (event, columnIndex) {
        this.isColumnDragging = true;
        this.columnDraggedHoverIndex = columnIndex;
        event.dataTransfer.setData("columnIndex", JSON.stringify(columnIndex));
    };
    Table.prototype.columnDragEnd = function (event, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
    };
    Table.prototype.columnDragEnter = function (event, position, columnIndex) {
        this.columnDraggedPosition = position;
        this.columnDraggedHoverIndex = columnIndex;
    };
    Table.prototype.columnDragLeave = function (event, position, columnIndex) {
        this.columnDraggedPosition = "";
    };
    Table.prototype.columnDragover = function (event, position, columnIndex) {
        this.columnDraggedHoverIndex = columnIndex;
        this.columnDraggedPosition = position;
        // needed to tell browser to allow dropping
        event.preventDefault();
    };
    Table.prototype.columnDrop = function (event, position, columnIndex) {
        this.isColumnDragging = false;
        this.columnDraggedHoverIndex = -1;
        this.columnDraggedPosition = "";
        this.model.moveColumn(parseInt(event.dataTransfer.getData("columnIndex"), 10), columnIndex + (position === "right" ? 1 : 0));
    };
    Table.prototype.doSort = function (index) {
        if (this.sort.observers.length === 0) {
            // no sort provided so do the simple sort
            if (this.model.header[index].sorted) {
                // if already sorted flip sorting direction
                this.model.header[index].ascending = this.model.header[index].descending;
            }
            this.model.sort(index);
        }
        this.sort.emit(index);
    };
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    Table.prototype.scrollToTop = function (event) {
        event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;
        this.model.isEnd = false;
    };
    Table.prototype.getSelectionLabelValue = function (row) {
        if (!this.selectionLabelColumn) {
            return { value: this.i18n.get().TABLE.ROW };
        }
        return { value: row[this.selectionLabelColumn].data };
    };
    Table.prototype.getExpandButtonAriaLabel = function () {
        return this._expandButtonAriaLabel.subject;
    };
    Table.prototype.getSortDescendingLabel = function () {
        return this._sortDescendingLabel.subject;
    };
    Table.prototype.getSortAscendingLabel = function () {
        return this._sortAscendingLabel.subject;
    };
    Table.prototype.getCheckboxHeaderLabel = function () {
        return this._checkboxHeaderLabel.subject;
    };
    Table.prototype.getCheckboxRowLabel = function () {
        return this._checkboxRowLabel.subject;
    };
    Table.prototype.getEndOfDataText = function () {
        return this._endOfDataText.subject;
    };
    Table.prototype.getScrollTopText = function () {
        return this._scrollTopText.subject;
    };
    Table.prototype.getFilterTitle = function () {
        return this._filterTitle.subject;
    };
    Table.decorators = [
        { type: Component, args: [{
                    selector: "ibm-table",
                    template: "\n\t<table\n\t\tibmTable\n\t\t[sortable]=\"sortable\"\n\t\t[noBorder]=\"noBorder\"\n\t\t[ngClass]=\"{'bx--data-table--sticky-header': stickyHeader}\"\n\t\t[size]=\"size\"\n\t\t[striped]=\"striped\"\n\t\t[skeleton]=\"skeleton\">\n\t\t<thead\n\t\t\tibmTableHead\n\t\t\t[sortable]=\"sortable\"\n\t\t\t(deselectAll)=\"onDeselectAll()\"\n\t\t\t(selectAll)=\"onSelectAll()\"\n\t\t\t(sort)=\"doSort($event)\"\n\t\t\t[checkboxHeaderLabel]=\"getCheckboxHeaderLabel()\"\n\t\t\t[filterTitle]=\"getFilterTitle()\"\n\t\t\t[model]=\"model\"\n\t\t\t[size]=\"size\"\n\t\t\t[selectAllCheckbox]=\"selectAllCheckbox\"\n\t\t\t[selectAllCheckboxSomeSelected]=\"selectAllCheckboxSomeSelected\"\n\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t[skeleton]=\"skeleton\"\n\t\t\t[sortAscendingLabel]=\"sortAscendingLabel\"\n\t\t\t[sortDescendingLabel]=\"sortDescendingLabel\"\n\t\t\t[stickyHeader]=\"stickyHeader\">\n\t\t</thead>\n\t\t<tbody\n\t\t\tibmTableBody\n\t\t\t(deselectRow)=\"onSelectRow($event)\"\n\t\t\t(scroll)=\"onScroll($event)\"\n\t\t\t(selectRow)=\"onSelectRow($event)\"\n\t\t\t[checkboxRowLabel]=\"getCheckboxRowLabel()\"\n\t\t\t[enableSingleSelect]=\"enableSingleSelect\"\n\t\t\t(rowClick)=\"onRowClick($event)\"\n\t\t\t[expandButtonAriaLabel]=\"expandButtonAriaLabel\"\n\t\t\t[model]=\"model\"\n\t\t\t[size]=\"size\"\n\t\t\t[ngStyle]=\"{'overflow-y': 'scroll'}\"\n\t\t\t[selectionLabelColumn]=\"selectionLabelColumn\"\n\t\t\t[showSelectionColumn]=\"showSelectionColumn\"\n\t\t\t[skeleton]=\"skeleton\"\n\t\t\t*ngIf=\"!noData; else noDataTemplate\">\n\t\t</tbody>\n\t\t<ng-template #noDataTemplate><ng-content></ng-content></ng-template>\n\t\t<tfoot>\n\t\t\t<ng-template\n\t\t\t\t[ngTemplateOutlet]=\"footerTemplate\">\n\t\t\t</ng-template>\n\t\t\t<tr *ngIf=\"this.model.isLoading\">\n\t\t\t\t<td class=\"table_loading-indicator\">\n\t\t\t\t\t<div class=\"bx--loading bx--loading--small\">\n\t\t\t\t\t\t<svg class=\"bx--loading__svg\" viewBox=\"-75 -75 150 150\">\n\t\t\t\t\t\t\t<circle class=\"bx--loading__stroke\" cx=\"0\" cy=\"0\" r=\"37.5\" />\n\t\t\t\t\t\t</svg>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr *ngIf=\"this.model.isEnd\">\n\t\t\t\t<td class=\"table_end-indicator\">\n\t\t\t\t\t<h5>{{getEndOfDataText() | async}}</h5>\n\t\t\t\t\t<button (click)=\"scrollToTop($event)\" class=\"btn--secondary-sm\">\n\t\t\t\t\t\t{{getScrollTopText() | async}}\n\t\t\t\t\t</button>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tfoot>\n\t</table>\n\t"
                }] }
    ];
    /** @nocollapse */
    Table.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ApplicationRef },
        { type: I18n }
    ]; };
    Table.propDecorators = {
        model: [{ type: Input }],
        size: [{ type: Input }],
        skeleton: [{ type: Input }],
        isDataGrid: [{ type: Input }],
        sortable: [{ type: Input }],
        noBorder: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        enableSingleSelect: [{ type: Input }],
        scrollLoadDistance: [{ type: Input }],
        columnsResizable: [{ type: Input }],
        columnsDraggable: [{ type: Input }],
        expandButtonAriaLabel: [{ type: Input }],
        sortDescendingLabel: [{ type: Input }],
        sortAscendingLabel: [{ type: Input }],
        translations: [{ type: Input }],
        striped: [{ type: Input }],
        stickyHeader: [{ type: HostBinding, args: ["class.bx--data-table_inner-container",] }, { type: Input }],
        footerTemplate: [{ type: Input }],
        selectionLabelColumn: [{ type: Input }],
        sort: [{ type: Output }],
        selectAll: [{ type: Output }],
        deselectAll: [{ type: Output }],
        selectRow: [{ type: Output }],
        deselectRow: [{ type: Output }],
        rowClick: [{ type: Output }],
        scrollLoad: [{ type: Output }]
    };
    return Table;
}());
export { Table };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci90YWJsZS8iLCJzb3VyY2VzIjpbInRhYmxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxjQUFjLEVBQ2QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osVUFBVSxFQUVWLFdBQVcsRUFFWCxXQUFXLEVBQ1gsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFFM0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUM1RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFL0MsT0FBTyxFQUFFLG1CQUFtQixFQUFFLDhCQUE4QixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDdkcsT0FBTyxFQUFFLElBQUksRUFBZSxNQUFNLGdDQUFnQyxDQUFDO0FBQ25FLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUN4RCxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUMvRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHeEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0pHO0FBQ0g7SUFnY0M7O09BRUc7SUFDSCxlQUNXLFVBQXNCLEVBQ3RCLGNBQThCLEVBQzlCLElBQVU7UUFGVixlQUFVLEdBQVYs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S0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0QXBwbGljYXRpb25SZWYsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0RWxlbWVudFJlZixcblx0QWZ0ZXJWaWV3SW5pdCxcblx0VGVtcGxhdGVSZWYsXG5cdE9uRGVzdHJveSxcblx0SG9zdEJpbmRpbmdcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgZnJvbUV2ZW50LCBPYnNlcnZhYmxlIH0gZnJvbSBcInJ4anNcIjtcblxuaW1wb3J0IHsgVGFibGVNb2RlbCB9IGZyb20gXCIuL3RhYmxlLW1vZGVsLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZUhlYWRlckl0ZW0gfSBmcm9tIFwiLi90YWJsZS1oZWFkZXItaXRlbS5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVJdGVtIH0gZnJvbSBcIi4vdGFibGUtaXRlbS5jbGFzc1wiO1xuXG5pbXBvcnQgeyBnZXRGb2N1c0VsZW1lbnRMaXN0LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXggfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jb21tb25cIjtcbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuaW1wb3J0IHsgRGF0YUdyaWRJbnRlcmFjdGlvbk1vZGVsIH0gZnJvbSBcIi4vZGF0YS1ncmlkLWludGVyYWN0aW9uLW1vZGVsLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZURvbUFkYXB0ZXIgfSBmcm9tIFwiLi90YWJsZS1hZGFwdGVyLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZVJvd1NpemUgfSBmcm9tIFwiLi90YWJsZS50eXBlc1wiO1xuXG4vKipcbiAqIEJ1aWxkIHlvdXIgdGFibGUgd2l0aCB0aGlzIGNvbXBvbmVudCBieSBleHRlbmRpbmcgdGhpbmdzIHRoYXQgZGlmZmVyIGZyb20gZGVmYXVsdC5cbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLXRhYmxlLS1iYXNpYylcbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSB1c3VhbCB3cml0ZS15b3VyLW93bi1odG1sIGFwcHJvYWNoIHlvdSBoYWQgd2l0aCBgPHRhYmxlPmAsXG4gKiBjYXJib24gdGFibGUgdXNlcyBtb2RlbC12aWV3LWNvbnRyb2xsZXIgYXBwcm9hY2guXG4gKlxuICogSGVyZSwgeW91IGNyZWF0ZSBhIHZpZXcgKHdpdGggYnVpbHQtaW4gY29udHJvbGxlcikgYW5kIHByb3ZpZGUgaXQgYSBtb2RlbC5cbiAqIENoYW5nZXMgeW91IG1ha2UgdG8gdGhlIG1vZGVsIGFyZSByZWZsZWN0ZWQgaW4gdGhlIHZpZXcuIFByb3ZpZGUgc2FtZSBtb2RlbCB5b3UgdXNlXG4gKiBpbiB0aGUgdGFibGUgdG8gdGhlIGA8aWJtLXBhZ2luYXRpb24+YCBjb21wb25lbnRzLlxuICogVGhleSBwcm92aWRlIGEgZGlmZmVyZW50IHZpZXcgb3ZlciB0aGUgc2FtZSBkYXRhLlxuICpcbiAqICMjIEJhc2ljIHVzYWdlXG4gKlxuICogYGBgaHRtbFxuICogPGlibS10YWJsZSBbbW9kZWxdPVwibW9kZWxcIj48L2libS10YWJsZT5cbiAqIGBgYFxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIHB1YmxpYyBtb2RlbCA9IG5ldyBUYWJsZU1vZGVsKCk7XG4gKlxuICogdGhpcy5tb2RlbC5kYXRhID0gW1xuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJhc2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJxd2VyXCJ9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInp3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiYnNkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwic3dlclwifSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJjc2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ0d2VyXCJ9KV1cbiAqIF07XG4gKiBgYGBcbiAqXG4gKiAjIyBDdXN0b21pemF0aW9uXG4gKlxuICogSWYgeW91IGhhdmUgY3VzdG9tIGRhdGEgaW4geW91ciB0YWJsZSwgeW91IG5lZWQgYSB3YXkgdG8gZGlzcGxheSBpdC4gWW91IGNhbiBkbyB0aGF0XG4gKiBieSBwcm92aWRpbmcgYSB0ZW1wbGF0ZSB0byBgVGFibGVJdGVtYC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8bmctdGVtcGxhdGUgI2N1c3RvbVRhYmxlSXRlbVRlbXBsYXRlIGxldC1kYXRhPVwiZGF0YVwiPlxuICogXHQ8YSBbcm91dGVyTGlua109XCJkYXRhLmxpbmtcIj57e2RhdGEubmFtZX19IHt7ZGF0YS5zdXJuYW1lfX08L2E+XG4gKiA8L25nLXRlbXBsYXRlPlxuICogYGBgXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY3VzdG9tVGFibGVJdGVtVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gKlxuICogdGhpcy5jdXN0b21Nb2RlbC5kYXRhID0gW1xuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJhc2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YToge25hbWU6IFwiTGVzc3lcIiwgbGluazogXCIvdGFibGVcIn0sIHRlbXBsYXRlOiB0aGlzLmN1c3RvbVRhYmxlSXRlbVRlbXBsYXRlfSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJjc2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJzd2VyXCJ9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImJzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiB7bmFtZTogXCJBbGljZVwiLCBzdXJuYW1lOiBcIkJvYlwifSwgdGVtcGxhdGU6IHRoaXMuY3VzdG9tVGFibGVJdGVtVGVtcGxhdGV9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXSxcbiAqIF07XG4gKiBgYGBcbiAqXG4gKiAjIyMgU29ydGluZyBhbmQgZmlsdGVyaW5nXG4gKlxuICogSW4gY2FzZSB5b3UgbmVlZCBjdXN0b20gc29ydGluZyBhbmQvb3IgZmlsdGVyaW5nIHlvdSBzaG91bGQgc3ViY2xhc3MgYFRhYmxlSGVhZGVySXRlbWBcbiAqIGFuZCBvdmVycmlkZSBuZWVkZWQgZnVuY3Rpb25zLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNsYXNzIEZpbHRlcmFibGVIZWFkZXJJdGVtIGV4dGVuZHMgVGFibGVIZWFkZXJJdGVtIHtcbiAqIFx0Ly8gY3VzdG9tIGZpbHRlciBmdW5jdGlvblxuICogXHRmaWx0ZXIoaXRlbTogVGFibGVJdGVtKTogYm9vbGVhbiB7XG4gKiBcdFx0aWYgKHR5cGVvZiBpdGVtLmRhdGEgPT09IFwic3RyaW5nXCIgJiYgaXRlbS5kYXRhLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlckRhdGEuZGF0YS50b0xvd2VyQ2FzZSgpKSA+PSAwIHx8XG4gKiBcdFx0aXRlbS5kYXRhLm5hbWUgJiYgaXRlbS5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyRGF0YS5kYXRhLnRvTG93ZXJDYXNlKCkpID49IDAgfHxcbiAqIFx0XHRpdGVtLmRhdGEuc3VybmFtZSAmJiBpdGVtLmRhdGEuc3VybmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXJEYXRhLmRhdGEudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuICogXHRcdFx0cmV0dXJuIGZhbHNlO1xuICogXHRcdH1cbiAqIFx0XHRyZXR1cm4gdHJ1ZTtcbiAqIFx0fVxuICpcbiAqIFx0c2V0IGZpbHRlckNvdW50KG4pIHt9XG4gKiBcdGdldCBmaWx0ZXJDb3VudCgpIHtcbiAqIFx0XHRyZXR1cm4gKHRoaXMuZmlsdGVyRGF0YSAmJiB0aGlzLmZpbHRlckRhdGEuZGF0YSAmJiB0aGlzLmZpbHRlckRhdGEuZGF0YS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICogXHR9XG4gKlxuICogXHQvLyB1c2VkIGZvciBjdXN0b20gc29ydGluZ1xuICogXHRjb21wYXJlKG9uZTogVGFibGVJdGVtLCB0d286IFRhYmxlSXRlbSkge1xuICogXHRcdGNvbnN0IHN0cmluZ09uZSA9IChvbmUuZGF0YS5uYW1lIHx8IG9uZS5kYXRhLnN1cm5hbWUgfHwgb25lLmRhdGEpLnRvTG93ZXJDYXNlKCk7XG4gKiBcdFx0Y29uc3Qgc3RyaW5nVHdvID0gKHR3by5kYXRhLm5hbWUgfHwgdHdvLmRhdGEuc3VybmFtZSB8fCB0d28uZGF0YSkudG9Mb3dlckNhc2UoKTtcbiAqXG4gKiBcdFx0aWYgKHN0cmluZ09uZSA+IHN0cmluZ1R3bykge1xuICogXHRcdFx0cmV0dXJuIDE7XG4gKiBcdFx0fSBlbHNlIGlmIChzdHJpbmdPbmUgPCBzdHJpbmdUd28pIHtcbiAqIFx0XHRcdHJldHVybiAtMTtcbiAqIFx0XHR9IGVsc2Uge1xuICogXHRcdFx0cmV0dXJuIDA7XG4gKiBcdFx0fVxuICogXHR9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBkbyB5b3VyIHNvcnRpbmcgb24gdGhlIGJhY2tlbmQgb3IgcXVlcnkgZm9yIHNvcnRlZCBkYXRhIGFzIGEgcmVzdWx0IG9mIHVzZXJcbiAqIGNsaWNraW5nIHRoZSB0YWJsZSBoZWFkZXIsIGNoZWNrIHRhYmxlIFtgc29ydGBdKCNzb3J0KSBvdXRwdXQgZG9jdW1lbnRhdGlvblxuICpcbiAqIFNlZSBgVGFibGVIZWFkZXJJdGVtYCBjbGFzcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAjIyBObyBkYXRhIHRlbXBsYXRlXG4gKlxuICogV2hlbiB0YWJsZSBoYXMgbm8gZGF0YSB0byBzaG93LCBpdCBjYW4gc2hvdyBhIG1lc3NhZ2UgeW91IHByb3ZpZGUgaXQgaW5zdGVhZC5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aWJtLXRhYmxlIFttb2RlbF09XCJtb2RlbFwiPk5vIGRhdGEuPC9pYm0tdGFibGU+XG4gKiBgYGBcbiAqXG4gKiAuLi4gd2lsbCBzaG93IGBObyBkYXRhLmAgbWVzc2FnZSwgYnV0IHlvdSBjYW4gZ2V0IGNyZWF0aXZlIGFuZCBwcm92aWRlIGFueSB0ZW1wbGF0ZSB5b3Ugd2FudFxuICogdG8gcmVwbGFjZSB0YWJsZSdzIGRlZmF1bHQgYHRib2R5YC5cbiAqXG4gKiAjIyBVc2UgcGFnaW5hdGlvbiBhcyB0YWJsZSBmb290ZXJcbiAqXG4gKiBgYGBodG1sXG4gKiA8aWJtLXBhZ2luYXRpb24gW21vZGVsXT1cIm1vZGVsXCIgKHNlbGVjdFBhZ2UpPVwic2VsZWN0UGFnZSgkZXZlbnQpXCI+PC9pYm0tcGFnaW5hdGlvbj5cbiAqIGBgYFxuICpcbiAqIGBzZWxlY3RQYWdlKClgIGZ1bmN0aW9uIHNob3VsZCBmZXRjaCB0aGUgZGF0YSBmcm9tIGJhY2tlbmQsIGNyZWF0ZSBuZXcgYGRhdGFgLCBhcHBseSBpdCB0byBgbW9kZWwuZGF0YWAsXG4gKiBhbmQgdXBkYXRlIGBtb2RlbC5jdXJyZW50UGFnZWAuXG4gKlxuICogSWYgdGhlIGRhdGEgeW91ciBzZXJ2ZXIgcmV0dXJucyBpcyBhIHR3byBkaW1lbnNpb25hbCBhcnJheSBvZiBvYmplY3RzLCBpdCB3b3VsZCBsb29rIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogc2VsZWN0UGFnZShwYWdlKSB7XG4gKiBcdHRoaXMuZ2V0UGFnZShwYWdlKS50aGVuKChkYXRhOiBBcnJheTxBcnJheTxhbnk+PikgPT4ge1xuICogXHRcdC8vIHNldCB0aGUgZGF0YSBhbmQgdXBkYXRlIHBhZ2VcbiAqIFx0XHR0aGlzLm1vZGVsLmRhdGEgPSB0aGlzLnByZXBhcmVEYXRhKGRhdGEpO1xuICogXHRcdHRoaXMubW9kZWwuY3VycmVudFBhZ2UgPSBwYWdlO1xuICogXHR9KTtcbiAqIH1cbiAqXG4gKiBwcm90ZWN0ZWQgcHJlcGFyZURhdGEoZGF0YTogQXJyYXk8QXJyYXk8YW55Pj4pIHtcbiAqIFx0Ly8gY3JlYXRlIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZpY2UgZGF0YVxuICogXHRsZXQgbmV3RGF0YSA9IFtdO1xuICogXHRkYXRhLmZvckVhY2goZGF0YVJvdyA9PiB7XG4gKiBcdFx0bGV0IHJvdyA9IFtdO1xuICogXHRcdGRhdGFSb3cuZm9yRWFjaChkYXRhRWxlbWVudCA9PiB7XG4gKiBcdFx0XHRyb3cucHVzaChuZXcgVGFibGVJdGVtKHtcbiAqIFx0XHRcdFx0ZGF0YTogZGF0YUVsZW1lbnQsXG4gKiBcdFx0XHRcdHRlbXBsYXRlOiB0eXBlb2YgZGF0YUVsZW1lbnQgPT09IFwic3RyaW5nXCIgPyB1bmRlZmluZWQgOiB0aGlzLnBhZ2luYXRpb25UYWJsZUl0ZW1UZW1wbGF0ZVxuICogXHRcdFx0XHQvLyB5b3VyIHRlbXBsYXRlIGNhbiBoYW5kbGUgYWxsIHRoZSBkYXRhIHR5cGVzIHNvIHlvdSBkb24ndCBoYXZlIHRvIGNvbmRpdGlvbmFsbHkgc2V0IGl0XG4gKiBcdFx0XHRcdC8vIHlvdSBjYW4gYWxzbyBzZXQgZGlmZmVyZW50IHRlbXBsYXRlcyBmb3IgZGlmZmVyZW50IGNvbHVtbnMgYmFzZWQgb24gaW5kZXhcbiAqIFx0XHRcdH0pKTtcbiAqIFx0XHR9KTtcbiAqIFx0XHRuZXdEYXRhLnB1c2gocm93KTtcbiAqIFx0fSk7XG4gKiBcdHJldHVybiBuZXdEYXRhO1xuICogfVxuICogYGBgXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNvbXBvbmVudHMtdGFibGUtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS10YWJsZVwiLFxuXHR0ZW1wbGF0ZTogYFxuXHQ8dGFibGVcblx0XHRpYm1UYWJsZVxuXHRcdFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG5cdFx0W25vQm9yZGVyXT1cIm5vQm9yZGVyXCJcblx0XHRbbmdDbGFzc109XCJ7J2J4LS1kYXRhLXRhYmxlLS1zdGlja3ktaGVhZGVyJzogc3RpY2t5SGVhZGVyfVwiXG5cdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0W3N0cmlwZWRdPVwic3RyaXBlZFwiXG5cdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCI+XG5cdFx0PHRoZWFkXG5cdFx0XHRpYm1UYWJsZUhlYWRcblx0XHRcdFtzb3J0YWJsZV09XCJzb3J0YWJsZVwiXG5cdFx0XHQoZGVzZWxlY3RBbGwpPVwib25EZXNlbGVjdEFsbCgpXCJcblx0XHRcdChzZWxlY3RBbGwpPVwib25TZWxlY3RBbGwoKVwiXG5cdFx0XHQoc29ydCk9XCJkb1NvcnQoJGV2ZW50KVwiXG5cdFx0XHRbY2hlY2tib3hIZWFkZXJMYWJlbF09XCJnZXRDaGVja2JveEhlYWRlckxhYmVsKClcIlxuXHRcdFx0W2ZpbHRlclRpdGxlXT1cImdldEZpbHRlclRpdGxlKClcIlxuXHRcdFx0W21vZGVsXT1cIm1vZGVsXCJcblx0XHRcdFtzaXplXT1cInNpemVcIlxuXHRcdFx0W3NlbGVjdEFsbENoZWNrYm94XT1cInNlbGVjdEFsbENoZWNrYm94XCJcblx0XHRcdFtzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZF09XCJzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZFwiXG5cdFx0XHRbc2hvd1NlbGVjdGlvbkNvbHVtbl09XCJzaG93U2VsZWN0aW9uQ29sdW1uXCJcblx0XHRcdFtlbmFibGVTaW5nbGVTZWxlY3RdPVwiZW5hYmxlU2luZ2xlU2VsZWN0XCJcblx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiXG5cdFx0XHRbc29ydEFzY2VuZGluZ0xhYmVsXT1cInNvcnRBc2NlbmRpbmdMYWJlbFwiXG5cdFx0XHRbc29ydERlc2NlbmRpbmdMYWJlbF09XCJzb3J0RGVzY2VuZGluZ0xhYmVsXCJcblx0XHRcdFtzdGlja3lIZWFkZXJdPVwic3RpY2t5SGVhZGVyXCI+XG5cdFx0PC90aGVhZD5cblx0XHQ8dGJvZHlcblx0XHRcdGlibVRhYmxlQm9keVxuXHRcdFx0KGRlc2VsZWN0Um93KT1cIm9uU2VsZWN0Um93KCRldmVudClcIlxuXHRcdFx0KHNjcm9sbCk9XCJvblNjcm9sbCgkZXZlbnQpXCJcblx0XHRcdChzZWxlY3RSb3cpPVwib25TZWxlY3RSb3coJGV2ZW50KVwiXG5cdFx0XHRbY2hlY2tib3hSb3dMYWJlbF09XCJnZXRDaGVja2JveFJvd0xhYmVsKClcIlxuXHRcdFx0W2VuYWJsZVNpbmdsZVNlbGVjdF09XCJlbmFibGVTaW5nbGVTZWxlY3RcIlxuXHRcdFx0KHJvd0NsaWNrKT1cIm9uUm93Q2xpY2soJGV2ZW50KVwiXG5cdFx0XHRbZXhwYW5kQnV0dG9uQXJpYUxhYmVsXT1cImV4cGFuZEJ1dHRvbkFyaWFMYWJlbFwiXG5cdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0W3NpemVdPVwic2l6ZVwiXG5cdFx0XHRbbmdTdHlsZV09XCJ7J292ZXJmbG93LXknOiAnc2Nyb2xsJ31cIlxuXHRcdFx0W3NlbGVjdGlvbkxhYmVsQ29sdW1uXT1cInNlbGVjdGlvbkxhYmVsQ29sdW1uXCJcblx0XHRcdFtzaG93U2VsZWN0aW9uQ29sdW1uXT1cInNob3dTZWxlY3Rpb25Db2x1bW5cIlxuXHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCJcblx0XHRcdCpuZ0lmPVwiIW5vRGF0YTsgZWxzZSBub0RhdGFUZW1wbGF0ZVwiPlxuXHRcdDwvdGJvZHk+XG5cdFx0PG5nLXRlbXBsYXRlICNub0RhdGFUZW1wbGF0ZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT5cblx0XHQ8dGZvb3Q+XG5cdFx0XHQ8bmctdGVtcGxhdGVcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiZm9vdGVyVGVtcGxhdGVcIj5cblx0XHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0XHQ8dHIgKm5nSWY9XCJ0aGlzLm1vZGVsLmlzTG9hZGluZ1wiPlxuXHRcdFx0XHQ8dGQgY2xhc3M9XCJ0YWJsZV9sb2FkaW5nLWluZGljYXRvclwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJieC0tbG9hZGluZyBieC0tbG9hZGluZy0tc21hbGxcIj5cblx0XHRcdFx0XHRcdDxzdmcgY2xhc3M9XCJieC0tbG9hZGluZ19fc3ZnXCIgdmlld0JveD1cIi03NSAtNzUgMTUwIDE1MFwiPlxuXHRcdFx0XHRcdFx0XHQ8Y2lyY2xlIGNsYXNzPVwiYngtLWxvYWRpbmdfX3N0cm9rZVwiIGN4PVwiMFwiIGN5PVwiMFwiIHI9XCIzNy41XCIgLz5cblx0XHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3RkPlxuXHRcdFx0PC90cj5cblx0XHRcdDx0ciAqbmdJZj1cInRoaXMubW9kZWwuaXNFbmRcIj5cblx0XHRcdFx0PHRkIGNsYXNzPVwidGFibGVfZW5kLWluZGljYXRvclwiPlxuXHRcdFx0XHRcdDxoNT57e2dldEVuZE9mRGF0YVRleHQoKSB8IGFzeW5jfX08L2g1PlxuXHRcdFx0XHRcdDxidXR0b24gKGNsaWNrKT1cInNjcm9sbFRvVG9wKCRldmVudClcIiBjbGFzcz1cImJ0bi0tc2Vjb25kYXJ5LXNtXCI+XG5cdFx0XHRcdFx0XHR7e2dldFNjcm9sbFRvcFRleHQoKSB8IGFzeW5jfX1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC90ZD5cblx0XHRcdDwvdHI+XG5cdFx0PC90Zm9vdD5cblx0PC90YWJsZT5cblx0YFxufSlcbmV4cG9ydCBjbGFzcyBUYWJsZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc2tlbGV0b24gbW9kZWwgd2l0aCBhIHJvdyBhbmQgY29sdW1uIGNvdW50IHNwZWNpZmllZCBieSB0aGUgdXNlclxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBgYGB0eXBlc2NyaXB0XG5cdCAqIHRoaXMubW9kZWwgPSBUYWJsZS5za2VsZXRvbk1vZGVsKDUsIDUpO1xuXHQgKiBgYGBcblx0ICovXG5cdHN0YXRpYyBza2VsZXRvbk1vZGVsKHJvd0NvdW50OiBudW1iZXIsIGNvbHVtbkNvdW50OiBudW1iZXIpIHtcblx0XHRjb25zdCBtb2RlbCA9IG5ldyBUYWJsZU1vZGVsKCk7XG5cdFx0bGV0IGhlYWRlciA9IG5ldyBBcnJheTxUYWJsZUhlYWRlckl0ZW0+KCk7XG5cdFx0bGV0IGRhdGEgPSBuZXcgQXJyYXk8QXJyYXk8VGFibGVJdGVtPj4oKTtcblx0XHRsZXQgcm93ID0gbmV3IEFycmF5PFRhYmxlSXRlbT4oKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuXHRcdFx0aGVhZGVyLnB1c2gobmV3IFRhYmxlSGVhZGVySXRlbSgpKTtcblx0XHRcdHJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oKSk7XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQgLSAxOyBpKyspIHtcblx0XHRcdGRhdGEucHVzaChyb3cpO1xuXHRcdH1cblxuXHRcdG1vZGVsLmhlYWRlciA9IGhlYWRlcjtcblx0XHRtb2RlbC5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gbW9kZWw7XG5cdH1cblxuXHRzdGF0aWMgc2V0VGFiSW5kZXgoZWxlbWVudDogSFRNTEVsZW1lbnQsIGluZGV4OiAtMSB8IDApIHtcblx0XHRjb25zdCBmb2N1c0VsZW1lbnRMaXN0ID0gZ2V0Rm9jdXNFbGVtZW50TGlzdChlbGVtZW50LCB0YWJiYWJsZVNlbGVjdG9ySWdub3JlVGFiSW5kZXgpO1xuXHRcdGlmIChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkICYmIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYngtLXRhYmxlLXNvcnRcIikgJiYgZm9jdXNFbGVtZW50TGlzdC5sZW5ndGggPiAxKSB7XG5cdFx0XHRmb2N1c0VsZW1lbnRMaXN0WzFdLnRhYkluZGV4ID0gaW5kZXg7XG5cdFx0fSBlbHNlIGlmIChmb2N1c0VsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvY3VzRWxlbWVudExpc3RbMF0udGFiSW5kZXggPSBpbmRleDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbWVudC50YWJJbmRleCA9IGluZGV4O1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBmb2N1cyhlbGVtZW50OiBIVE1MRWxlbWVudCkge1xuXHRcdGNvbnN0IGZvY3VzRWxlbWVudExpc3QgPSBnZXRGb2N1c0VsZW1lbnRMaXN0KGVsZW1lbnQsIHRhYmJhYmxlU2VsZWN0b3JJZ25vcmVUYWJJbmRleCk7XG5cdFx0aWYgKGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQgJiYgZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJieC0tdGFibGUtc29ydFwiKSAmJiBmb2N1c0VsZW1lbnRMaXN0Lmxlbmd0aCA+IDEpIHtcblx0XHRcdGZvY3VzRWxlbWVudExpc3RbMV0uZm9jdXMoKTtcblx0XHR9IGVsc2UgaWYgKGZvY3VzRWxlbWVudExpc3QubGVuZ3RoID4gMCkge1xuXHRcdFx0Zm9jdXNFbGVtZW50TGlzdFswXS5mb2N1cygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIGBUYWJsZU1vZGVsYCB3aXRoIGRhdGEgdGhlIHRhYmxlIGlzIHRvIGRpc3BsYXkuXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRzZXQgbW9kZWwobTogVGFibGVNb2RlbCkge1xuXHRcdGlmICh0aGlzLl9tb2RlbCkge1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHQvLyBOZWVkIHRvIGNyZWF0ZSBhIG5ldyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgaGVyZSBiZWNhdXNlIHVuc3Vic2NyaWJpbmcgcHJldmVudHMgYW55IG5ldyBzdWJzY3JpcHRpb25zXG5cdFx0XHQvLyBmcm9tIGJlaW5nIGFkZGVkIGZvciBzb21lIHJlYXNvbi4gV2hlbiBhIG5ldyBtb2RlbCBpcyBzZXQsIG5vbmUgb2YgdGhlIHN1YnNjcmlwdGlvbnMgd291bGQgZXhpc3QuXG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbW9kZWwgPSBtO1xuXG5cdFx0Y29uc3Qgcm93c0NoYW5nZSA9IHRoaXMuX21vZGVsLnJvd3NTZWxlY3RlZENoYW5nZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVTZWxlY3RBbGxDaGVja2JveCgpKTtcblx0XHRjb25zdCBkYXRhQ2hhbmdlID0gdGhpcy5fbW9kZWwuZGF0YUNoYW5nZS5zdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0aWYgKHRoaXMuaXNEYXRhR3JpZCkge1xuXHRcdFx0XHR0aGlzLnJlc2V0VGFiSW5kZXgoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlU2VsZWN0QWxsQ2hlY2tib3goKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQocm93c0NoYW5nZSk7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLmFkZChkYXRhQ2hhbmdlKTtcblxuXHRcdGlmICh0aGlzLmlzRGF0YUdyaWQpIHtcblx0XHRcdGNvbnN0IGV4cGFuZGVkQ2hhbmdlID0gdGhpcy5fbW9kZWwucm93c0V4cGFuZGVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG5cdFx0XHRcdC8vIEFsbG93cyB0aGUgZXhwYW5kZWQgcm93IHRvIGhhdmUgYSBmb2N1cyBzdGF0ZSB3aGVuIGl0IGV4aXN0cyBpbiB0aGUgRE9NXG5cdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGV4cGFuZGVkUm93cyA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuYngtLWV4cGFuZGFibGUtcm93Om5vdCguYngtLXBhcmVudC1yb3cpXCIpO1xuXHRcdFx0XHRcdEFycmF5LmZyb208YW55PihleHBhbmRlZFJvd3MpLmZvckVhY2gocm93ID0+IHtcblx0XHRcdFx0XHRcdGlmIChyb3cuZmlyc3RFbGVtZW50Q2hpbGQudGFiSW5kZXggPT09IHVuZGVmaW5lZCB8fCByb3cuZmlyc3RFbGVtZW50Q2hpbGQudGFiSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdHJvdy5maXJzdEVsZW1lbnRDaGlsZC50YWJJbmRleCA9IC0xO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0dGhpcy5zdWJzY3JpcHRpb25zLmFkZChleHBhbmRlZENoYW5nZSk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IG1vZGVsKCk6IFRhYmxlTW9kZWwge1xuXHRcdHJldHVybiB0aGlzLl9tb2RlbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSB0YWJsZSByb3dzLlxuXHQgKi9cblx0QElucHV0KCkgc2l6ZTogVGFibGVSb3dTaXplID0gXCJtZFwiO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIHRhYmxlLlxuXHQgKi9cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgZm9yIGEgZGF0YSBncmlkIHdpdGgga2V5Ym9hcmQgaW50ZXJhY3Rpb25zLlxuXHQgKi9cblx0QElucHV0KCkgc2V0IGlzRGF0YUdyaWQodmFsdWU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLl9pc0RhdGFHcmlkID0gdmFsdWU7XG5cdFx0aWYgKHRoaXMuaXNWaWV3UmVhZHkpIHtcblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHR0aGlzLmVuYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRpc2FibGVEYXRhR3JpZEludGVyYWN0aW9ucygpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXR0aW5nIHNvcnRhYmxlIHRvIGZhbHNlIHdpbGwgZGlzYWJsZSBhbGwgaGVhZGVycyBpbmNsdWRpbmcgaGVhZGVycyB3aGljaCBhcmUgc29ydGFibGUuIElzIGlzXG5cdCAqIHBvc3NpYmxlIHRvIHNldCB0aGUgc29ydGFibGUgc3RhdGUgb24gdGhlIGhlYWRlciBpdGVtIHRvIGRpc2FibGUvZW5hYmxlIHNvcnRpbmcgZm9yIG9ubHkgc29tZSBoZWFkZXJzLlxuXHQgKi9cblx0QElucHV0KCkgc29ydGFibGUgPSB0cnVlO1xuXG5cdEBJbnB1dCgpIG5vQm9yZGVyID0gdHJ1ZTtcblxuXHRnZXQgaXNEYXRhR3JpZCgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5faXNEYXRhR3JpZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb250cm9scyB3aGV0aGVyIHRvIHNob3cgdGhlIHNlbGVjdGlvbiBjaGVja2JveGVzIGNvbHVtbiBvciBub3QuXG5cdCAqL1xuXHRASW5wdXQoKSBzaG93U2VsZWN0aW9uQ29sdW1uID0gdHJ1ZTtcblxuXHQvKipcblx0ICogQ29udHJvbHMgd2hldGhlciB0byBlbmFibGUgbXVsdGlwbGUgb3Igc2luZ2xlIHJvdyBzZWxlY3Rpb24uXG5cdCAqL1xuXHRASW5wdXQoKSBlbmFibGVTaW5nbGVTZWxlY3QgPSBmYWxzZTtcblxuXHQvKipcblx0ICogRGlzdGFuY2UgKGluIHB4KSBmcm9tIHRoZSBib3R0b20gdGhhdCB2aWV3IGhhcyB0byByZWFjaCBiZWZvcmVcblx0ICogYHNjcm9sbExvYWRgIGV2ZW50IGlzIGVtaXR0ZWQuXG5cdCAqL1xuXHRASW5wdXQoKSBzY3JvbGxMb2FkRGlzdGFuY2UgPSAwO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIHRvIGVuYWJsZSB1c2VycyB0byByZXNpemUgY29sdW1ucy5cblx0ICpcblx0ICogV29ya3MgZm9yIGNvbHVtbnMgd2l0aCB3aWR0aCBzZXQgaW4gcGl4ZWxzLlxuXHQgKlxuXHQgKi9cblx0QElucHV0KCkgY29sdW1uc1Jlc2l6YWJsZSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIHRvIGVuYWJsZSB1c2VycyB0byBkcmFnIGFuZCBkcm9wIGNvbHVtbnMuXG5cdCAqXG5cdCAqIENoYW5naW5nIHRoZSBjb2x1bW4gb3JkZXIgaW4gdGFibGUgY2hhbmdlcyB0YWJsZSBtb2RlbC4gQmUgYXdhcmUgb2YgaXQgd2hlbiB5b3UgYWRkIGFkZGl0aW9uYWwgZGF0YVxuXHQgKiB0byB0aGUgbW9kZWwuXG5cdCAqXG5cdCAqL1xuXHRASW5wdXQoKSBjb2x1bW5zRHJhZ2dhYmxlID0gZmFsc2U7XG5cblx0QElucHV0KClcblx0c2V0IGV4cGFuZEJ1dHRvbkFyaWFMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fZXhwYW5kQnV0dG9uQXJpYUxhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXHRnZXQgZXhwYW5kQnV0dG9uQXJpYUxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9leHBhbmRCdXR0b25BcmlhTGFiZWwudmFsdWU7XG5cdH1cblx0QElucHV0KClcblx0c2V0IHNvcnREZXNjZW5kaW5nTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX3NvcnREZXNjZW5kaW5nTGFiZWwub3ZlcnJpZGUodmFsdWUpO1xuXHR9XG5cdGdldCBzb3J0RGVzY2VuZGluZ0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3J0RGVzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cdEBJbnB1dCgpXG5cdHNldCBzb3J0QXNjZW5kaW5nTGFiZWwodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX3NvcnRBc2NlbmRpbmdMYWJlbC5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblx0Z2V0IHNvcnRBc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4cGVjdHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgc29tZSBvciBhbGwgb2Y6XG5cdCAqIGBgYFxuXHQgKiB7XG5cdCAqXHRcdFwiRklMVEVSXCI6IFwiRmlsdGVyXCIsXG5cdCAqXHRcdFwiRU5EX09GX0RBVEFcIjogXCJZb3UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHlvdXIgY29udGVudFwiLFxuXHQgKlx0XHRcIlNDUk9MTF9UT1BcIjogXCJTY3JvbGwgdG8gdG9wXCIsXG5cdCAqXHRcdFwiQ0hFQ0tCT1hfSEVBREVSXCI6IFwiU2VsZWN0IGFsbCByb3dzXCIsXG5cdCAqXHRcdFwiQ0hFQ0tCT1hfUk9XXCI6IFwiU2VsZWN0IHJvd1wiXG5cdCAqIH1cblx0ICogYGBgXG5cdCAqL1xuXHRASW5wdXQoKVxuXHRzZXQgdHJhbnNsYXRpb25zICh2YWx1ZSkge1xuXHRcdGNvbnN0IHZhbHVlV2l0aERlZmF1bHRzID0gbWVyZ2UodGhpcy5pMThuLmdldE11bHRpcGxlKFwiVEFCTEVcIiksIHZhbHVlKTtcblx0XHR0aGlzLl9maWx0ZXJUaXRsZS5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5GSUxURVIpO1xuXHRcdHRoaXMuX2VuZE9mRGF0YVRleHQub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuRU5EX09GX0RBVEEpO1xuXHRcdHRoaXMuX3Njcm9sbFRvcFRleHQub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuU0NST0xMX1RPUCk7XG5cdFx0dGhpcy5fY2hlY2tib3hIZWFkZXJMYWJlbC5vdmVycmlkZSh2YWx1ZVdpdGhEZWZhdWx0cy5DSEVDS0JPWF9IRUFERVIpO1xuXHRcdHRoaXMuX2NoZWNrYm94Um93TGFiZWwub3ZlcnJpZGUodmFsdWVXaXRoRGVmYXVsdHMuQ0hFQ0tCT1hfUk9XKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdG8gYGZhbHNlYCB0byByZW1vdmUgdGFibGUgcm93cyAoemVicmEpIHN0cmlwZXMuXG5cdCAqL1xuXHRASW5wdXQoKSBzdHJpcGVkID0gdHJ1ZTtcblxuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBzdGljayB0aGUgaGVhZGVyIHRvIHRoZSB0b3Agb2YgdGhlIHRhYmxlXG5cdCAqL1xuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5ieC0tZGF0YS10YWJsZV9pbm5lci1jb250YWluZXJcIikgQElucHV0KCkgc3RpY2t5SGVhZGVyID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFNldCBmb290ZXIgdGVtcGxhdGUgdG8gY3VzdG9taXplIHdoYXQgaXMgZGlzcGxheWVkIGluIHRoZSB0Zm9vdCBzZWN0aW9uIG9mIHRoZSB0YWJsZVxuXHQgKi9cblx0QElucHV0KCkgZm9vdGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gcG9wdWxhdGUgdGhlIHJvdyBzZWxlY3Rpb24gY2hlY2tib3ggbGFiZWwgd2l0aCBhIHVzZWZ1bCB2YWx1ZSBpZiBzZXQuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqIGBgYFxuXHQgKiA8aWJtLXRhYmxlIFtzZWxlY3Rpb25MYWJlbENvbHVtbl09XCIwXCI+PC9pYm0tdGFibGU+XG5cdCAqIDwhLS0gcmVzdWx0cyBpbiBhcmlhLWxhYmVsPVwiU2VsZWN0IGZpcnN0IGNvbHVtbiB2YWx1ZVwiXG5cdCAqICh3aGVyZSBcImZpcnN0IGNvbHVtbiB2YWx1ZVwiIGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY29sdW1uIGluIHRoZSByb3cgLS0+XG5cdCAqIGBgYFxuXHQgKi9cblx0QElucHV0KCkgc2VsZWN0aW9uTGFiZWxDb2x1bW46IG51bWJlcjtcblxuXHQvKipcblx0ICogRW1pdHMgYW4gaW5kZXggb2YgdGhlIGNvbHVtbiB0aGF0IHdhbnRzIHRvIGJlIHNvcnRlZC5cblx0ICpcblx0ICogSWYgbm8gb2JzZXJ2ZXJzIGFyZSBwcm92aWRlZCAoZGVmYXVsdCksIHRhYmxlIHdpbGwgYXR0ZW1wdCB0byBkbyBhIHNpbXBsZSBzb3J0IG9mIHRoZSBkYXRhIGxvYWRlZFxuXHQgKiBpbnRvIHRoZSBtb2RlbC5cblx0ICpcblx0ICogSWYgYW4gb2JzZXJ2ZXIgaXMgcHJvdmlkZWQsIHRhYmxlIHdpbGwgbm90IGF0dGVtcHQgYW55IHNvcnRpbmcgb2YgaXRzIG93biBhbmQgaXQgaXMgdXAgdG8gdGhlIG9ic2VydmVyXG5cdCAqIHRvIHNvcnQgdGhlIHRhYmxlLiBUaGlzIGlzIHdoYXQgeW91IHR5cGljYWxseSB3YW50IGlmIHlvdSdyZSB1c2luZyBhIGJhY2tlbmQgcXVlcnkgdG8gZ2V0IHRoZSBzb3J0ZWRcblx0ICogZGF0YSBvciB3YW50IHRvIHNvcnQgZGF0YSBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMuXG5cdCAqXG5cdCAqIFVzYWdlOlxuXHQgKlxuXHQgKiBgYGB0eXBlc2NyaXB0XG5cdCAqIEBDb21wb25lbnQoe1xuXHQgKiBcdHNlbGVjdG9yOiBcImFwcC10YWJsZVwiLFxuXHQgKiBcdHRlbXBsYXRlOiBgXG5cdCAqIFx0XHQ8aWJtLXRhYmxlXG5cdCAqIFx0XHRcdFttb2RlbF09XCJtb2RlbFwiXG5cdCAqIFx0XHRcdChzb3J0KT1cInNpbXBsZVNvcnQoJGV2ZW50KVwiPlxuXHQgKiBcdFx0XHRObyBkYXRhLlxuXHQgKiBcdFx0PC9pYm0tdGFibGU+XG5cdCAqIFx0YFxuXHQgKiB9KVxuXHQgKiBleHBvcnQgY2xhc3MgVGFibGVBcHAgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG5cdCAqIFx0QElucHV0KCkgbW9kZWwgPSBuZXcgVGFibGVNb2RlbCgpO1xuXHQgKlxuXHQgKiBcdG5nT25Jbml0KCkge1xuXHQgKiBcdFx0dGhpcy5tb2RlbC5oZWFkZXIgPSBbXG5cdCAqIFx0XHRcdG5ldyBUYWJsZUhlYWRlckl0ZW0oeyBkYXRhOiBcIk5hbWVcIiB9KSxcblx0ICogXHRcdFx0bmV3IFRhYmxlSGVhZGVySXRlbSh7IGRhdGE6IFwiaHdlclwiIH0pXG5cdCAqIFx0XHRdO1xuXHQgKlxuXHQgKiBcdFx0dGhpcy5tb2RlbC5kYXRhID0gW1xuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSAxXCIgfSksIG5ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcInF3ZXJcIiB9KV0sXG5cdCAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDNcIiB9KSwgbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiendlclwiIH0pXSxcblx0ICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgMlwiIH0pLCBuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJzd2VyXCIgfSldLFxuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSA0XCIgfSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldLFxuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSA1XCIgfSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldLFxuXHQgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSA2XCIgfSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldXG5cdCAqIFx0XHRdO1xuXHQgKiBcdH1cblx0ICpcblx0ICogXHRzaW1wbGVTb3J0KGluZGV4OiBudW1iZXIpIHtcblx0ICogXHRcdC8vIHRoaXMgZnVuY3Rpb24gZG9lcyBhIHNpbXBsZSBzb3J0LCB3aGljaCBpcyB0aGUgZGVmYXVsdCBmb3IgdGhlIHRhYmxlIGFuZCBpZiB0aGF0J3Ncblx0ICogXHRcdC8vIGFsbCB5b3Ugd2FudCwgeW91IGRvbid0IG5lZWQgdG8gZG8gdGhpcy5cblx0ICpcblx0ICogXHRcdC8vIGhlcmUgeW91IGNhbiBxdWVyeSB5b3VyIGJhY2tlbmQgYW5kIHVwZGF0ZSB0aGUgbW9kZWwuZGF0YSBiYXNlZCBvbiB0aGUgcmVzdWx0XG5cdCAqIFx0XHRpZiAodGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLnNvcnRlZCkge1xuXHQgKiBcdFx0XHQvLyBpZiBhbHJlYWR5IHNvcnRlZCBmbGlwIHNvcnRpbmcgZGlyZWN0aW9uXG5cdCAqIFx0XHRcdHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5hc2NlbmRpbmcgPSB0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uZGVzY2VuZGluZztcblx0ICogXHRcdH1cblx0ICogXHRcdHRoaXMubW9kZWwuc29ydChpbmRleCk7XG5cdCAqIFx0fVxuXHQgKiB9XG5cdCAqIGBgYFxuXHQgKi9cblx0QE91dHB1dCgpIHNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIHNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gbW9kZWxcblx0ICovXG5cdEBPdXRwdXQoKSBzZWxlY3RBbGwgPSBuZXcgRXZlbnRFbWl0dGVyPE9iamVjdD4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIGRlc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSBtb2RlbFxuXHQgKi9cblx0QE91dHB1dCgpIGRlc2VsZWN0QWxsID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGEgc2luZ2xlIHJvdyBpcyBzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtICh7bW9kZWw6IHRoaXMubW9kZWwsIHNlbGVjdGVkUm93SW5kZXg6IGluZGV4fSlcblx0ICovXG5cdEBPdXRwdXQoKSBzZWxlY3RSb3cgPSBuZXcgRXZlbnRFbWl0dGVyPE9iamVjdD4oKTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYSBzaW5nbGUgcm93IGlzIGRlc2VsZWN0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSAoe21vZGVsOiB0aGlzLm1vZGVsLCBkZXNlbGVjdGVkUm93SW5kZXg6IGluZGV4fSlcblx0ICovXG5cdEBPdXRwdXQoKSBkZXNlbGVjdFJvdyA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhIHJvdyBpdGVtIGV4Y2x1ZGluZyBleHBhbmRCdXR0b25zLCBjaGVja2JveGVzLCBvciByYWRpb3MgaXMgY2xpY2tlZC5cblx0ICovXG5cdEBPdXRwdXQoKSByb3dDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyB3aGVuIHRhYmxlIHJlcXVpcmVzIG1vcmUgZGF0YSB0byBiZSBsb2FkZWQuXG5cdCAqL1xuXHRAT3V0cHV0KCkgc2Nyb2xsTG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFibGVNb2RlbD4oKTtcblxuXHQvKipcblx0ICogQ29udHJvbHMgaWYgYWxsIGNoZWNrYm94ZXMgYXJlIHZpZXdlZCBhcyBzZWxlY3RlZC5cblx0ICovXG5cdHNlbGVjdEFsbENoZWNrYm94ID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIHRoZSBpbmRldGVybWluYXRlIHN0YXRlIG9mIHRoZSBoZWFkZXIgY2hlY2tib3guXG5cdCAqL1xuXHRzZWxlY3RBbGxDaGVja2JveFNvbWVTZWxlY3RlZCA9IGZhbHNlO1xuXG5cdGdldCBub0RhdGEoKSB7XG5cdFx0cmV0dXJuICF0aGlzLm1vZGVsLmRhdGEgfHxcblx0XHRcdHRoaXMubW9kZWwuZGF0YS5sZW5ndGggPT09IDAgfHxcblx0XHRcdHRoaXMubW9kZWwuZGF0YS5sZW5ndGggPT09IDEgJiYgdGhpcy5tb2RlbC5kYXRhWzBdLmxlbmd0aCA9PT0gMDtcblx0fVxuXG5cdHB1YmxpYyBpc0NvbHVtbkRyYWdnaW5nID0gZmFsc2U7XG5cdHB1YmxpYyBjb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IC0xO1xuXHRwdWJsaWMgY29sdW1uRHJhZ2dlZFBvc2l0aW9uID0gXCJcIjtcblxuXHRwcm90ZWN0ZWQgX21vZGVsOiBUYWJsZU1vZGVsO1xuXHRwcm90ZWN0ZWQgX2lzRGF0YUdyaWQgPSBmYWxzZTtcblx0Ly8gZmxhZyB0byBwcmV2ZW50IGdldHRlcnMvc2V0dGVycyBmcm9tIHF1ZXJ5aW5nIHRoZSB2aWV3IGJlZm9yZSBpdCdzIGZ1bGx5IGluc3RhbnRpYXRlZFxuXHRwcm90ZWN0ZWQgaXNWaWV3UmVhZHkgPSBmYWxzZTtcblxuXHRwcm90ZWN0ZWQgc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblx0cHJvdGVjdGVkIHBvc2l0aW9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cblx0cHJvdGVjdGVkIGludGVyYWN0aW9uTW9kZWw6IERhdGFHcmlkSW50ZXJhY3Rpb25Nb2RlbDtcblx0cHJvdGVjdGVkIGludGVyYWN0aW9uUG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuXHRwcm90ZWN0ZWQgX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbCAgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5FWFBBTkRfQlVUVE9OXCIpO1xuXHRwcm90ZWN0ZWQgX3NvcnREZXNjZW5kaW5nTGFiZWwgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5TT1JUX0RFU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfc29ydEFzY2VuZGluZ0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU09SVF9BU0NFTkRJTkdcIik7XG5cdHByb3RlY3RlZCBfY2hlY2tib3hIZWFkZXJMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkNIRUNLQk9YX0hFQURFUlwiKTtcblx0cHJvdGVjdGVkIF9jaGVja2JveFJvd0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuQ0hFQ0tCT1hfUk9XXCIpO1xuXHRwcm90ZWN0ZWQgX2VuZE9mRGF0YVRleHQgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUQUJMRS5FTkRfT0ZfREFUQVwiKTtcblx0cHJvdGVjdGVkIF9zY3JvbGxUb3BUZXh0ID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuU0NST0xMX1RPUFwiKTtcblx0cHJvdGVjdGVkIF9maWx0ZXJUaXRsZSA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkZJTFRFUlwiKTtcblxuXHRwcm90ZWN0ZWQgY29sdW1uUmVzaXplV2lkdGg6IG51bWJlcjtcblx0cHJvdGVjdGVkIGNvbHVtblJlc2l6ZU1vdXNlWDogbnVtYmVyO1xuXHRwcm90ZWN0ZWQgbW91c2VNb3ZlU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cdHByb3RlY3RlZCBtb3VzZVVwU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGFibGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihcblx0XHRwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcblx0XHRwcm90ZWN0ZWQgYXBwbGljYXRpb25SZWY6IEFwcGxpY2F0aW9uUmVmLFxuXHRcdHByb3RlY3RlZCBpMThuOiBJMThuXG5cdCkge31cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0dGhpcy5pc1ZpZXdSZWFkeSA9IHRydWU7XG5cdFx0aWYgKHRoaXMuaXNEYXRhR3JpZCkge1xuXHRcdFx0dGhpcy5lbmFibGVEYXRhR3JpZEludGVyYWN0aW9ucygpO1xuXHRcdH1cblx0fVxuXG5cdG5nT25EZXN0cm95KCkge1xuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuXHRcdGlmICh0aGlzLnBvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XG5cdFx0XHR0aGlzLnBvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHR9XG5cblx0ZW5hYmxlRGF0YUdyaWRJbnRlcmFjdGlvbnMoKSB7XG5cdFx0Ly8gaWYgd2UgaGF2ZSBhbiBgaW50ZXJhY3Rpb01vZGVsYCB3ZSd2ZSBhbHJlYWR5IGVuYWJsZWQgZGF0YWdyaWRcblx0XHRpZiAodGhpcy5pbnRlcmFjdGlvbk1vZGVsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNvbnN0IHRhYmxlID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcInRhYmxlXCIpIGFzIEhUTUxUYWJsZUVsZW1lbnQ7XG5cdFx0Y29uc3QgdGFibGVBZGFwdGVyID0gbmV3IFRhYmxlRG9tQWRhcHRlcih0YWJsZSk7XG5cdFx0Y29uc3Qga2V5ZG93bkV2ZW50U3RyZWFtID0gZnJvbUV2ZW50PEtleWJvYXJkRXZlbnQ+KHRhYmxlLCBcImtleWRvd25cIik7XG5cdFx0Y29uc3QgY2xpY2tFdmVudFN0cmVhbSA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pih0YWJsZSwgXCJjbGlja1wiKTtcblx0XHR0aGlzLmludGVyYWN0aW9uTW9kZWwgPSBuZXcgRGF0YUdyaWRJbnRlcmFjdGlvbk1vZGVsKGtleWRvd25FdmVudFN0cmVhbSwgY2xpY2tFdmVudFN0cmVhbSwgdGFibGVBZGFwdGVyKTtcblx0XHR0aGlzLnBvc2l0aW9uU3Vic2NyaXB0aW9uID0gdGhpcy5pbnRlcmFjdGlvbk1vZGVsLnBvc2l0aW9uLnN1YnNjcmliZShldmVudCA9PiB7XG5cdFx0XHRjb25zdCBbY3VycmVudFJvdywgY3VycmVudENvbHVtbl0gPSBldmVudC5jdXJyZW50O1xuXHRcdFx0Y29uc3QgW3ByZXZpb3VzUm93LCBwcmV2aW91c0NvbHVtbl0gPSBldmVudC5wcmV2aW91cztcblxuXHRcdFx0Y29uc3QgY3VycmVudEVsZW1lbnQgPSB0YWJsZUFkYXB0ZXIuZ2V0Q2VsbChjdXJyZW50Um93LCBjdXJyZW50Q29sdW1uKTtcblx0XHRcdFRhYmxlLnNldFRhYkluZGV4KGN1cnJlbnRFbGVtZW50LCAwKTtcblxuXHRcdFx0Ly8gaWYgdGhlIG1vZGVsIGhhcyBqdXN0IGluaXRpYWxpemVkIGRvbid0IGZvY3VzIG9yIHJlc2V0IGFueXRoaW5nXG5cdFx0XHRpZiAocHJldmlvdXNSb3cgPT09IC0xIHx8IHByZXZpb3VzQ29sdW1uID09PSAtMSkgeyByZXR1cm47IH1cblx0XHRcdC8vIE1ha2UgdGhlIHByZXZpb3VzIGNlbGwgdW5mb2N1c2FibGUgKGlmIGl0J3Mgbm90IHRoZSBjdXJyZW50KVxuXHRcdFx0aWYgKHByZXZpb3VzUm93ICE9PSBjdXJyZW50Um93IHx8IHByZXZpb3VzQ29sdW1uICE9PSBjdXJyZW50Q29sdW1uKSB7XG5cdFx0XHRcdGNvbnN0IHByZXZpb3VzRWxlbWVudCA9IHRhYmxlQWRhcHRlci5nZXRDZWxsKHByZXZpb3VzUm93LCBwcmV2aW91c0NvbHVtbik7XG5cdFx0XHRcdFRhYmxlLnNldFRhYkluZGV4KHByZXZpb3VzRWxlbWVudCwgLTEpO1xuXHRcdFx0fVxuXHRcdFx0VGFibGUuZm9jdXMoY3VycmVudEVsZW1lbnQpO1xuXHRcdH0pO1xuXHRcdC8vIGNhbGwgdGhpcyBhZnRlciBhc3NpZ25pbmcgYHRoaXMuaW50ZXJhY3Rpb25Nb2RlbGAgc2luY2UgaXQgZGVwZW5kcyBvbiBpdFxuXHRcdHRoaXMucmVzZXRUYWJJbmRleCgpO1xuXHR9XG5cblx0ZGlzYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCkge1xuXHRcdC8vIHVuc3Vic2NyaWJlIGZpcnN0IHNvIHdlIGRvbid0IGNhdXNlIHRoZSBmb2N1cyB0byBmbHkgYXJvdW5kXG5cdFx0aWYgKHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24pIHtcblx0XHRcdHRoaXMucG9zaXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdFx0Ly8gdW5kbyB0YWIgaW5kZXhpbmcgKGFsc28gcmVzZXRzIHRoZSBtb2RlbClcblx0XHR0aGlzLnJlc2V0VGFiSW5kZXgoMCk7XG5cdFx0Ly8gbnVsbCBvdXQgdGhlIG1vZGVsIHJlZlxuXHRcdHRoaXMuaW50ZXJhY3Rpb25Nb2RlbCA9IG51bGw7XG5cdH1cblxuXHRvblNlbGVjdEFsbCgpIHtcblx0XHR0aGlzLm1vZGVsLnNlbGVjdEFsbCh0cnVlKTtcblx0XHR0aGlzLnNlbGVjdEFsbC5lbWl0KHRoaXMubW9kZWwpO1xuXHR9XG5cblx0b25EZXNlbGVjdEFsbCgpIHtcblx0XHR0aGlzLm1vZGVsLnNlbGVjdEFsbChmYWxzZSk7XG5cdFx0dGhpcy5kZXNlbGVjdEFsbC5lbWl0KHRoaXMubW9kZWwpO1xuXHR9XG5cblx0b25TZWxlY3RSb3coZXZlbnQpIHtcblx0XHQvLyBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgc2VsZWN0ZWRSb3dJbmRleCBwcm9wZXJ0eVxuXHRcdGlmIChPYmplY3Qua2V5cyhldmVudCkuaW5jbHVkZXMoXCJzZWxlY3RlZFJvd0luZGV4XCIpKSB7XG5cdFx0XHRpZiAodGhpcy5lbmFibGVTaW5nbGVTZWxlY3QpIHtcblx0XHRcdFx0dGhpcy5tb2RlbC5zZWxlY3RBbGwoZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5tb2RlbC5zZWxlY3RSb3coZXZlbnQuc2VsZWN0ZWRSb3dJbmRleCwgdHJ1ZSk7XG5cdFx0XHR0aGlzLnNlbGVjdFJvdy5lbWl0KGV2ZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5tb2RlbC5zZWxlY3RSb3coZXZlbnQuZGVzZWxlY3RlZFJvd0luZGV4LCBmYWxzZSk7XG5cdFx0XHR0aGlzLmRlc2VsZWN0Um93LmVtaXQoZXZlbnQpO1xuXHRcdH1cblx0fVxuXG5cdG9uUm93Q2xpY2soaW5kZXg6IG51bWJlcikge1xuXHRcdHRoaXMucm93Q2xpY2suZW1pdChpbmRleCk7XG5cdH1cblxuXHR1cGRhdGVTZWxlY3RBbGxDaGVja2JveCgpIHtcblx0XHRjb25zdCBzZWxlY3RlZFJvd3NDb3VudCA9IHRoaXMubW9kZWwuc2VsZWN0ZWRSb3dzQ291bnQoKTtcblxuXHRcdGlmIChzZWxlY3RlZFJvd3NDb3VudCA8PSAwKSB7XG5cdFx0XHQvLyByZXNldCBzZWxlY3QgYWxsIGNoZWNrYm94IGlmIG5vdGhpbmcgc2VsZWN0ZWRcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3ggPSBmYWxzZTtcblx0XHRcdHRoaXMuc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKHNlbGVjdGVkUm93c0NvdW50IDwgdGhpcy5tb2RlbC5kYXRhLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveCA9IHRydWU7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZWxlY3RBbGxDaGVja2JveCA9IHRydWU7XG5cdFx0XHR0aGlzLnNlbGVjdEFsbENoZWNrYm94U29tZVNlbGVjdGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0cmVzZXRUYWJJbmRleChuZXdUYWJJbmRleCA9IC0xKSB7XG5cdFx0Ly8gZW5zdXJlIHRoZSB2aWV3IGlzIHJlYWR5IGZvciB0aGUgcmVzZXQgYmVmb3JlIHdlIHByZWZvcm0gdGhlIGFjdHVhbCByZXNldFxuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0Ly8gcmVzZXQgYWxsIHRoZSB0YWJJbmRleGVzIHdlIGNhbiBmaW5kXG5cdFx0XHRjb25zdCBmb2N1c0VsZW1lbnRMaXN0ID0gZ2V0Rm9jdXNFbGVtZW50TGlzdCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGFiYmFibGVTZWxlY3Rvcklnbm9yZVRhYkluZGV4KTtcblx0XHRcdGlmIChmb2N1c0VsZW1lbnRMaXN0KSB7XG5cdFx0XHRcdGZvY3VzRWxlbWVudExpc3QuZm9yRWFjaCh0YWJiYWJsZSA9PiB7XG5cdFx0XHRcdFx0dGFiYmFibGUudGFiSW5kZXggPSBuZXdUYWJJbmRleDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXNldCBpbnRlcmFjdGlvbiBtb2RlbCBwb3NpdGlvbnMgYW5kIHRhYkluZGV4ZXNcblx0XHRcdGlmICh0aGlzLmludGVyYWN0aW9uTW9kZWwpIHtcblx0XHRcdFx0dGhpcy5pbnRlcmFjdGlvbk1vZGVsLnJlc2V0VGFiSW5kZXhlcyhuZXdUYWJJbmRleCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRjb2x1bW5SZXNpemVTdGFydChldmVudCwgY29sdW1uKSB7XG5cdFx0dGhpcy5jb2x1bW5SZXNpemVXaWR0aCA9IHBhcnNlSW50KGNvbHVtbi5zdHlsZS53aWR0aCwgMTApO1xuXHRcdHRoaXMuY29sdW1uUmVzaXplTW91c2VYID0gZXZlbnQuY2xpZW50WDtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0dGhpcy5tb3VzZU1vdmVTdWJzY3JpcHRpb24gPSBmcm9tRXZlbnQoZG9jdW1lbnQuYm9keSwgXCJtb3VzZW1vdmVcIikuc3Vic2NyaWJlKGV2ZW50ID0+IHtcblx0XHRcdHRoaXMuY29sdW1uUmVzaXplUHJvZ3Jlc3MoZXZlbnQsIGNvbHVtbik7XG5cdFx0fSk7XG5cdFx0dGhpcy5tb3VzZVVwU3Vic2NyaXB0aW9uID0gZnJvbUV2ZW50KGRvY3VtZW50LmJvZHksIFwibW91c2V1cFwiKS5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuXHRcdFx0dGhpcy5jb2x1bW5SZXNpemVFbmQoZXZlbnQsIGNvbHVtbik7XG5cdFx0fSk7XG5cdH1cblxuXHRjb2x1bW5SZXNpemVQcm9ncmVzcyhldmVudCwgY29sdW1uKSB7XG5cdFx0Y29uc3QgbW92ZSA9IGV2ZW50LmNsaWVudFggLSB0aGlzLmNvbHVtblJlc2l6ZU1vdXNlWDtcblx0XHRjb2x1bW4uc3R5bGUud2lkdGggPSBgJHt0aGlzLmNvbHVtblJlc2l6ZVdpZHRoICsgbW92ZX1weGA7XG5cdH1cblxuXHRjb2x1bW5SZXNpemVFbmQoZXZlbnQsIGNvbHVtbikge1xuXHRcdHRoaXMubW91c2VNb3ZlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdFx0dGhpcy5tb3VzZVVwU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBvbiB0aGUgYDx0Ym9keT5gIGVsZW1lbnQuXG5cdCAqIEVtaXRzIHRoZSBgc2Nyb2xsTG9hZGAgZXZlbnQuXG5cdCAqL1xuXHRvblNjcm9sbChldmVudCkge1xuXHRcdGNvbnN0IGRpc3RhbmNlRnJvbUJvdHRvbSA9IGV2ZW50LnRhcmdldC5zY3JvbGxIZWlnaHQgLSBldmVudC50YXJnZXQuY2xpZW50SGVpZ2h0IC0gZXZlbnQudGFyZ2V0LnNjcm9sbFRvcDtcblxuXHRcdGlmIChkaXN0YW5jZUZyb21Cb3R0b20gPD0gdGhpcy5zY3JvbGxMb2FkRGlzdGFuY2UpIHtcblx0XHRcdHRoaXMuc2Nyb2xsTG9hZC5lbWl0KHRoaXMubW9kZWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1vZGVsLmlzRW5kID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0Y29sdW1uRHJhZ1N0YXJ0KGV2ZW50LCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuaXNDb2x1bW5EcmFnZ2luZyA9IHRydWU7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IGNvbHVtbkluZGV4O1xuXHRcdGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiY29sdW1uSW5kZXhcIiwgSlNPTi5zdHJpbmdpZnkoY29sdW1uSW5kZXgpKTtcblx0fVxuXG5cdGNvbHVtbkRyYWdFbmQoZXZlbnQsIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5pc0NvbHVtbkRyYWdnaW5nID0gZmFsc2U7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkSG92ZXJJbmRleCA9IC0xO1xuXHR9XG5cblx0Y29sdW1uRHJhZ0VudGVyKGV2ZW50LCBwb3NpdGlvbiwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSBjb2x1bW5JbmRleDtcblx0fVxuXG5cdGNvbHVtbkRyYWdMZWF2ZShldmVudCwgcG9zaXRpb24sIGNvbHVtbkluZGV4KSB7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkUG9zaXRpb24gPSBcIlwiO1xuXHR9XG5cblx0Y29sdW1uRHJhZ292ZXIoZXZlbnQsIHBvc2l0aW9uLCBjb2x1bW5JbmRleCkge1xuXHRcdHRoaXMuY29sdW1uRHJhZ2dlZEhvdmVySW5kZXggPSBjb2x1bW5JbmRleDtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuXG5cdFx0Ly8gbmVlZGVkIHRvIHRlbGwgYnJvd3NlciB0byBhbGxvdyBkcm9wcGluZ1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cblxuXHRjb2x1bW5Ecm9wKGV2ZW50LCBwb3NpdGlvbiwgY29sdW1uSW5kZXgpIHtcblx0XHR0aGlzLmlzQ29sdW1uRHJhZ2dpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmNvbHVtbkRyYWdnZWRIb3ZlckluZGV4ID0gLTE7XG5cdFx0dGhpcy5jb2x1bW5EcmFnZ2VkUG9zaXRpb24gPSBcIlwiO1xuXG5cdFx0dGhpcy5tb2RlbC5tb3ZlQ29sdW1uKFxuXHRcdFx0cGFyc2VJbnQoZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJjb2x1bW5JbmRleFwiKSwgMTApLFxuXHRcdFx0Y29sdW1uSW5kZXggKyAocG9zaXRpb24gPT09IFwicmlnaHRcIiA/IDEgOiAwKVxuXHRcdCk7XG5cdH1cblxuXHRkb1NvcnQoaW5kZXg6IG51bWJlcikge1xuXHRcdGlmICh0aGlzLnNvcnQub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gbm8gc29ydCBwcm92aWRlZCBzbyBkbyB0aGUgc2ltcGxlIHNvcnRcblx0XHRcdGlmICh0aGlzLm1vZGVsLmhlYWRlcltpbmRleF0uc29ydGVkKSB7XG5cdFx0XHRcdC8vIGlmIGFscmVhZHkgc29ydGVkIGZsaXAgc29ydGluZyBkaXJlY3Rpb25cblx0XHRcdFx0dGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLmFzY2VuZGluZyA9IHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5kZXNjZW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5tb2RlbC5zb3J0KGluZGV4KTtcblx0XHR9XG5cblx0XHR0aGlzLnNvcnQuZW1pdChpbmRleCk7XG5cdH1cblxuXHQvKipcblx0ICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBvbiB0aGUgYDx0Ym9keT5gIGVsZW1lbnQuXG5cdCAqIEVtaXRzIHRoZSBgc2Nyb2xsTG9hZGAgZXZlbnQuXG5cdCAqL1xuXHRzY3JvbGxUb1RvcChldmVudCkge1xuXHRcdGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LmNoaWxkcmVuWzFdLnNjcm9sbFRvcCA9IDA7XG5cdFx0dGhpcy5tb2RlbC5pc0VuZCA9IGZhbHNlO1xuXHR9XG5cblx0Z2V0U2VsZWN0aW9uTGFiZWxWYWx1ZShyb3c6IFRhYmxlSXRlbVtdKSB7XG5cdFx0aWYgKCF0aGlzLnNlbGVjdGlvbkxhYmVsQ29sdW1uKSB7XG5cdFx0XHRyZXR1cm4geyB2YWx1ZTogdGhpcy5pMThuLmdldCgpLlRBQkxFLlJPVyB9O1xuXHRcdH1cblx0XHRyZXR1cm4geyB2YWx1ZTogcm93W3RoaXMuc2VsZWN0aW9uTGFiZWxDb2x1bW5dLmRhdGEgfTtcblx0fVxuXG5cdGdldEV4cGFuZEJ1dHRvbkFyaWFMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kQnV0dG9uQXJpYUxhYmVsLnN1YmplY3Q7XG5cdH1cblx0Z2V0U29ydERlc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydERlc2NlbmRpbmdMYWJlbC5zdWJqZWN0O1xuXHR9XG5cdGdldFNvcnRBc2NlbmRpbmdMYWJlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc29ydEFzY2VuZGluZ0xhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRDaGVja2JveEhlYWRlckxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2JveEhlYWRlckxhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRDaGVja2JveFJvd0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2JveFJvd0xhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRFbmRPZkRhdGFUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzLl9lbmRPZkRhdGFUZXh0LnN1YmplY3Q7XG5cdH1cblxuXHRnZXRTY3JvbGxUb3BUZXh0KCkge1xuXHRcdHJldHVybiB0aGlzLl9zY3JvbGxUb3BUZXh0LnN1YmplY3Q7XG5cdH1cblxuXHRnZXRGaWx0ZXJUaXRsZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZmlsdGVyVGl0bGUuc3ViamVjdDtcblx0fVxufVxuIl19