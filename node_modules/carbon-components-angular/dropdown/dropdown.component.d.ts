/**
 *
 * carbon-angular v0.0.0 | dropdown.component.d.ts
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { EventEmitter, ElementRef, OnInit, AfterContentInit, OnDestroy, TemplateRef, ApplicationRef, AfterViewInit } from "@angular/core";
import { ControlValueAccessor } from "@angular/forms";
import { Observable, Subscription } from "rxjs";
import { AbstractDropdownView } from "./abstract-dropdown-view.class";
import { I18n } from "carbon-components-angular/i18n";
import { ListItem } from "./list-item.interface";
import { DropdownService } from "./dropdown.service";
import { ElementService } from "carbon-components-angular/utils";
/**
 * Drop-down lists enable users to select one or more items from a list.
 *
 * #### Opening behavior/List DOM placement
 * By default the dropdown will try to figure out the best placement for the dropdown list.
 *
 * If it's not contained within any scrolling elements, it will open inline, if it _is_
 * contained within a scrolling container it will try to open in the body, or an `ibm-placeholder`.
 *
 * To control this behavior you can use the `appendInline` input:
 * - `[appendInline]="null"` is the default (auto detection)
 * - `[appendInline]="false"` will always append to the body/`ibm-placeholder`
 * - `[appendInline]="true"` will always append inline (next to the dropdown button)
 *
 * [See demo](../../?path=/story/components-dropdown--basic)
 *
 * <example-url>../../iframe.html?id=components-dropdown--basic</example-url>
 */
import * as ɵngcc0 from '@angular/core';
export declare class Dropdown implements OnInit, AfterContentInit, AfterViewInit, OnDestroy, ControlValueAccessor {
    protected elementRef: ElementRef;
    protected i18n: I18n;
    protected dropdownService: DropdownService;
    protected appRef: ApplicationRef;
    protected elementService: ElementService;
    static dropdownCount: number;
    id: string;
    /**
     * Label for the dropdown.
     */
    label: string | TemplateRef<any>;
    /**
     * Sets the optional helper text.
     */
    helperText: string | TemplateRef<any>;
    /**
     * Value displayed if no item is selected.
     */
    placeholder: string;
    /**
     * The selected value from the `Dropdown`. Can be a string or template.
     */
    displayValue: string | TemplateRef<any>;
    /**
     * Sets the optional clear button tooltip text.
     */
    clearText: string;
    /**
     * Size to render the dropdown field.
     *
     * @deprecated since v4
     */
    size: "sm" | "md" | "xl";
    /**
     * Defines whether or not the `Dropdown` supports selecting multiple items as opposed to single
     * item selection.
     */
    type: "single" | "multi";
    /**
     * `light` or `dark` dropdown theme
     */
    theme: "light" | "dark";
    /**
     * Set to `true` to disable the dropdown.
     */
    disabled: boolean;
    /**
     * Set to `true` for a loading dropdown.
     */
    skeleton: boolean;
    /**
     * Set to `true` for an inline dropdown.
     */
    inline: boolean;
    /**
     * Set to `true` for a dropdown without arrow key activation.
     */
    disableArrowKeys: boolean;
    /**
     * Set to `true` for invalid state.
     */
    invalid: boolean;
    /**
     * Value displayed if dropdown is in invalid state.
     */
    invalidText: string | TemplateRef<any>;
    /**
      * Set to `true` to show a warning (contents set by warningText)
      */
    warn: boolean;
    /**
     * Sets the warning text
     */
    warnText: string | TemplateRef<any>;
    /**
     * set to `true` to place the dropdown view inline with the component
     */
    appendInline: boolean;
    /**
     * Query string for the element that contains the `Dropdown`.
     * Used to trigger closing the dropdown if it scrolls outside of the viewport of the `scrollableContainer`.
     */
    scrollableContainer: string;
    /**
     * Deprecated. Use `itemValueKey` instead.
     * Specifies the property to be used as the return value to `ngModel`
     * @deprecated since v4 use itemValueKey instead
     */
    value: string;
    /**
     * Specifies the property to be used as the return value to `ngModel`
     */
    itemValueKey: string;
    /**
     * Specify feedback (mode) of the selection.
     * `top`: selected item jumps to top
     * `fixed`: selected item stays at it's position
     * `top-after-reopen`: selected item jump to top after reopen dropdown
     */
    selectionFeedback: "top" | "fixed" | "top-after-reopen";
    /**
     * Accessible label for the button that opens the dropdown list.
     * Defaults to the `DROPDOWN.OPEN` value from the i18n service.
     */
    menuButtonLabel: any;
    /**
     * Provides the label for the "# selected" text.
     * Defaults to the `DROPDOWN.SELECTED` value from the i18n service.
     */
    selectedLabel: any;
    /**
     * Overrides the automatic dropUp.
     */
    dropUp: boolean;
    /**
     * Emits selection events.
     */
    selected: EventEmitter<Object>;
    /**
     * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
     */
    onClose: EventEmitter<any>;
    /**
     * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
     */
    close: EventEmitter<any>;
    /**
     * Maintains a reference to the `AbstractDropdownView` object within the content DOM.
     */
    view: AbstractDropdownView;
    /**
     * Maintains a reference to the view DOM element of the `Dropdown` button.
     */
    dropdownButton: any;
    /**
     * ViewChid of the dropdown view.
     */
    dropdownMenu: any;
    hostClass: boolean;
    /**
     * Set to `true` if the dropdown is closed (not expanded).
     */
    menuIsClosed: boolean;
    /**
     * controls whether the `drop-up` class is applied
     */
    _dropUp: boolean;
    noop: any;
    outsideClick: any;
    outsideKey: any;
    keyboardNav: any;
    protected visibilitySubscription: Subscription;
    protected onTouchedCallback: () => void;
    private _writtenValue;
    protected writtenValue: any[];
    /**
     * Creates an instance of Dropdown.
     */
    constructor(elementRef: ElementRef, i18n: I18n, dropdownService: DropdownService, appRef: ApplicationRef, elementService: ElementService);
    /**
     * Updates the `type` property in the `@ContentChild`.
     * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.
     */
    ngOnInit(): void;
    /**
     * Initializes classes and subscribes to events for single or multi selection.
     */
    ngAfterContentInit(): void;
    ngAfterViewInit(): void;
    /**
     * Removing the `Dropdown` from the body if it is appended to the body.
     */
    ngOnDestroy(): void;
    /**
     * Propagates the injected `value`.
     */
    writeValue(value: any): void;
    onBlur(): void;
    registerOnChange(fn: any): void;
    /**
     * Registering the function injected to control the touch use of the `Dropdown`.
     */
    registerOnTouched(fn: any): void;
    /**
     * function passed in by `registerOnChange`
     */
    propagateChange: (_: any) => void;
    /**
     * `ControlValueAccessor` method to programmatically disable the dropdown.
     *
     * ex: `this.formGroup.get("myDropdown").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled: boolean): void;
    /**
     * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.
     */
    onKeyDown(event: KeyboardEvent): void;
    closedDropdownNavigation(event: any): void;
    /**
     * Returns the display value if there is a selection and displayValue is set,
     * if there is just a selection the ListItem content property will be returned,
     * otherwise the placeholder will be returned.
     */
    getDisplayStringValue(): Observable<string>;
    isRenderString(): boolean;
    getRenderTemplateContext(): {
        items: ListItem[];
        item?: undefined;
    } | {
        item: ListItem;
        items?: undefined;
    } | {
        items?: undefined;
        item?: undefined;
    };
    getSelectedCount(): number;
    clearSelected(): void;
    /**
     * Returns `true` if there is a value selected.
     */
    valueSelected(): boolean;
    _noop(): void;
    /**
     * Handles clicks outside of the `Dropdown`.
     */
    _outsideClick(event: any): void;
    _outsideKey(event: any): void;
    /**
     * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
     */
    _keyboardNav(event: KeyboardEvent): void;
    /**
     * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
     */
    _appendToDropdown(): void;
    /**
     * Creates the `Dropdown` list as an element that is appended to the DOM body.
     */
    _appendToBody(): void;
    /**
     * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
     * This can be overridden by passing in a value to the `dropUp` input.
     */
    _shouldDropUp(): boolean;
    /**
     * Expands the dropdown menu in the view.
     */
    openMenu(): void;
    /**
     * Collapsing the dropdown menu and removing unnecessary `EventListeners`.
     */
    closeMenu(): void;
    /**
     * Controls toggling menu states between open/expanded and closed/collapsed.
     */
    toggleMenu(): void;
    isTemplate(value: any): boolean;
    /**
     * Controls when it's needed to apply the selection feedback
     */
    protected checkForReorder(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Dropdown>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<Dropdown, "ibm-dropdown", never, {
    "id": "id";
    "placeholder": "placeholder";
    "displayValue": "displayValue";
    "clearText": "clearText";
    "size": "size";
    "type": "type";
    "theme": "theme";
    "disabled": "disabled";
    "skeleton": "skeleton";
    "inline": "inline";
    "disableArrowKeys": "disableArrowKeys";
    "invalid": "invalid";
    "warn": "warn";
    "appendInline": "appendInline";
    "selectionFeedback": "selectionFeedback";
    "menuButtonLabel": "menuButtonLabel";
    "selectedLabel": "selectedLabel";
    "value": "value";
    "itemValueKey": "itemValueKey";
    "label": "label";
    "helperText": "helperText";
    "invalidText": "invalidText";
    "warnText": "warnText";
    "scrollableContainer": "scrollableContainer";
    "dropUp": "dropUp";
}, {
    "selected": "selected";
    "onClose": "onClose";
    "close": "close";
}, ["view"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImRyb3Bkb3duLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3UUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBjYXJib24tYW5ndWxhciB2MC4wLjAgfCBkcm9wZG93bi5jb21wb25lbnQuZC50c1xuICpcbiAqIENvcHlyaWdodCAyMDE0LCAyMDIxIElCTVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBFbGVtZW50UmVmLCBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYsIEFwcGxpY2F0aW9uUmVmLCBBZnRlclZpZXdJbml0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3REcm9wZG93blZpZXcgfSBmcm9tIFwiLi9hYnN0cmFjdC1kcm9wZG93bi12aWV3LmNsYXNzXCI7XG5pbXBvcnQgeyBJMThuIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgTGlzdEl0ZW0gfSBmcm9tIFwiLi9saXN0LWl0ZW0uaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBEcm9wZG93blNlcnZpY2UgfSBmcm9tIFwiLi9kcm9wZG93bi5zZXJ2aWNlXCI7XG5pbXBvcnQgeyBFbGVtZW50U2VydmljZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzXCI7XG4vKipcbiAqIERyb3AtZG93biBsaXN0cyBlbmFibGUgdXNlcnMgdG8gc2VsZWN0IG9uZSBvciBtb3JlIGl0ZW1zIGZyb20gYSBsaXN0LlxuICpcbiAqICMjIyMgT3BlbmluZyBiZWhhdmlvci9MaXN0IERPTSBwbGFjZW1lbnRcbiAqIEJ5IGRlZmF1bHQgdGhlIGRyb3Bkb3duIHdpbGwgdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIGJlc3QgcGxhY2VtZW50IGZvciB0aGUgZHJvcGRvd24gbGlzdC5cbiAqXG4gKiBJZiBpdCdzIG5vdCBjb250YWluZWQgd2l0aGluIGFueSBzY3JvbGxpbmcgZWxlbWVudHMsIGl0IHdpbGwgb3BlbiBpbmxpbmUsIGlmIGl0IF9pc19cbiAqIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxpbmcgY29udGFpbmVyIGl0IHdpbGwgdHJ5IHRvIG9wZW4gaW4gdGhlIGJvZHksIG9yIGFuIGBpYm0tcGxhY2Vob2xkZXJgLlxuICpcbiAqIFRvIGNvbnRyb2wgdGhpcyBiZWhhdmlvciB5b3UgY2FuIHVzZSB0aGUgYGFwcGVuZElubGluZWAgaW5wdXQ6XG4gKiAtIGBbYXBwZW5kSW5saW5lXT1cIm51bGxcImAgaXMgdGhlIGRlZmF1bHQgKGF1dG8gZGV0ZWN0aW9uKVxuICogLSBgW2FwcGVuZElubGluZV09XCJmYWxzZVwiYCB3aWxsIGFsd2F5cyBhcHBlbmQgdG8gdGhlIGJvZHkvYGlibS1wbGFjZWhvbGRlcmBcbiAqIC0gYFthcHBlbmRJbmxpbmVdPVwidHJ1ZVwiYCB3aWxsIGFsd2F5cyBhcHBlbmQgaW5saW5lIChuZXh0IHRvIHRoZSBkcm9wZG93biBidXR0b24pXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1kcm9wZG93bi0tYmFzaWMpXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPWNvbXBvbmVudHMtZHJvcGRvd24tLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRHJvcGRvd24gaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmO1xuICAgIHByb3RlY3RlZCBpMThuOiBJMThuO1xuICAgIHByb3RlY3RlZCBkcm9wZG93blNlcnZpY2U6IERyb3Bkb3duU2VydmljZTtcbiAgICBwcm90ZWN0ZWQgYXBwUmVmOiBBcHBsaWNhdGlvblJlZjtcbiAgICBwcm90ZWN0ZWQgZWxlbWVudFNlcnZpY2U6IEVsZW1lbnRTZXJ2aWNlO1xuICAgIHN0YXRpYyBkcm9wZG93bkNvdW50OiBudW1iZXI7XG4gICAgaWQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBMYWJlbCBmb3IgdGhlIGRyb3Bkb3duLlxuICAgICAqL1xuICAgIGxhYmVsOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG9wdGlvbmFsIGhlbHBlciB0ZXh0LlxuICAgICAqL1xuICAgIGhlbHBlclRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogVmFsdWUgZGlzcGxheWVkIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgcGxhY2Vob2xkZXI6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0ZWQgdmFsdWUgZnJvbSB0aGUgYERyb3Bkb3duYC4gQ2FuIGJlIGEgc3RyaW5nIG9yIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBvcHRpb25hbCBjbGVhciBidXR0b24gdG9vbHRpcCB0ZXh0LlxuICAgICAqL1xuICAgIGNsZWFyVGV4dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFNpemUgdG8gcmVuZGVyIHRoZSBkcm9wZG93biBmaWVsZC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG4gICAgICovXG4gICAgc2l6ZTogXCJzbVwiIHwgXCJtZFwiIHwgXCJ4bFwiO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGBEcm9wZG93bmAgc3VwcG9ydHMgc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIGFzIG9wcG9zZWQgdG8gc2luZ2xlXG4gICAgICogaXRlbSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgdHlwZTogXCJzaW5nbGVcIiB8IFwibXVsdGlcIjtcbiAgICAvKipcbiAgICAgKiBgbGlnaHRgIG9yIGBkYXJrYCBkcm9wZG93biB0aGVtZVxuICAgICAqL1xuICAgIHRoZW1lOiBcImxpZ2h0XCIgfCBcImRhcmtcIjtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gYHRydWVgIHRvIGRpc2FibGUgdGhlIGRyb3Bkb3duLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgZm9yIGEgbG9hZGluZyBkcm9wZG93bi5cbiAgICAgKi9cbiAgICBza2VsZXRvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBhbiBpbmxpbmUgZHJvcGRvd24uXG4gICAgICovXG4gICAgaW5saW5lOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgZm9yIGEgZHJvcGRvd24gd2l0aG91dCBhcnJvdyBrZXkgYWN0aXZhdGlvbi5cbiAgICAgKi9cbiAgICBkaXNhYmxlQXJyb3dLZXlzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgZm9yIGludmFsaWQgc3RhdGUuXG4gICAgICovXG4gICAgaW52YWxpZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBWYWx1ZSBkaXNwbGF5ZWQgaWYgZHJvcGRvd24gaXMgaW4gaW52YWxpZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBpbnZhbGlkVGV4dDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgd2FybmluZyAoY29udGVudHMgc2V0IGJ5IHdhcm5pbmdUZXh0KVxuICAgICAgKi9cbiAgICB3YXJuOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHdhcm5pbmcgdGV4dFxuICAgICAqL1xuICAgIHdhcm5UZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIHNldCB0byBgdHJ1ZWAgdG8gcGxhY2UgdGhlIGRyb3Bkb3duIHZpZXcgaW5saW5lIHdpdGggdGhlIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGFwcGVuZElubGluZTogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBRdWVyeSBzdHJpbmcgZm9yIHRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGBEcm9wZG93bmAuXG4gICAgICogVXNlZCB0byB0cmlnZ2VyIGNsb3NpbmcgdGhlIGRyb3Bkb3duIGlmIGl0IHNjcm9sbHMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQgb2YgdGhlIGBzY3JvbGxhYmxlQ29udGFpbmVyYC5cbiAgICAgKi9cbiAgICBzY3JvbGxhYmxlQ29udGFpbmVyOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZC4gVXNlIGBpdGVtVmFsdWVLZXlgIGluc3RlYWQuXG4gICAgICogU3BlY2lmaWVzIHRoZSBwcm9wZXJ0eSB0byBiZSB1c2VkIGFzIHRoZSByZXR1cm4gdmFsdWUgdG8gYG5nTW9kZWxgXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdjQgdXNlIGl0ZW1WYWx1ZUtleSBpbnN0ZWFkXG4gICAgICovXG4gICAgdmFsdWU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHByb3BlcnR5IHRvIGJlIHVzZWQgYXMgdGhlIHJldHVybiB2YWx1ZSB0byBgbmdNb2RlbGBcbiAgICAgKi9cbiAgICBpdGVtVmFsdWVLZXk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IGZlZWRiYWNrIChtb2RlKSBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAqIGB0b3BgOiBzZWxlY3RlZCBpdGVtIGp1bXBzIHRvIHRvcFxuICAgICAqIGBmaXhlZGA6IHNlbGVjdGVkIGl0ZW0gc3RheXMgYXQgaXQncyBwb3NpdGlvblxuICAgICAqIGB0b3AtYWZ0ZXItcmVvcGVuYDogc2VsZWN0ZWQgaXRlbSBqdW1wIHRvIHRvcCBhZnRlciByZW9wZW4gZHJvcGRvd25cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25GZWVkYmFjazogXCJ0b3BcIiB8IFwiZml4ZWRcIiB8IFwidG9wLWFmdGVyLXJlb3BlblwiO1xuICAgIC8qKlxuICAgICAqIEFjY2Vzc2libGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBvcGVucyB0aGUgZHJvcGRvd24gbGlzdC5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgYERST1BET1dOLk9QRU5gIHZhbHVlIGZyb20gdGhlIGkxOG4gc2VydmljZS5cbiAgICAgKi9cbiAgICBtZW51QnV0dG9uTGFiZWw6IGFueTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgbGFiZWwgZm9yIHRoZSBcIiMgc2VsZWN0ZWRcIiB0ZXh0LlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBgRFJPUERPV04uU0VMRUNURURgIHZhbHVlIGZyb20gdGhlIGkxOG4gc2VydmljZS5cbiAgICAgKi9cbiAgICBzZWxlY3RlZExhYmVsOiBhbnk7XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBhdXRvbWF0aWMgZHJvcFVwLlxuICAgICAqL1xuICAgIGRyb3BVcDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBzZWxlY3Rpb24gZXZlbnRzLlxuICAgICAqL1xuICAgIHNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8T2JqZWN0PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBldmVudCBub3RpZnlpbmcgdG8gb3RoZXIgY2xhc3NlcyB0aGF0IHRoZSBgRHJvcGRvd25gIGhhcyBiZWVuIGNsb3NlZCAoY29sbGFwc2VkKS5cbiAgICAgKi9cbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBldmVudCBub3RpZnlpbmcgdG8gb3RoZXIgY2xhc3NlcyB0aGF0IHRoZSBgRHJvcGRvd25gIGhhcyBiZWVuIGNsb3NlZCAoY29sbGFwc2VkKS5cbiAgICAgKi9cbiAgICBjbG9zZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgLyoqXG4gICAgICogTWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgQWJzdHJhY3REcm9wZG93blZpZXdgIG9iamVjdCB3aXRoaW4gdGhlIGNvbnRlbnQgRE9NLlxuICAgICAqL1xuICAgIHZpZXc6IEFic3RyYWN0RHJvcGRvd25WaWV3O1xuICAgIC8qKlxuICAgICAqIE1haW50YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgdmlldyBET00gZWxlbWVudCBvZiB0aGUgYERyb3Bkb3duYCBidXR0b24uXG4gICAgICovXG4gICAgZHJvcGRvd25CdXR0b246IGFueTtcbiAgICAvKipcbiAgICAgKiBWaWV3Q2hpZCBvZiB0aGUgZHJvcGRvd24gdmlldy5cbiAgICAgKi9cbiAgICBkcm9wZG93bk1lbnU6IGFueTtcbiAgICBob3N0Q2xhc3M6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCBpZiB0aGUgZHJvcGRvd24gaXMgY2xvc2VkIChub3QgZXhwYW5kZWQpLlxuICAgICAqL1xuICAgIG1lbnVJc0Nsb3NlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBjb250cm9scyB3aGV0aGVyIHRoZSBgZHJvcC11cGAgY2xhc3MgaXMgYXBwbGllZFxuICAgICAqL1xuICAgIF9kcm9wVXA6IGJvb2xlYW47XG4gICAgbm9vcDogYW55O1xuICAgIG91dHNpZGVDbGljazogYW55O1xuICAgIG91dHNpZGVLZXk6IGFueTtcbiAgICBrZXlib2FyZE5hdjogYW55O1xuICAgIHByb3RlY3RlZCB2aXNpYmlsaXR5U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJvdGVjdGVkIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkO1xuICAgIHByaXZhdGUgX3dyaXR0ZW5WYWx1ZTtcbiAgICBwcm90ZWN0ZWQgd3JpdHRlblZhbHVlOiBhbnlbXTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIERyb3Bkb3duLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGkxOG46IEkxOG4sIGRyb3Bkb3duU2VydmljZTogRHJvcGRvd25TZXJ2aWNlLCBhcHBSZWY6IEFwcGxpY2F0aW9uUmVmLCBlbGVtZW50U2VydmljZTogRWxlbWVudFNlcnZpY2UpO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGB0eXBlYCBwcm9wZXJ0eSBpbiB0aGUgYEBDb250ZW50Q2hpbGRgLlxuICAgICAqIFRoZSBgdHlwZWAgcHJvcGVydHkgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIGBEcm9wZG93bmAgYWxsb3dzIHNpbmdsZSBzZWxlY3Rpb24gb3IgbXVsdGkgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgY2xhc3NlcyBhbmQgc3Vic2NyaWJlcyB0byBldmVudHMgZm9yIHNpbmdsZSBvciBtdWx0aSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVtb3ZpbmcgdGhlIGBEcm9wZG93bmAgZnJvbSB0aGUgYm9keSBpZiBpdCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keS5cbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFByb3BhZ2F0ZXMgdGhlIGluamVjdGVkIGB2YWx1ZWAuXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZDtcbiAgICBvbkJsdXIoKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyaW5nIHRoZSBmdW5jdGlvbiBpbmplY3RlZCB0byBjb250cm9sIHRoZSB0b3VjaCB1c2Ugb2YgdGhlIGBEcm9wZG93bmAuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogZnVuY3Rpb24gcGFzc2VkIGluIGJ5IGByZWdpc3Rlck9uQ2hhbmdlYFxuICAgICAqL1xuICAgIHByb3BhZ2F0ZUNoYW5nZTogKF86IGFueSkgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIG1ldGhvZCB0byBwcm9ncmFtbWF0aWNhbGx5IGRpc2FibGUgdGhlIGRyb3Bkb3duLlxuICAgICAqXG4gICAgICogZXg6IGB0aGlzLmZvcm1Hcm91cC5nZXQoXCJteURyb3Bkb3duXCIpLmRpc2FibGUoKTtgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZCBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgaW5wdXRcbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEFkZHMga2V5Ym9hcmQgZnVuY3Rpb25hbGl0eSBmb3IgbmF2aWdhdGlvbiwgc2VsZWN0aW9uIGFuZCBjbG9zaW5nIG9mIHRoZSBgRHJvcGRvd25gLlxuICAgICAqL1xuICAgIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XG4gICAgY2xvc2VkRHJvcGRvd25OYXZpZ2F0aW9uKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgaWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24gYW5kIGRpc3BsYXlWYWx1ZSBpcyBzZXQsXG4gICAgICogaWYgdGhlcmUgaXMganVzdCBhIHNlbGVjdGlvbiB0aGUgTGlzdEl0ZW0gY29udGVudCBwcm9wZXJ0eSB3aWxsIGJlIHJldHVybmVkLFxuICAgICAqIG90aGVyd2lzZSB0aGUgcGxhY2Vob2xkZXIgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXREaXNwbGF5U3RyaW5nVmFsdWUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICAgIGlzUmVuZGVyU3RyaW5nKCk6IGJvb2xlYW47XG4gICAgZ2V0UmVuZGVyVGVtcGxhdGVDb250ZXh0KCk6IHtcbiAgICAgICAgaXRlbXM6IExpc3RJdGVtW107XG4gICAgICAgIGl0ZW0/OiB1bmRlZmluZWQ7XG4gICAgfSB8IHtcbiAgICAgICAgaXRlbTogTGlzdEl0ZW07XG4gICAgICAgIGl0ZW1zPzogdW5kZWZpbmVkO1xuICAgIH0gfCB7XG4gICAgICAgIGl0ZW1zPzogdW5kZWZpbmVkO1xuICAgICAgICBpdGVtPzogdW5kZWZpbmVkO1xuICAgIH07XG4gICAgZ2V0U2VsZWN0ZWRDb3VudCgpOiBudW1iZXI7XG4gICAgY2xlYXJTZWxlY3RlZCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGEgdmFsdWUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgdmFsdWVTZWxlY3RlZCgpOiBib29sZWFuO1xuICAgIF9ub29wKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgYERyb3Bkb3duYC5cbiAgICAgKi9cbiAgICBfb3V0c2lkZUNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIF9vdXRzaWRlS2V5KGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMga2V5Ym9hcmQgZXZlbnRzIHNvIHVzZXJzIGFyZSBjb250cm9sbGluZyB0aGUgYERyb3Bkb3duYCBpbnN0ZWFkIG9mIHVuaW50ZW50aW9uYWxseSBjb250cm9sbGluZyBvdXRzaWRlIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIF9rZXlib2FyZE5hdihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgYERyb3Bkb3duYCBsaXN0IGFwcGVuZGluZyBpdCB0byB0aGUgZHJvcGRvd24gcGFyZW50IG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBib2R5LlxuICAgICAqL1xuICAgIF9hcHBlbmRUb0Ryb3Bkb3duKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgYERyb3Bkb3duYCBsaXN0IGFzIGFuIGVsZW1lbnQgdGhhdCBpcyBhcHBlbmRlZCB0byB0aGUgRE9NIGJvZHkuXG4gICAgICovXG4gICAgX2FwcGVuZFRvQm9keSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERldGVjdHMgd2hldGhlciBvciBub3QgdGhlIGBEcm9wZG93bmAgbGlzdCBpcyB2aXNpYmxlIHdpdGhpbiBhbGwgc2Nyb2xsYWJsZSBwYXJlbnRzLlxuICAgICAqIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBpbiBhIHZhbHVlIHRvIHRoZSBgZHJvcFVwYCBpbnB1dC5cbiAgICAgKi9cbiAgICBfc2hvdWxkRHJvcFVwKCk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgZHJvcGRvd24gbWVudSBpbiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBvcGVuTWVudSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENvbGxhcHNpbmcgdGhlIGRyb3Bkb3duIG1lbnUgYW5kIHJlbW92aW5nIHVubmVjZXNzYXJ5IGBFdmVudExpc3RlbmVyc2AuXG4gICAgICovXG4gICAgY2xvc2VNZW51KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgdG9nZ2xpbmcgbWVudSBzdGF0ZXMgYmV0d2VlbiBvcGVuL2V4cGFuZGVkIGFuZCBjbG9zZWQvY29sbGFwc2VkLlxuICAgICAqL1xuICAgIHRvZ2dsZU1lbnUoKTogdm9pZDtcbiAgICBpc1RlbXBsYXRlKHZhbHVlOiBhbnkpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoZW4gaXQncyBuZWVkZWQgdG8gYXBwbHkgdGhlIHNlbGVjdGlvbiBmZWVkYmFja1xuICAgICAqL1xuICAgIHByb3RlY3RlZCBjaGVja0ZvclJlb3JkZXIoKTogdm9pZDtcbn1cbiJdfQ==