/**
 *
 * carbon-angular v0.0.0 | dropdown.service.js
 *
 * Copyright 2014, 2020 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Injectable } from "@angular/core";
import { PlaceholderService } from "./../placeholder/placeholder.module";
import { Subscription } from "rxjs";
import { position } from "@carbon/utils-position";
import { AnimationFrameService } from "./../utils/utils.module";
var defaultOffset = { top: 0, left: 0 };
var DropdownService = /** @class */ (function () {
    function DropdownService(placeholderService, animationFrameService) {
        this.placeholderService = placeholderService;
        this.animationFrameService = animationFrameService;
        /**
         * Maintains an Event Observable Subscription for the global requestAnimationFrame.
         * requestAnimationFrame is tracked only if the `Dropdown` is appended to the body otherwise we don't need it
         */
        this.animationFrameSubscription = new Subscription();
        this._offset = defaultOffset;
    }
    Object.defineProperty(DropdownService.prototype, "offset", {
        get: function () {
            return this._offset;
        },
        set: function (value) {
            this._offset = Object.assign({}, defaultOffset, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Appends the menu to the body, or a `ibm-placeholder` (if defined)
     *
     * @param parentRef container to position relative to
     * @param menuRef menu to be appended to body
     * @param classList any extra classes we should wrap the container with
     */
    DropdownService.prototype.appendToBody = function (parentRef, menuRef, classList) {
        var _this = this;
        // build the dropdown list container
        menuRef.style.display = "block";
        var dropdownWrapper = document.createElement("div");
        dropdownWrapper.className = "dropdown " + classList;
        dropdownWrapper.style.width = parentRef.offsetWidth + "px";
        dropdownWrapper.style.position = "absolute";
        dropdownWrapper.appendChild(menuRef);
        // append it to the placeholder
        if (this.placeholderService.hasPlaceholderRef()) {
            this.placeholderService.appendElement(dropdownWrapper);
            // or append it directly to the body
        }
        else {
            document.body.appendChild(dropdownWrapper);
        }
        this.menuInstance = dropdownWrapper;
        this.animationFrameSubscription = this.animationFrameService.tick.subscribe(function () {
            _this.positionDropdown(parentRef, dropdownWrapper);
        });
        return dropdownWrapper;
    };
    /**
     * Reattach the dropdown menu to the parent container
     * @param hostRef container to append to
     */
    DropdownService.prototype.appendToDropdown = function (hostRef) {
        // if the instance is already removed don't try and remove it again
        if (!this.menuInstance) {
            return;
        }
        var instance = this.menuInstance;
        var menu = instance.firstElementChild;
        // clean up the instance
        this.menuInstance = null;
        menu.style.display = "none";
        hostRef.appendChild(menu);
        this.animationFrameSubscription.unsubscribe();
        if (this.placeholderService.hasPlaceholderRef() && this.placeholderService.hasElement(instance)) {
            this.placeholderService.removeElement(instance);
        }
        else if (document.body.contains(instance)) {
            document.body.removeChild(instance);
        }
        return instance;
    };
    /**
     * position an open dropdown relative to the given parentRef
     */
    DropdownService.prototype.updatePosition = function (parentRef) {
        this.positionDropdown(parentRef, this.menuInstance);
    };
    DropdownService.prototype.ngOnDestroy = function () {
        this.animationFrameSubscription.unsubscribe();
    };
    DropdownService.prototype.positionDropdown = function (parentRef, menuRef) {
        if (!menuRef) {
            return;
        }
        var leftOffset = 0;
        var boxMenu = menuRef.querySelector(".bx--list-box__menu");
        // If the parentRef and boxMenu are in a different left position relative to the
        // window, the the boxMenu position has already been flipped and a check needs to be done
        // to see if it needs to stay flipped.
        if (parentRef.getBoundingClientRect().left !== boxMenu.getBoundingClientRect().left) {
            // The getBoundingClientRect().right of the boxMenu if it were hypothetically flipped
            // back into the original position before the flip.
            var testBoxMenuRightEdgePos = parentRef.getBoundingClientRect().left - boxMenu.getBoundingClientRect().left + boxMenu.getBoundingClientRect().right;
            if (testBoxMenuRightEdgePos > (window.innerWidth || document.documentElement.clientWidth)) {
                leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
            }
            // If it has not already been flipped, check if it is necessary to flip, ie. if the
            // boxMenu is outside of the right viewPort.
        }
        else if (boxMenu.getBoundingClientRect().right > (window.innerWidth || document.documentElement.clientWidth)) {
            leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
        }
        var pos = position.findAbsolute(parentRef, menuRef, "bottom");
        pos = position.addOffset(pos, this.offset.top, this.offset.left + leftOffset);
        position.setElement(menuRef, pos);
    };
    DropdownService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DropdownService.ctorParameters = function () { return [
        { type: PlaceholderService },
        { type: AnimationFrameService }
    ]; };
    return DropdownService;
}());
export { DropdownService };
//# sourceMappingURL=dropdown.service.js.map