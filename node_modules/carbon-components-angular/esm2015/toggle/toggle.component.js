/**
 *
 * carbon-angular v0.0.0 | toggle.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Checkbox } from "carbon-components-angular/checkbox";
import { ChangeDetectorRef, Component, Input, Output, EventEmitter, TemplateRef } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { I18n } from "carbon-components-angular/i18n";
/**
 * Defines the set of states for a toggle component.
 */
export var ToggleState;
(function (ToggleState) {
    ToggleState[ToggleState["Init"] = 0] = "Init";
    ToggleState[ToggleState["Indeterminate"] = 1] = "Indeterminate";
    ToggleState[ToggleState["Checked"] = 2] = "Checked";
    ToggleState[ToggleState["Unchecked"] = 3] = "Unchecked";
})(ToggleState || (ToggleState = {}));
/**
 * Used to emit changes performed on toggle components.
 *
 * @deprecated since v4
 */
export class ToggleChange {
}
/**
 * [See demo](../../?path=/story/components-toggle--basic)
 *
 * ```html
 * <ibm-toggle [(ngModel)]="toggleState">Toggle</ibm-toggle>
 * ```
 *
 * <example-url>../../iframe.html?id=components-toggle--basic</example-url>
 */
export class Toggle extends Checkbox {
    /**
     * Creates an instance of Toggle.
     */
    constructor(changeDetectorRef, i18n) {
        super(changeDetectorRef);
        this.changeDetectorRef = changeDetectorRef;
        this.i18n = i18n;
        /**
         * Size of the toggle component.
         */
        this.size = "md";
        /**
         * Set to `true` for a loading toggle.
         */
        this.skeleton = false;
        /**
         * The unique id allocated to the `Toggle`.
         */
        this.id = "toggle-" + Toggle.toggleCount;
        /**
         * Emits event notifying other classes when a change in state occurs on a toggle after a
         * click.
         *
         * @deprecated since v4
         */
        this.change = new EventEmitter();
        this._offValues = this.i18n.getOverridable("TOGGLE.OFF");
        this._onValues = this.i18n.getOverridable("TOGGLE.ON");
        Toggle.toggleCount++;
    }
    /**
     * Text that is set on the left side of the toggle.
     */
    set offText(value) {
        this._offValues.override(value);
    }
    get offText() {
        return this._offValues.value;
    }
    /**
     * Text that is set on the right side of the toggle.
     */
    set onText(value) {
        this._onValues.override(value);
    }
    get onText() {
        return this._onValues.value;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the toggle input.
     *
     * ex: `this.formGroup.get("myToggle").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    getOffText() {
        return this._offValues.subject;
    }
    getOnText() {
        return this._onValues.subject;
    }
    /**
     * Creates instance of `ToggleChange` used to propagate the change event.
     */
    emitChangeEvent() {
        /* begin deprecation */
        let event = new ToggleChange();
        event.source = this;
        event.checked = this.checked;
        this.change.emit(event);
        /* end deprecation */
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
/**
 * Variable used for creating unique ids for toggle components.
 */
Toggle.toggleCount = 0;
Toggle.decorators = [
    { type: Component, args: [{
                selector: "ibm-toggle",
                template: `
		<label *ngIf="label" [id]="ariaLabelledby" class="bx--label">
			<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
			<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
		</label>
		<input
			class="bx--toggle-input"
			type="checkbox"
			[ngClass]="{
				'bx--toggle-input--small': size === 'sm',
				'bx--skeleton': skeleton
			}"
			[id]="id"
			[value]="value"
			[name]="name"
			[required]="required"
			[checked]="checked"
			[disabled]="disabled"
			[attr.aria-labelledby]="ariaLabelledby"
			[attr.aria-checked]="checked"
			(change)="onChange($event)"
			(click)="onClick($event)">
		<label
			class="bx--toggle-input__label"
			[for]="id"
			[ngClass]="{
				'bx--skeleton': skeleton
			}">
			<span class="bx--toggle__switch">
				<span class="bx--toggle__text--off">{{(!skeleton ? getOffText() : null) | async }}</span>
				<span class="bx--toggle__text--on">{{(!skeleton ? getOnText() : null) | async}}</span>
			</span>
		</label>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Toggle,
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
Toggle.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: I18n }
];
Toggle.propDecorators = {
    offText: [{ type: Input }],
    onText: [{ type: Input }],
    label: [{ type: Input }],
    size: [{ type: Input }],
    skeleton: [{ type: Input }],
    change: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdG9nZ2xlLyIsInNvdXJjZXMiOlsidG9nZ2xlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDOUQsT0FBTyxFQUNOLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRW5ELE9BQU8sRUFBRSxJQUFJLEVBQWUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUduRTs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFdBS1g7QUFMRCxXQUFZLFdBQVc7SUFDdEIsNkNBQUksQ0FBQTtJQUNKLCtEQUFhLENBQUE7SUFDYixtREFBTyxDQUFBO0lBQ1AsdURBQVMsQ0FBQTtBQUNWLENBQUMsRUFMVyxXQUFXLEtBQVgsV0FBVyxRQUt0QjtBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLE9BQU8sWUFBWTtDQVN4QjtBQUVEOzs7Ozs7OztHQVFHO0FBNkNILE1BQU0sT0FBTyxNQUFPLFNBQVEsUUFBUTtJQXlEbkM7O09BRUc7SUFDSCxZQUFzQixpQkFBb0MsRUFBWSxJQUFVO1FBQy9FLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBREosc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUFZLFNBQUksR0FBSixJQUFJLENBQU07UUEzQmhGOztXQUVHO1FBQ00sU0FBSSxHQUFnQixJQUFJLENBQUM7UUFDbEM7O1dBRUc7UUFDTSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRTFCOztXQUVHO1FBQ0gsT0FBRSxHQUFHLFNBQVMsR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDO1FBRXBDOzs7OztXQUtHO1FBQ08sV0FBTSxHQUFHLElBQUksWUFBWSxFQUFnQixDQUFDO1FBRTFDLGVBQVUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNwRCxjQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7UUFNM0QsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3RCLENBQUM7SUF6REQ7O09BRUc7SUFDSCxJQUNJLE9BQU8sQ0FBQyxLQUFrQztRQUM3QyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBRUQsSUFBSSxPQUFPO1FBQ1YsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztJQUM5QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUNJLE1BQU0sQ0FBQyxLQUFrQztRQUM1QyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQsSUFBSSxNQUFNO1FBQ1QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUM3QixDQUFDO0lBcUNEOzs7Ozs7T0FNRztJQUNILGdCQUFnQixDQUFDLFVBQW1CO1FBQ25DLElBQUksQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO0lBQzVCLENBQUM7SUFFRCxVQUFVO1FBQ1QsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQztJQUNoQyxDQUFDO0lBRUQsU0FBUztRQUNSLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUM7SUFDL0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZUFBZTtRQUNkLHVCQUF1QjtRQUN2QixJQUFJLEtBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBQy9CLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4QixxQkFBcUI7UUFFckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFTSxVQUFVLENBQUMsS0FBSztRQUN0QixPQUFPLEtBQUssWUFBWSxXQUFXLENBQUM7SUFDckMsQ0FBQzs7QUFwR0Q7O0dBRUc7QUFDSSxrQkFBVyxHQUFHLENBQUMsQ0FBQzs7WUFoRHZCLFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsWUFBWTtnQkFDdEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFpQ1Q7Z0JBQ0QsU0FBUyxFQUFFO29CQUNWO3dCQUNDLE9BQU8sRUFBRSxpQkFBaUI7d0JBQzFCLFdBQVcsRUFBRSxNQUFNO3dCQUNuQixLQUFLLEVBQUUsSUFBSTtxQkFDWDtpQkFDRDthQUNEOzs7O1lBMUZBLGlCQUFpQjtZQVNULElBQUk7OztzQkEyRlgsS0FBSztxQkFZTCxLQUFLO29CQVdMLEtBQUs7bUJBSUwsS0FBSzt1QkFJTCxLQUFLO3FCQWFMLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGVja2JveCB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2NoZWNrYm94XCI7XG5pbXBvcnQge1xuXHRDaGFuZ2VEZXRlY3RvclJlZixcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRFdmVudEVtaXR0ZXIsXG5cdFRlbXBsYXRlUmVmXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuXG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIHNldCBvZiBzdGF0ZXMgZm9yIGEgdG9nZ2xlIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGVudW0gVG9nZ2xlU3RhdGUge1xuXHRJbml0LFxuXHRJbmRldGVybWluYXRlLFxuXHRDaGVja2VkLFxuXHRVbmNoZWNrZWRcbn1cblxuLyoqXG4gKiBVc2VkIHRvIGVtaXQgY2hhbmdlcyBwZXJmb3JtZWQgb24gdG9nZ2xlIGNvbXBvbmVudHMuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjRcbiAqL1xuZXhwb3J0IGNsYXNzIFRvZ2dsZUNoYW5nZSB7XG5cdC8qKlxuXHQgKiBDb250YWlucyB0aGUgYFRvZ2dsZWAgdGhhdCBoYXMgYmVlbiBjaGFuZ2VkLlxuXHQgKi9cblx0c291cmNlOiBUb2dnbGU7XG5cdC8qKlxuXHQgKiBUaGUgc3RhdGUgb2YgdGhlIGBUb2dnbGVgIGVuY29tcGFzc2VkIGluIHRoZSBgVG9nZ2xlQ2hhbmdlYCBjbGFzcy5cblx0ICovXG5cdGNoZWNrZWQ6IGJvb2xlYW47XG59XG5cbi8qKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy10b2dnbGUtLWJhc2ljKVxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tdG9nZ2xlIFsobmdNb2RlbCldPVwidG9nZ2xlU3RhdGVcIj5Ub2dnbGU8L2libS10b2dnbGU+XG4gKiBgYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9Y29tcG9uZW50cy10b2dnbGUtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS10b2dnbGVcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8bGFiZWwgKm5nSWY9XCJsYWJlbFwiIFtpZF09XCJhcmlhTGFiZWxsZWRieVwiIGNsYXNzPVwiYngtLWxhYmVsXCI+XG5cdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGxhYmVsKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxhYmVsXCI+PC9uZy10ZW1wbGF0ZT5cblx0XHQ8L2xhYmVsPlxuXHRcdDxpbnB1dFxuXHRcdFx0Y2xhc3M9XCJieC0tdG9nZ2xlLWlucHV0XCJcblx0XHRcdHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdCdieC0tdG9nZ2xlLWlucHV0LS1zbWFsbCc6IHNpemUgPT09ICdzbScsXG5cdFx0XHRcdCdieC0tc2tlbGV0b24nOiBza2VsZXRvblxuXHRcdFx0fVwiXG5cdFx0XHRbaWRdPVwiaWRcIlxuXHRcdFx0W3ZhbHVlXT1cInZhbHVlXCJcblx0XHRcdFtuYW1lXT1cIm5hbWVcIlxuXHRcdFx0W3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcblx0XHRcdFtjaGVja2VkXT1cImNoZWNrZWRcIlxuXHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0XHRbYXR0ci5hcmlhLWNoZWNrZWRdPVwiY2hlY2tlZFwiXG5cdFx0XHQoY2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuXHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soJGV2ZW50KVwiPlxuXHRcdDxsYWJlbFxuXHRcdFx0Y2xhc3M9XCJieC0tdG9nZ2xlLWlucHV0X19sYWJlbFwiXG5cdFx0XHRbZm9yXT1cImlkXCJcblx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0J2J4LS1za2VsZXRvbic6IHNrZWxldG9uXG5cdFx0XHR9XCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS10b2dnbGVfX3N3aXRjaFwiPlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS10b2dnbGVfX3RleHQtLW9mZlwiPnt7KCFza2VsZXRvbiA/IGdldE9mZlRleHQoKSA6IG51bGwpIHwgYXN5bmMgfX08L3NwYW4+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYngtLXRvZ2dsZV9fdGV4dC0tb25cIj57eyghc2tlbGV0b24gPyBnZXRPblRleHQoKSA6IG51bGwpIHwgYXN5bmN9fTwvc3Bhbj5cblx0XHRcdDwvc3Bhbj5cblx0XHQ8L2xhYmVsPlxuXHRgLFxuXHRwcm92aWRlcnM6IFtcblx0XHR7XG5cdFx0XHRwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcblx0XHRcdHVzZUV4aXN0aW5nOiBUb2dnbGUsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGUgZXh0ZW5kcyBDaGVja2JveCB7XG5cdC8qKlxuXHQgKiBWYXJpYWJsZSB1c2VkIGZvciBjcmVhdGluZyB1bmlxdWUgaWRzIGZvciB0b2dnbGUgY29tcG9uZW50cy5cblx0ICovXG5cdHN0YXRpYyB0b2dnbGVDb3VudCA9IDA7XG5cblx0LyoqXG5cdCAqIFRleHQgdGhhdCBpcyBzZXQgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgdG9nZ2xlLlxuXHQgKi9cblx0QElucHV0KClcblx0c2V0IG9mZlRleHQodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX29mZlZhbHVlcy5vdmVycmlkZSh2YWx1ZSk7XG5cdH1cblxuXHRnZXQgb2ZmVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2ZmVmFsdWVzLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRleHQgdGhhdCBpcyBzZXQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpXG5cdHNldCBvblRleHQodmFsdWU6IHN0cmluZyB8IE9ic2VydmFibGU8c3RyaW5nPikge1xuXHRcdHRoaXMuX29uVmFsdWVzLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBvblRleHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29uVmFsdWVzLnZhbHVlO1xuXHR9XG5cdC8qKlxuXHQgKiBUZXh0IHRoYXQgaXMgc2V0IGFzIHRoZSBsYWJlbCBvZiB0aGUgdG9nZ2xlLlxuXHQgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSB0b2dnbGUgY29tcG9uZW50LlxuXHQgKi9cblx0QElucHV0KCkgc2l6ZTogXCJzbVwiIHwgXCJtZFwiID0gXCJtZFwiO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIHRvZ2dsZS5cblx0ICovXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIFRoZSB1bmlxdWUgaWQgYWxsb2NhdGVkIHRvIHRoZSBgVG9nZ2xlYC5cblx0ICovXG5cdGlkID0gXCJ0b2dnbGUtXCIgKyBUb2dnbGUudG9nZ2xlQ291bnQ7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyBvdGhlciBjbGFzc2VzIHdoZW4gYSBjaGFuZ2UgaW4gc3RhdGUgb2NjdXJzIG9uIGEgdG9nZ2xlIGFmdGVyIGFcblx0ICogY2xpY2suXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0XG5cdCAqL1xuXHRAT3V0cHV0KCkgY2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVDaGFuZ2U+KCk7XG5cblx0cHJvdGVjdGVkIF9vZmZWYWx1ZXMgPSB0aGlzLmkxOG4uZ2V0T3ZlcnJpZGFibGUoXCJUT0dHTEUuT0ZGXCIpO1xuXHRwcm90ZWN0ZWQgX29uVmFsdWVzID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVE9HR0xFLk9OXCIpO1xuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBUb2dnbGUuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBwcm90ZWN0ZWQgaTE4bjogSTE4bikge1xuXHRcdHN1cGVyKGNoYW5nZURldGVjdG9yUmVmKTtcblx0XHRUb2dnbGUudG9nZ2xlQ291bnQrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIG1ldGhvZCB0byBwcm9ncmFtbWF0aWNhbGx5IGRpc2FibGUgdGhlIHRvZ2dsZSBpbnB1dC5cblx0ICpcblx0ICogZXg6IGB0aGlzLmZvcm1Hcm91cC5nZXQoXCJteVRvZ2dsZVwiKS5kaXNhYmxlKCk7YFxuXHQgKlxuXHQgKiBAcGFyYW0gaXNEaXNhYmxlZCBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgaW5wdXRcblx0ICovXG5cdHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXHR9XG5cblx0Z2V0T2ZmVGV4dCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9vZmZWYWx1ZXMuc3ViamVjdDtcblx0fVxuXG5cdGdldE9uVGV4dCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9vblZhbHVlcy5zdWJqZWN0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgYFRvZ2dsZUNoYW5nZWAgdXNlZCB0byBwcm9wYWdhdGUgdGhlIGNoYW5nZSBldmVudC5cblx0ICovXG5cdGVtaXRDaGFuZ2VFdmVudCgpIHtcblx0XHQvKiBiZWdpbiBkZXByZWNhdGlvbiAqL1xuXHRcdGxldCBldmVudCA9IG5ldyBUb2dnbGVDaGFuZ2UoKTtcblx0XHRldmVudC5zb3VyY2UgPSB0aGlzO1xuXHRcdGV2ZW50LmNoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG5cdFx0dGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG5cdFx0LyogZW5kIGRlcHJlY2F0aW9uICovXG5cblx0XHR0aGlzLmNoZWNrZWRDaGFuZ2UuZW1pdCh0aGlzLmNoZWNrZWQpO1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuY2hlY2tlZCk7XG5cdH1cblxuXHRwdWJsaWMgaXNUZW1wbGF0ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuXHR9XG59XG4iXX0=