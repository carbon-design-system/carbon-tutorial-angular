/**
 *
 * carbon-angular v0.0.0 | table.component.d.ts
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { ApplicationRef, EventEmitter, ElementRef, AfterViewInit, TemplateRef, OnDestroy } from "@angular/core";
import { Subscription, Observable } from "rxjs";
import { TableModel } from "./table-model.class";
import { TableItem } from "./table-item.class";
import { I18n, Overridable } from "carbon-components-angular/i18n";
import { DataGridInteractionModel } from "./data-grid-interaction-model.class";
import { TableRowSize } from "./table.types";
/**
 * Build your table with this component by extending things that differ from default.
 *
 * [See demo](../../?path=/story/components-table--basic)
 *
 * Instead of the usual write-your-own-html approach you had with `<table>`,
 * carbon table uses model-view-controller approach.
 *
 * Here, you create a view (with built-in controller) and provide it a model.
 * Changes you make to the model are reflected in the view. Provide same model you use
 * in the table to the `<ibm-pagination>` components.
 * They provide a different view over the same data.
 *
 * ## Basic usage
 *
 * ```html
 * <ibm-table [model]="model"></ibm-table>
 * ```
 *
 * ```typescript
 * public model = new TableModel();
 *
 * this.model.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: "qwer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "zwer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})]
 * ];
 * ```
 *
 * ## Customization
 *
 * If you have custom data in your table, you need a way to display it. You can do that
 * by providing a template to `TableItem`.
 *
 * ```html
 * <ng-template #customTableItemTemplate let-data="data">
 * 	<a [routerLink]="data.link">{{data.name}} {{data.surname}}</a>
 * </ng-template>
 * ```
 *
 * ```typescript
 * customTableItemTemplate: TemplateRef<any>;
 *
 * this.customModel.data = [
 * 	[new TableItem({data: "asdf"}), new TableItem({data: {name: "Lessy", link: "/table"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "swer"})],
 * 	[new TableItem({data: "bsdf"}), new TableItem({data: {name: "Alice", surname: "Bob"}, template: this.customTableItemTemplate})],
 * 	[new TableItem({data: "csdf"}), new TableItem({data: "twer"})],
 * ];
 * ```
 *
 * ### Sorting and filtering
 *
 * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`
 * and override needed functions.
 *
 * ```typescript
 * class FilterableHeaderItem extends TableHeaderItem {
 * 	// custom filter function
 * 	filter(item: TableItem): boolean {
 * 		if (typeof item.data === "string" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||
 * 		item.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {
 * 			return false;
 * 		}
 * 		return true;
 * 	}
 *
 * 	set filterCount(n) {}
 * 	get filterCount() {
 * 		return (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;
 * 	}
 *
 * 	// used for custom sorting
 * 	compare(one: TableItem, two: TableItem) {
 * 		const stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();
 * 		const stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();
 *
 * 		if (stringOne > stringTwo) {
 * 			return 1;
 * 		} else if (stringOne < stringTwo) {
 * 			return -1;
 * 		} else {
 * 			return 0;
 * 		}
 * 	}
 * }
 * ```
 *
 * If you want to do your sorting on the backend or query for sorted data as a result of user
 * clicking the table header, check table [`sort`](#sort) output documentation
 *
 * See `TableHeaderItem` class for more information.
 *
 * ## No data template
 *
 * When table has no data to show, it can show a message you provide it instead.
 *
 * ```html
 * <ibm-table [model]="model">No data.</ibm-table>
 * ```
 *
 * ... will show `No data.` message, but you can get creative and provide any template you want
 * to replace table's default `tbody`.
 *
 * ## Use pagination as table footer
 *
 * ```html
 * <ibm-pagination [model]="model" (selectPage)="selectPage($event)"></ibm-pagination>
 * ```
 *
 * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,
 * and update `model.currentPage`.
 *
 * If the data your server returns is a two dimensional array of objects, it would look something like this:
 *
 * ```typescript
 * selectPage(page) {
 * 	this.getPage(page).then((data: Array<Array<any>>) => {
 * 		// set the data and update page
 * 		this.model.data = this.prepareData(data);
 * 		this.model.currentPage = page;
 * 	});
 * }
 *
 * protected prepareData(data: Array<Array<any>>) {
 * 	// create new data from the service data
 * 	let newData = [];
 * 	data.forEach(dataRow => {
 * 		let row = [];
 * 		dataRow.forEach(dataElement => {
 * 			row.push(new TableItem({
 * 				data: dataElement,
 * 				template: typeof dataElement === "string" ? undefined : this.paginationTableItemTemplate
 * 				// your template can handle all the data types so you don't have to conditionally set it
 * 				// you can also set different templates for different columns based on index
 * 			}));
 * 		});
 * 		newData.push(row);
 * 	});
 * 	return newData;
 * }
 * ```
 *
 * <example-url>../../iframe.html?id=components-table--basic</example-url>
 */
import * as ɵngcc0 from '@angular/core';
export declare class Table implements AfterViewInit, OnDestroy {
    protected elementRef: ElementRef;
    protected applicationRef: ApplicationRef;
    protected i18n: I18n;
    /**
     * Creates a skeleton model with a row and column count specified by the user
     *
     * Example:
     *
     * ```typescript
     * this.model = Table.skeletonModel(5, 5);
     * ```
     */
    static skeletonModel(rowCount: number, columnCount: number): TableModel;
    static setTabIndex(element: HTMLElement, index: -1 | 0): void;
    static focus(element: HTMLElement): void;
    /**
     * `TableModel` with data the table is to display.
     */
    model: TableModel;
    /**
     * Size of the table rows.
     */
    size: TableRowSize;
    /**
     * Set to `true` for a loading table.
     */
    skeleton: boolean;
    /**
     * Set to `true` for a data grid with keyboard interactions.
     */
    isDataGrid: boolean;
    /**
     * Setting sortable to false will disable all headers including headers which are sortable. Is is
     * possible to set the sortable state on the header item to disable/enable sorting for only some headers.
     */
    sortable: boolean;
    noBorder: boolean;
    /**
     * Controls whether to show the selection checkboxes column or not.
     */
    showSelectionColumn: boolean;
    /**
     * Controls whether to enable multiple or single row selection.
     */
    enableSingleSelect: boolean;
    /**
     * Distance (in px) from the bottom that view has to reach before
     * `scrollLoad` event is emitted.
     */
    scrollLoadDistance: number;
    /**
     * Set to `true` to enable users to resize columns.
     *
     * Works for columns with width set in pixels.
     *
     */
    columnsResizable: boolean;
    /**
     * Set to `true` to enable users to drag and drop columns.
     *
     * Changing the column order in table changes table model. Be aware of it when you add additional data
     * to the model.
     *
     */
    columnsDraggable: boolean;
    expandButtonAriaLabel: string | Observable<string>;
    sortDescendingLabel: string | Observable<string>;
    sortAscendingLabel: string | Observable<string>;
    /**
     * Expects an object that contains some or all of:
     * ```
     * {
     *		"FILTER": "Filter",
     *		"END_OF_DATA": "You've reached the end of your content",
     *		"SCROLL_TOP": "Scroll to top",
     *		"CHECKBOX_HEADER": "Select all rows",
     *		"CHECKBOX_ROW": "Select row"
     * }
     * ```
     */
    translations: any;
    /**
     * Set to `false` to remove table rows (zebra) stripes.
     */
    striped: boolean;
    /**
     * Set to `true` to stick the header to the top of the table
     */
    stickyHeader: boolean;
    /**
     * Set footer template to customize what is displayed in the tfoot section of the table
     */
    footerTemplate: TemplateRef<any>;
    /**
     * Used to populate the row selection checkbox label with a useful value if set.
     *
     * Example:
     * ```
     * <ibm-table [selectionLabelColumn]="0"></ibm-table>
     * <!-- results in aria-label="Select first column value"
     * (where "first column value" is the value of the first column in the row -->
     * ```
     */
    selectionLabelColumn: number;
    /**
     * Emits an index of the column that wants to be sorted.
     *
     * If no observers are provided (default), table will attempt to do a simple sort of the data loaded
     * into the model.
     *
     * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer
     * to sort the table. This is what you typically want if you're using a backend query to get the sorted
     * data or want to sort data across multiple pages.
     *
     * Usage:
     *
     * ```typescript
     * @Component({
     * 	selector: "app-table",
     * 	template: `
     * 		<ibm-table
     * 			[model]="model"
     * 			(sort)="simpleSort($event)">
     * 			No data.
     * 		</ibm-table>
     * 	`
     * })
     * export class TableApp implements OnInit, OnChanges {
     * 	@Input() model = new TableModel();
     *
     * 	ngOnInit() {
     * 		this.model.header = [
     * 			new TableHeaderItem({ data: "Name" }),
     * 			new TableHeaderItem({ data: "hwer" })
     * 		];
     *
     * 		this.model.data = [
     * 			[new TableItem({ data: "Name 1" }), new TableItem({ data: "qwer" })],
     * 			[new TableItem({ data: "Name 3" }), new TableItem({ data: "zwer" })],
     * 			[new TableItem({ data: "Name 2" }), new TableItem({ data: "swer" })],
     * 			[new TableItem({ data: "Name 4" }), new TableItem({data: "twer"})],
     * 			[new TableItem({ data: "Name 5" }), new TableItem({data: "twer"})],
     * 			[new TableItem({ data: "Name 6" }), new TableItem({data: "twer"})]
     * 		];
     * 	}
     *
     * 	simpleSort(index: number) {
     * 		// this function does a simple sort, which is the default for the table and if that's
     * 		// all you want, you don't need to do this.
     *
     * 		// here you can query your backend and update the model.data based on the result
     * 		if (this.model.header[index].sorted) {
     * 			// if already sorted flip sorting direction
     * 			this.model.header[index].ascending = this.model.header[index].descending;
     * 		}
     * 		this.model.sort(index);
     * 	}
     * }
     * ```
     */
    sort: EventEmitter<number>;
    /**
     * Emits if all rows are selected.
     *
     * @param model
     */
    selectAll: EventEmitter<Object>;
    /**
     * Emits if all rows are deselected.
     *
     * @param model
     */
    deselectAll: EventEmitter<Object>;
    /**
     * Emits if a single row is selected.
     *
     * @param ({model: this.model, selectedRowIndex: index})
     */
    selectRow: EventEmitter<Object>;
    /**
     * Emits if a single row is deselected.
     *
     * @param ({model: this.model, deselectedRowIndex: index})
     */
    deselectRow: EventEmitter<Object>;
    /**
     * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
     */
    rowClick: EventEmitter<number>;
    /**
     * Emits when table requires more data to be loaded.
     */
    scrollLoad: EventEmitter<TableModel>;
    /**
     * Controls if all checkboxes are viewed as selected.
     */
    selectAllCheckbox: boolean;
    /**
     * Controls the indeterminate state of the header checkbox.
     */
    selectAllCheckboxSomeSelected: boolean;
    readonly noData: boolean;
    isColumnDragging: boolean;
    columnDraggedHoverIndex: number;
    columnDraggedPosition: string;
    protected _model: TableModel;
    protected _isDataGrid: boolean;
    protected isViewReady: boolean;
    protected subscriptions: Subscription;
    protected positionSubscription: Subscription;
    protected interactionModel: DataGridInteractionModel;
    protected interactionPositionSubscription: Subscription;
    protected _expandButtonAriaLabel: Overridable;
    protected _sortDescendingLabel: Overridable;
    protected _sortAscendingLabel: Overridable;
    protected _checkboxHeaderLabel: Overridable;
    protected _checkboxRowLabel: Overridable;
    protected _endOfDataText: Overridable;
    protected _scrollTopText: Overridable;
    protected _filterTitle: Overridable;
    protected columnResizeWidth: number;
    protected columnResizeMouseX: number;
    protected mouseMoveSubscription: Subscription;
    protected mouseUpSubscription: Subscription;
    /**
     * Creates an instance of Table.
     */
    constructor(elementRef: ElementRef, applicationRef: ApplicationRef, i18n: I18n);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    enableDataGridInteractions(): void;
    disableDataGridInteractions(): void;
    onSelectAll(): void;
    onDeselectAll(): void;
    onSelectRow(event: any): void;
    onRowClick(index: number): void;
    updateSelectAllCheckbox(): void;
    resetTabIndex(newTabIndex?: number): void;
    columnResizeStart(event: any, column: any): void;
    columnResizeProgress(event: any, column: any): void;
    columnResizeEnd(event: any, column: any): void;
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    onScroll(event: any): void;
    columnDragStart(event: any, columnIndex: any): void;
    columnDragEnd(event: any, columnIndex: any): void;
    columnDragEnter(event: any, position: any, columnIndex: any): void;
    columnDragLeave(event: any, position: any, columnIndex: any): void;
    columnDragover(event: any, position: any, columnIndex: any): void;
    columnDrop(event: any, position: any, columnIndex: any): void;
    doSort(index: number): void;
    /**
     * Triggered when the user scrolls on the `<tbody>` element.
     * Emits the `scrollLoad` event.
     */
    scrollToTop(event: any): void;
    getSelectionLabelValue(row: TableItem[]): {
        value: any;
    };
    getExpandButtonAriaLabel(): Observable<string>;
    getSortDescendingLabel(): Observable<string>;
    getSortAscendingLabel(): Observable<string>;
    getCheckboxHeaderLabel(): Observable<string>;
    getCheckboxRowLabel(): Observable<string>;
    getEndOfDataText(): Observable<string>;
    getScrollTopText(): Observable<string>;
    getFilterTitle(): Observable<string>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<Table>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<Table, "ibm-table", never, {
    "size": "size";
    "skeleton": "skeleton";
    "sortable": "sortable";
    "noBorder": "noBorder";
    "showSelectionColumn": "showSelectionColumn";
    "enableSingleSelect": "enableSingleSelect";
    "scrollLoadDistance": "scrollLoadDistance";
    "columnsResizable": "columnsResizable";
    "columnsDraggable": "columnsDraggable";
    "striped": "striped";
    "stickyHeader": "stickyHeader";
    "model": "model";
    "isDataGrid": "isDataGrid";
    "expandButtonAriaLabel": "expandButtonAriaLabel";
    "sortDescendingLabel": "sortDescendingLabel";
    "sortAscendingLabel": "sortAscendingLabel";
    "translations": "translations";
    "footerTemplate": "footerTemplate";
    "selectionLabelColumn": "selectionLabelColumn";
}, {
    "sort": "sort";
    "selectAll": "selectAll";
    "deselectAll": "deselectAll";
    "selectRow": "selectRow";
    "deselectRow": "deselectRow";
    "rowClick": "rowClick";
    "scrollLoad": "scrollLoad";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbInRhYmxlLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEtBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4UUEiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBjYXJib24tYW5ndWxhciB2MC4wLjAgfCB0YWJsZS5jb21wb25lbnQuZC50c1xuICpcbiAqIENvcHlyaWdodCAyMDE0LCAyMDIxIElCTVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuaW1wb3J0IHsgQXBwbGljYXRpb25SZWYsIEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiwgQWZ0ZXJWaWV3SW5pdCwgVGVtcGxhdGVSZWYsIE9uRGVzdHJveSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIE9ic2VydmFibGUgfSBmcm9tIFwicnhqc1wiO1xuaW1wb3J0IHsgVGFibGVNb2RlbCB9IGZyb20gXCIuL3RhYmxlLW1vZGVsLmNsYXNzXCI7XG5pbXBvcnQgeyBUYWJsZUl0ZW0gfSBmcm9tIFwiLi90YWJsZS1pdGVtLmNsYXNzXCI7XG5pbXBvcnQgeyBJMThuLCBPdmVycmlkYWJsZSB9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2kxOG5cIjtcbmltcG9ydCB7IERhdGFHcmlkSW50ZXJhY3Rpb25Nb2RlbCB9IGZyb20gXCIuL2RhdGEtZ3JpZC1pbnRlcmFjdGlvbi1tb2RlbC5jbGFzc1wiO1xuaW1wb3J0IHsgVGFibGVSb3dTaXplIH0gZnJvbSBcIi4vdGFibGUudHlwZXNcIjtcbi8qKlxuICogQnVpbGQgeW91ciB0YWJsZSB3aXRoIHRoaXMgY29tcG9uZW50IGJ5IGV4dGVuZGluZyB0aGluZ3MgdGhhdCBkaWZmZXIgZnJvbSBkZWZhdWx0LlxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NvbXBvbmVudHMtdGFibGUtLWJhc2ljKVxuICpcbiAqIEluc3RlYWQgb2YgdGhlIHVzdWFsIHdyaXRlLXlvdXItb3duLWh0bWwgYXBwcm9hY2ggeW91IGhhZCB3aXRoIGA8dGFibGU+YCxcbiAqIGNhcmJvbiB0YWJsZSB1c2VzIG1vZGVsLXZpZXctY29udHJvbGxlciBhcHByb2FjaC5cbiAqXG4gKiBIZXJlLCB5b3UgY3JlYXRlIGEgdmlldyAod2l0aCBidWlsdC1pbiBjb250cm9sbGVyKSBhbmQgcHJvdmlkZSBpdCBhIG1vZGVsLlxuICogQ2hhbmdlcyB5b3UgbWFrZSB0byB0aGUgbW9kZWwgYXJlIHJlZmxlY3RlZCBpbiB0aGUgdmlldy4gUHJvdmlkZSBzYW1lIG1vZGVsIHlvdSB1c2VcbiAqIGluIHRoZSB0YWJsZSB0byB0aGUgYDxpYm0tcGFnaW5hdGlvbj5gIGNvbXBvbmVudHMuXG4gKiBUaGV5IHByb3ZpZGUgYSBkaWZmZXJlbnQgdmlldyBvdmVyIHRoZSBzYW1lIGRhdGEuXG4gKlxuICogIyMgQmFzaWMgdXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKiA8aWJtLXRhYmxlIFttb2RlbF09XCJtb2RlbFwiPjwvaWJtLXRhYmxlPlxuICogYGBgXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogcHVibGljIG1vZGVsID0gbmV3IFRhYmxlTW9kZWwoKTtcbiAqXG4gKiB0aGlzLm1vZGVsLmRhdGEgPSBbXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImFzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInF3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiendlclwifSldLFxuICogXHRbbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJic2RmXCJ9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJzd2VyXCJ9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXVxuICogXTtcbiAqIGBgYFxuICpcbiAqICMjIEN1c3RvbWl6YXRpb25cbiAqXG4gKiBJZiB5b3UgaGF2ZSBjdXN0b20gZGF0YSBpbiB5b3VyIHRhYmxlLCB5b3UgbmVlZCBhIHdheSB0byBkaXNwbGF5IGl0LiBZb3UgY2FuIGRvIHRoYXRcbiAqIGJ5IHByb3ZpZGluZyBhIHRlbXBsYXRlIHRvIGBUYWJsZUl0ZW1gLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuZy10ZW1wbGF0ZSAjY3VzdG9tVGFibGVJdGVtVGVtcGxhdGUgbGV0LWRhdGE9XCJkYXRhXCI+XG4gKiBcdDxhIFtyb3V0ZXJMaW5rXT1cImRhdGEubGlua1wiPnt7ZGF0YS5uYW1lfX0ge3tkYXRhLnN1cm5hbWV9fTwvYT5cbiAqIDwvbmctdGVtcGxhdGU+XG4gKiBgYGBcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAqXG4gKiB0aGlzLmN1c3RvbU1vZGVsLmRhdGEgPSBbXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImFzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiB7bmFtZTogXCJMZXNzeVwiLCBsaW5rOiBcIi90YWJsZVwifSwgdGVtcGxhdGU6IHRoaXMuY3VzdG9tVGFibGVJdGVtVGVtcGxhdGV9KV0sXG4gKiBcdFtuZXcgVGFibGVJdGVtKHtkYXRhOiBcImNzZGZcIn0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInN3ZXJcIn0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiYnNkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IHtuYW1lOiBcIkFsaWNlXCIsIHN1cm5hbWU6IFwiQm9iXCJ9LCB0ZW1wbGF0ZTogdGhpcy5jdXN0b21UYWJsZUl0ZW1UZW1wbGF0ZX0pXSxcbiAqIFx0W25ldyBUYWJsZUl0ZW0oe2RhdGE6IFwiY3NkZlwifSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldLFxuICogXTtcbiAqIGBgYFxuICpcbiAqICMjIyBTb3J0aW5nIGFuZCBmaWx0ZXJpbmdcbiAqXG4gKiBJbiBjYXNlIHlvdSBuZWVkIGN1c3RvbSBzb3J0aW5nIGFuZC9vciBmaWx0ZXJpbmcgeW91IHNob3VsZCBzdWJjbGFzcyBgVGFibGVIZWFkZXJJdGVtYFxuICogYW5kIG92ZXJyaWRlIG5lZWRlZCBmdW5jdGlvbnMuXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY2xhc3MgRmlsdGVyYWJsZUhlYWRlckl0ZW0gZXh0ZW5kcyBUYWJsZUhlYWRlckl0ZW0ge1xuICogXHQvLyBjdXN0b20gZmlsdGVyIGZ1bmN0aW9uXG4gKiBcdGZpbHRlcihpdGVtOiBUYWJsZUl0ZW0pOiBib29sZWFuIHtcbiAqIFx0XHRpZiAodHlwZW9mIGl0ZW0uZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBpdGVtLmRhdGEudG9Mb3dlckNhc2UoKS5pbmRleE9mKHRoaXMuZmlsdGVyRGF0YS5kYXRhLnRvTG93ZXJDYXNlKCkpID49IDAgfHxcbiAqIFx0XHRpdGVtLmRhdGEubmFtZSAmJiBpdGVtLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXJEYXRhLmRhdGEudG9Mb3dlckNhc2UoKSkgPj0gMCB8fFxuICogXHRcdGl0ZW0uZGF0YS5zdXJuYW1lICYmIGl0ZW0uZGF0YS5zdXJuYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlckRhdGEuZGF0YS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gKiBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gKiBcdFx0fVxuICogXHRcdHJldHVybiB0cnVlO1xuICogXHR9XG4gKlxuICogXHRzZXQgZmlsdGVyQ291bnQobikge31cbiAqIFx0Z2V0IGZpbHRlckNvdW50KCkge1xuICogXHRcdHJldHVybiAodGhpcy5maWx0ZXJEYXRhICYmIHRoaXMuZmlsdGVyRGF0YS5kYXRhICYmIHRoaXMuZmlsdGVyRGF0YS5kYXRhLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gKiBcdH1cbiAqXG4gKiBcdC8vIHVzZWQgZm9yIGN1c3RvbSBzb3J0aW5nXG4gKiBcdGNvbXBhcmUob25lOiBUYWJsZUl0ZW0sIHR3bzogVGFibGVJdGVtKSB7XG4gKiBcdFx0Y29uc3Qgc3RyaW5nT25lID0gKG9uZS5kYXRhLm5hbWUgfHwgb25lLmRhdGEuc3VybmFtZSB8fCBvbmUuZGF0YSkudG9Mb3dlckNhc2UoKTtcbiAqIFx0XHRjb25zdCBzdHJpbmdUd28gPSAodHdvLmRhdGEubmFtZSB8fCB0d28uZGF0YS5zdXJuYW1lIHx8IHR3by5kYXRhKS50b0xvd2VyQ2FzZSgpO1xuICpcbiAqIFx0XHRpZiAoc3RyaW5nT25lID4gc3RyaW5nVHdvKSB7XG4gKiBcdFx0XHRyZXR1cm4gMTtcbiAqIFx0XHR9IGVsc2UgaWYgKHN0cmluZ09uZSA8IHN0cmluZ1R3bykge1xuICogXHRcdFx0cmV0dXJuIC0xO1xuICogXHRcdH0gZWxzZSB7XG4gKiBcdFx0XHRyZXR1cm4gMDtcbiAqIFx0XHR9XG4gKiBcdH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIElmIHlvdSB3YW50IHRvIGRvIHlvdXIgc29ydGluZyBvbiB0aGUgYmFja2VuZCBvciBxdWVyeSBmb3Igc29ydGVkIGRhdGEgYXMgYSByZXN1bHQgb2YgdXNlclxuICogY2xpY2tpbmcgdGhlIHRhYmxlIGhlYWRlciwgY2hlY2sgdGFibGUgW2Bzb3J0YF0oI3NvcnQpIG91dHB1dCBkb2N1bWVudGF0aW9uXG4gKlxuICogU2VlIGBUYWJsZUhlYWRlckl0ZW1gIGNsYXNzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqICMjIE5vIGRhdGEgdGVtcGxhdGVcbiAqXG4gKiBXaGVuIHRhYmxlIGhhcyBubyBkYXRhIHRvIHNob3csIGl0IGNhbiBzaG93IGEgbWVzc2FnZSB5b3UgcHJvdmlkZSBpdCBpbnN0ZWFkLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tdGFibGUgW21vZGVsXT1cIm1vZGVsXCI+Tm8gZGF0YS48L2libS10YWJsZT5cbiAqIGBgYFxuICpcbiAqIC4uLiB3aWxsIHNob3cgYE5vIGRhdGEuYCBtZXNzYWdlLCBidXQgeW91IGNhbiBnZXQgY3JlYXRpdmUgYW5kIHByb3ZpZGUgYW55IHRlbXBsYXRlIHlvdSB3YW50XG4gKiB0byByZXBsYWNlIHRhYmxlJ3MgZGVmYXVsdCBgdGJvZHlgLlxuICpcbiAqICMjIFVzZSBwYWdpbmF0aW9uIGFzIHRhYmxlIGZvb3RlclxuICpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tcGFnaW5hdGlvbiBbbW9kZWxdPVwibW9kZWxcIiAoc2VsZWN0UGFnZSk9XCJzZWxlY3RQYWdlKCRldmVudClcIj48L2libS1wYWdpbmF0aW9uPlxuICogYGBgXG4gKlxuICogYHNlbGVjdFBhZ2UoKWAgZnVuY3Rpb24gc2hvdWxkIGZldGNoIHRoZSBkYXRhIGZyb20gYmFja2VuZCwgY3JlYXRlIG5ldyBgZGF0YWAsIGFwcGx5IGl0IHRvIGBtb2RlbC5kYXRhYCxcbiAqIGFuZCB1cGRhdGUgYG1vZGVsLmN1cnJlbnRQYWdlYC5cbiAqXG4gKiBJZiB0aGUgZGF0YSB5b3VyIHNlcnZlciByZXR1cm5zIGlzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIG9iamVjdHMsIGl0IHdvdWxkIGxvb2sgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZWxlY3RQYWdlKHBhZ2UpIHtcbiAqIFx0dGhpcy5nZXRQYWdlKHBhZ2UpLnRoZW4oKGRhdGE6IEFycmF5PEFycmF5PGFueT4+KSA9PiB7XG4gKiBcdFx0Ly8gc2V0IHRoZSBkYXRhIGFuZCB1cGRhdGUgcGFnZVxuICogXHRcdHRoaXMubW9kZWwuZGF0YSA9IHRoaXMucHJlcGFyZURhdGEoZGF0YSk7XG4gKiBcdFx0dGhpcy5tb2RlbC5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gKiBcdH0pO1xuICogfVxuICpcbiAqIHByb3RlY3RlZCBwcmVwYXJlRGF0YShkYXRhOiBBcnJheTxBcnJheTxhbnk+Pikge1xuICogXHQvLyBjcmVhdGUgbmV3IGRhdGEgZnJvbSB0aGUgc2VydmljZSBkYXRhXG4gKiBcdGxldCBuZXdEYXRhID0gW107XG4gKiBcdGRhdGEuZm9yRWFjaChkYXRhUm93ID0+IHtcbiAqIFx0XHRsZXQgcm93ID0gW107XG4gKiBcdFx0ZGF0YVJvdy5mb3JFYWNoKGRhdGFFbGVtZW50ID0+IHtcbiAqIFx0XHRcdHJvdy5wdXNoKG5ldyBUYWJsZUl0ZW0oe1xuICogXHRcdFx0XHRkYXRhOiBkYXRhRWxlbWVudCxcbiAqIFx0XHRcdFx0dGVtcGxhdGU6IHR5cGVvZiBkYXRhRWxlbWVudCA9PT0gXCJzdHJpbmdcIiA/IHVuZGVmaW5lZCA6IHRoaXMucGFnaW5hdGlvblRhYmxlSXRlbVRlbXBsYXRlXG4gKiBcdFx0XHRcdC8vIHlvdXIgdGVtcGxhdGUgY2FuIGhhbmRsZSBhbGwgdGhlIGRhdGEgdHlwZXMgc28geW91IGRvbid0IGhhdmUgdG8gY29uZGl0aW9uYWxseSBzZXQgaXRcbiAqIFx0XHRcdFx0Ly8geW91IGNhbiBhbHNvIHNldCBkaWZmZXJlbnQgdGVtcGxhdGVzIGZvciBkaWZmZXJlbnQgY29sdW1ucyBiYXNlZCBvbiBpbmRleFxuICogXHRcdFx0fSkpO1xuICogXHRcdH0pO1xuICogXHRcdG5ld0RhdGEucHVzaChyb3cpO1xuICogXHR9KTtcbiAqIFx0cmV0dXJuIG5ld0RhdGE7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9Y29tcG9uZW50cy10YWJsZS0tYmFzaWM8L2V4YW1wbGUtdXJsPlxuICovXG5leHBvcnQgZGVjbGFyZSBjbGFzcyBUYWJsZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7XG4gICAgcHJvdGVjdGVkIGFwcGxpY2F0aW9uUmVmOiBBcHBsaWNhdGlvblJlZjtcbiAgICBwcm90ZWN0ZWQgaTE4bjogSTE4bjtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2tlbGV0b24gbW9kZWwgd2l0aCBhIHJvdyBhbmQgY29sdW1uIGNvdW50IHNwZWNpZmllZCBieSB0aGUgdXNlclxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm1vZGVsID0gVGFibGUuc2tlbGV0b25Nb2RlbCg1LCA1KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgc2tlbGV0b25Nb2RlbChyb3dDb3VudDogbnVtYmVyLCBjb2x1bW5Db3VudDogbnVtYmVyKTogVGFibGVNb2RlbDtcbiAgICBzdGF0aWMgc2V0VGFiSW5kZXgoZWxlbWVudDogSFRNTEVsZW1lbnQsIGluZGV4OiAtMSB8IDApOiB2b2lkO1xuICAgIHN0YXRpYyBmb2N1cyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogYFRhYmxlTW9kZWxgIHdpdGggZGF0YSB0aGUgdGFibGUgaXMgdG8gZGlzcGxheS5cbiAgICAgKi9cbiAgICBtb2RlbDogVGFibGVNb2RlbDtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSB0YWJsZSByb3dzLlxuICAgICAqL1xuICAgIHNpemU6IFRhYmxlUm93U2l6ZTtcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgdGFibGUuXG4gICAgICovXG4gICAgc2tlbGV0b246IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkYXRhIGdyaWQgd2l0aCBrZXlib2FyZCBpbnRlcmFjdGlvbnMuXG4gICAgICovXG4gICAgaXNEYXRhR3JpZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXR0aW5nIHNvcnRhYmxlIHRvIGZhbHNlIHdpbGwgZGlzYWJsZSBhbGwgaGVhZGVycyBpbmNsdWRpbmcgaGVhZGVycyB3aGljaCBhcmUgc29ydGFibGUuIElzIGlzXG4gICAgICogcG9zc2libGUgdG8gc2V0IHRoZSBzb3J0YWJsZSBzdGF0ZSBvbiB0aGUgaGVhZGVyIGl0ZW0gdG8gZGlzYWJsZS9lbmFibGUgc29ydGluZyBmb3Igb25seSBzb21lIGhlYWRlcnMuXG4gICAgICovXG4gICAgc29ydGFibGU6IGJvb2xlYW47XG4gICAgbm9Cb3JkZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hldGhlciB0byBzaG93IHRoZSBzZWxlY3Rpb24gY2hlY2tib3hlcyBjb2x1bW4gb3Igbm90LlxuICAgICAqL1xuICAgIHNob3dTZWxlY3Rpb25Db2x1bW46IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hldGhlciB0byBlbmFibGUgbXVsdGlwbGUgb3Igc2luZ2xlIHJvdyBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgZW5hYmxlU2luZ2xlU2VsZWN0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERpc3RhbmNlIChpbiBweCkgZnJvbSB0aGUgYm90dG9tIHRoYXQgdmlldyBoYXMgdG8gcmVhY2ggYmVmb3JlXG4gICAgICogYHNjcm9sbExvYWRgIGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICovXG4gICAgc2Nyb2xsTG9hZERpc3RhbmNlOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCB0byBlbmFibGUgdXNlcnMgdG8gcmVzaXplIGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBXb3JrcyBmb3IgY29sdW1ucyB3aXRoIHdpZHRoIHNldCBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb2x1bW5zUmVzaXphYmxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gZW5hYmxlIHVzZXJzIHRvIGRyYWcgYW5kIGRyb3AgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIENoYW5naW5nIHRoZSBjb2x1bW4gb3JkZXIgaW4gdGFibGUgY2hhbmdlcyB0YWJsZSBtb2RlbC4gQmUgYXdhcmUgb2YgaXQgd2hlbiB5b3UgYWRkIGFkZGl0aW9uYWwgZGF0YVxuICAgICAqIHRvIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbHVtbnNEcmFnZ2FibGU6IGJvb2xlYW47XG4gICAgZXhwYW5kQnV0dG9uQXJpYUxhYmVsOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgc29ydERlc2NlbmRpbmdMYWJlbDogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICAgIHNvcnRBc2NlbmRpbmdMYWJlbDogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICAgIC8qKlxuICAgICAqIEV4cGVjdHMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgc29tZSBvciBhbGwgb2Y6XG4gICAgICogYGBgXG4gICAgICoge1xuICAgICAqXHRcdFwiRklMVEVSXCI6IFwiRmlsdGVyXCIsXG4gICAgICpcdFx0XCJFTkRfT0ZfREFUQVwiOiBcIllvdSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgeW91ciBjb250ZW50XCIsXG4gICAgICpcdFx0XCJTQ1JPTExfVE9QXCI6IFwiU2Nyb2xsIHRvIHRvcFwiLFxuICAgICAqXHRcdFwiQ0hFQ0tCT1hfSEVBREVSXCI6IFwiU2VsZWN0IGFsbCByb3dzXCIsXG4gICAgICpcdFx0XCJDSEVDS0JPWF9ST1dcIjogXCJTZWxlY3Qgcm93XCJcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgdHJhbnNsYXRpb25zOiBhbnk7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGBmYWxzZWAgdG8gcmVtb3ZlIHRhYmxlIHJvd3MgKHplYnJhKSBzdHJpcGVzLlxuICAgICAqL1xuICAgIHN0cmlwZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0IHRvIGB0cnVlYCB0byBzdGljayB0aGUgaGVhZGVyIHRvIHRoZSB0b3Agb2YgdGhlIHRhYmxlXG4gICAgICovXG4gICAgc3RpY2t5SGVhZGVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNldCBmb290ZXIgdGVtcGxhdGUgdG8gY3VzdG9taXplIHdoYXQgaXMgZGlzcGxheWVkIGluIHRoZSB0Zm9vdCBzZWN0aW9uIG9mIHRoZSB0YWJsZVxuICAgICAqL1xuICAgIGZvb3RlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcG9wdWxhdGUgdGhlIHJvdyBzZWxlY3Rpb24gY2hlY2tib3ggbGFiZWwgd2l0aCBhIHVzZWZ1bCB2YWx1ZSBpZiBzZXQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYFxuICAgICAqIDxpYm0tdGFibGUgW3NlbGVjdGlvbkxhYmVsQ29sdW1uXT1cIjBcIj48L2libS10YWJsZT5cbiAgICAgKiA8IS0tIHJlc3VsdHMgaW4gYXJpYS1sYWJlbD1cIlNlbGVjdCBmaXJzdCBjb2x1bW4gdmFsdWVcIlxuICAgICAqICh3aGVyZSBcImZpcnN0IGNvbHVtbiB2YWx1ZVwiIGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY29sdW1uIGluIHRoZSByb3cgLS0+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2VsZWN0aW9uTGFiZWxDb2x1bW46IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2FudHMgdG8gYmUgc29ydGVkLlxuICAgICAqXG4gICAgICogSWYgbm8gb2JzZXJ2ZXJzIGFyZSBwcm92aWRlZCAoZGVmYXVsdCksIHRhYmxlIHdpbGwgYXR0ZW1wdCB0byBkbyBhIHNpbXBsZSBzb3J0IG9mIHRoZSBkYXRhIGxvYWRlZFxuICAgICAqIGludG8gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JzZXJ2ZXIgaXMgcHJvdmlkZWQsIHRhYmxlIHdpbGwgbm90IGF0dGVtcHQgYW55IHNvcnRpbmcgb2YgaXRzIG93biBhbmQgaXQgaXMgdXAgdG8gdGhlIG9ic2VydmVyXG4gICAgICogdG8gc29ydCB0aGUgdGFibGUuIFRoaXMgaXMgd2hhdCB5b3UgdHlwaWNhbGx5IHdhbnQgaWYgeW91J3JlIHVzaW5nIGEgYmFja2VuZCBxdWVyeSB0byBnZXQgdGhlIHNvcnRlZFxuICAgICAqIGRhdGEgb3Igd2FudCB0byBzb3J0IGRhdGEgYWNyb3NzIG11bHRpcGxlIHBhZ2VzLlxuICAgICAqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogXHRzZWxlY3RvcjogXCJhcHAtdGFibGVcIixcbiAgICAgKiBcdHRlbXBsYXRlOiBgXG4gICAgICogXHRcdDxpYm0tdGFibGVcbiAgICAgKiBcdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuICAgICAqIFx0XHRcdChzb3J0KT1cInNpbXBsZVNvcnQoJGV2ZW50KVwiPlxuICAgICAqIFx0XHRcdE5vIGRhdGEuXG4gICAgICogXHRcdDwvaWJtLXRhYmxlPlxuICAgICAqIFx0YFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFRhYmxlQXBwIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuICAgICAqIFx0QElucHV0KCkgbW9kZWwgPSBuZXcgVGFibGVNb2RlbCgpO1xuICAgICAqXG4gICAgICogXHRuZ09uSW5pdCgpIHtcbiAgICAgKiBcdFx0dGhpcy5tb2RlbC5oZWFkZXIgPSBbXG4gICAgICogXHRcdFx0bmV3IFRhYmxlSGVhZGVySXRlbSh7IGRhdGE6IFwiTmFtZVwiIH0pLFxuICAgICAqIFx0XHRcdG5ldyBUYWJsZUhlYWRlckl0ZW0oeyBkYXRhOiBcImh3ZXJcIiB9KVxuICAgICAqIFx0XHRdO1xuICAgICAqXG4gICAgICogXHRcdHRoaXMubW9kZWwuZGF0YSA9IFtcbiAgICAgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSAxXCIgfSksIG5ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcInF3ZXJcIiB9KV0sXG4gICAgICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgM1wiIH0pLCBuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJ6d2VyXCIgfSldLFxuICAgICAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDJcIiB9KSwgbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwic3dlclwiIH0pXSxcbiAgICAgKiBcdFx0XHRbbmV3IFRhYmxlSXRlbSh7IGRhdGE6IFwiTmFtZSA0XCIgfSksIG5ldyBUYWJsZUl0ZW0oe2RhdGE6IFwidHdlclwifSldLFxuICAgICAqIFx0XHRcdFtuZXcgVGFibGVJdGVtKHsgZGF0YTogXCJOYW1lIDVcIiB9KSwgbmV3IFRhYmxlSXRlbSh7ZGF0YTogXCJ0d2VyXCJ9KV0sXG4gICAgICogXHRcdFx0W25ldyBUYWJsZUl0ZW0oeyBkYXRhOiBcIk5hbWUgNlwiIH0pLCBuZXcgVGFibGVJdGVtKHtkYXRhOiBcInR3ZXJcIn0pXVxuICAgICAqIFx0XHRdO1xuICAgICAqIFx0fVxuICAgICAqXG4gICAgICogXHRzaW1wbGVTb3J0KGluZGV4OiBudW1iZXIpIHtcbiAgICAgKiBcdFx0Ly8gdGhpcyBmdW5jdGlvbiBkb2VzIGEgc2ltcGxlIHNvcnQsIHdoaWNoIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdGFibGUgYW5kIGlmIHRoYXQnc1xuICAgICAqIFx0XHQvLyBhbGwgeW91IHdhbnQsIHlvdSBkb24ndCBuZWVkIHRvIGRvIHRoaXMuXG4gICAgICpcbiAgICAgKiBcdFx0Ly8gaGVyZSB5b3UgY2FuIHF1ZXJ5IHlvdXIgYmFja2VuZCBhbmQgdXBkYXRlIHRoZSBtb2RlbC5kYXRhIGJhc2VkIG9uIHRoZSByZXN1bHRcbiAgICAgKiBcdFx0aWYgKHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5zb3J0ZWQpIHtcbiAgICAgKiBcdFx0XHQvLyBpZiBhbHJlYWR5IHNvcnRlZCBmbGlwIHNvcnRpbmcgZGlyZWN0aW9uXG4gICAgICogXHRcdFx0dGhpcy5tb2RlbC5oZWFkZXJbaW5kZXhdLmFzY2VuZGluZyA9IHRoaXMubW9kZWwuaGVhZGVyW2luZGV4XS5kZXNjZW5kaW5nO1xuICAgICAqIFx0XHR9XG4gICAgICogXHRcdHRoaXMubW9kZWwuc29ydChpbmRleCk7XG4gICAgICogXHR9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNvcnQ6IEV2ZW50RW1pdHRlcjxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGlmIGFsbCByb3dzIGFyZSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2RlbFxuICAgICAqL1xuICAgIHNlbGVjdEFsbDogRXZlbnRFbWl0dGVyPE9iamVjdD47XG4gICAgLyoqXG4gICAgICogRW1pdHMgaWYgYWxsIHJvd3MgYXJlIGRlc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWxcbiAgICAgKi9cbiAgICBkZXNlbGVjdEFsbDogRXZlbnRFbWl0dGVyPE9iamVjdD47XG4gICAgLyoqXG4gICAgICogRW1pdHMgaWYgYSBzaW5nbGUgcm93IGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICh7bW9kZWw6IHRoaXMubW9kZWwsIHNlbGVjdGVkUm93SW5kZXg6IGluZGV4fSlcbiAgICAgKi9cbiAgICBzZWxlY3RSb3c6IEV2ZW50RW1pdHRlcjxPYmplY3Q+O1xuICAgIC8qKlxuICAgICAqIEVtaXRzIGlmIGEgc2luZ2xlIHJvdyBpcyBkZXNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtICh7bW9kZWw6IHRoaXMubW9kZWwsIGRlc2VsZWN0ZWRSb3dJbmRleDogaW5kZXh9KVxuICAgICAqL1xuICAgIGRlc2VsZWN0Um93OiBFdmVudEVtaXR0ZXI8T2JqZWN0PjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBpZiBhIHJvdyBpdGVtIGV4Y2x1ZGluZyBleHBhbmRCdXR0b25zLCBjaGVja2JveGVzLCBvciByYWRpb3MgaXMgY2xpY2tlZC5cbiAgICAgKi9cbiAgICByb3dDbGljazogRXZlbnRFbWl0dGVyPG51bWJlcj47XG4gICAgLyoqXG4gICAgICogRW1pdHMgd2hlbiB0YWJsZSByZXF1aXJlcyBtb3JlIGRhdGEgdG8gYmUgbG9hZGVkLlxuICAgICAqL1xuICAgIHNjcm9sbExvYWQ6IEV2ZW50RW1pdHRlcjxUYWJsZU1vZGVsPjtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyBpZiBhbGwgY2hlY2tib3hlcyBhcmUgdmlld2VkIGFzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHNlbGVjdEFsbENoZWNrYm94OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHRoZSBpbmRldGVybWluYXRlIHN0YXRlIG9mIHRoZSBoZWFkZXIgY2hlY2tib3guXG4gICAgICovXG4gICAgc2VsZWN0QWxsQ2hlY2tib3hTb21lU2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgbm9EYXRhOiBib29sZWFuO1xuICAgIGlzQ29sdW1uRHJhZ2dpbmc6IGJvb2xlYW47XG4gICAgY29sdW1uRHJhZ2dlZEhvdmVySW5kZXg6IG51bWJlcjtcbiAgICBjb2x1bW5EcmFnZ2VkUG9zaXRpb246IHN0cmluZztcbiAgICBwcm90ZWN0ZWQgX21vZGVsOiBUYWJsZU1vZGVsO1xuICAgIHByb3RlY3RlZCBfaXNEYXRhR3JpZDogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgaXNWaWV3UmVhZHk6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbjtcbiAgICBwcm90ZWN0ZWQgcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBwcm90ZWN0ZWQgaW50ZXJhY3Rpb25Nb2RlbDogRGF0YUdyaWRJbnRlcmFjdGlvbk1vZGVsO1xuICAgIHByb3RlY3RlZCBpbnRlcmFjdGlvblBvc2l0aW9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJvdGVjdGVkIF9leHBhbmRCdXR0b25BcmlhTGFiZWw6IE92ZXJyaWRhYmxlO1xuICAgIHByb3RlY3RlZCBfc29ydERlc2NlbmRpbmdMYWJlbDogT3ZlcnJpZGFibGU7XG4gICAgcHJvdGVjdGVkIF9zb3J0QXNjZW5kaW5nTGFiZWw6IE92ZXJyaWRhYmxlO1xuICAgIHByb3RlY3RlZCBfY2hlY2tib3hIZWFkZXJMYWJlbDogT3ZlcnJpZGFibGU7XG4gICAgcHJvdGVjdGVkIF9jaGVja2JveFJvd0xhYmVsOiBPdmVycmlkYWJsZTtcbiAgICBwcm90ZWN0ZWQgX2VuZE9mRGF0YVRleHQ6IE92ZXJyaWRhYmxlO1xuICAgIHByb3RlY3RlZCBfc2Nyb2xsVG9wVGV4dDogT3ZlcnJpZGFibGU7XG4gICAgcHJvdGVjdGVkIF9maWx0ZXJUaXRsZTogT3ZlcnJpZGFibGU7XG4gICAgcHJvdGVjdGVkIGNvbHVtblJlc2l6ZVdpZHRoOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIGNvbHVtblJlc2l6ZU1vdXNlWDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBtb3VzZU1vdmVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBwcm90ZWN0ZWQgbW91c2VVcFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgVGFibGUuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgYXBwbGljYXRpb25SZWY6IEFwcGxpY2F0aW9uUmVmLCBpMThuOiBJMThuKTtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIGVuYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk6IHZvaWQ7XG4gICAgZGlzYWJsZURhdGFHcmlkSW50ZXJhY3Rpb25zKCk6IHZvaWQ7XG4gICAgb25TZWxlY3RBbGwoKTogdm9pZDtcbiAgICBvbkRlc2VsZWN0QWxsKCk6IHZvaWQ7XG4gICAgb25TZWxlY3RSb3coZXZlbnQ6IGFueSk6IHZvaWQ7XG4gICAgb25Sb3dDbGljayhpbmRleDogbnVtYmVyKTogdm9pZDtcbiAgICB1cGRhdGVTZWxlY3RBbGxDaGVja2JveCgpOiB2b2lkO1xuICAgIHJlc2V0VGFiSW5kZXgobmV3VGFiSW5kZXg/OiBudW1iZXIpOiB2b2lkO1xuICAgIGNvbHVtblJlc2l6ZVN0YXJ0KGV2ZW50OiBhbnksIGNvbHVtbjogYW55KTogdm9pZDtcbiAgICBjb2x1bW5SZXNpemVQcm9ncmVzcyhldmVudDogYW55LCBjb2x1bW46IGFueSk6IHZvaWQ7XG4gICAgY29sdW1uUmVzaXplRW5kKGV2ZW50OiBhbnksIGNvbHVtbjogYW55KTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBzY3JvbGxzIG9uIHRoZSBgPHRib2R5PmAgZWxlbWVudC5cbiAgICAgKiBFbWl0cyB0aGUgYHNjcm9sbExvYWRgIGV2ZW50LlxuICAgICAqL1xuICAgIG9uU2Nyb2xsKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIGNvbHVtbkRyYWdTdGFydChldmVudDogYW55LCBjb2x1bW5JbmRleDogYW55KTogdm9pZDtcbiAgICBjb2x1bW5EcmFnRW5kKGV2ZW50OiBhbnksIGNvbHVtbkluZGV4OiBhbnkpOiB2b2lkO1xuICAgIGNvbHVtbkRyYWdFbnRlcihldmVudDogYW55LCBwb3NpdGlvbjogYW55LCBjb2x1bW5JbmRleDogYW55KTogdm9pZDtcbiAgICBjb2x1bW5EcmFnTGVhdmUoZXZlbnQ6IGFueSwgcG9zaXRpb246IGFueSwgY29sdW1uSW5kZXg6IGFueSk6IHZvaWQ7XG4gICAgY29sdW1uRHJhZ292ZXIoZXZlbnQ6IGFueSwgcG9zaXRpb246IGFueSwgY29sdW1uSW5kZXg6IGFueSk6IHZvaWQ7XG4gICAgY29sdW1uRHJvcChldmVudDogYW55LCBwb3NpdGlvbjogYW55LCBjb2x1bW5JbmRleDogYW55KTogdm9pZDtcbiAgICBkb1NvcnQoaW5kZXg6IG51bWJlcik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2Nyb2xscyBvbiB0aGUgYDx0Ym9keT5gIGVsZW1lbnQuXG4gICAgICogRW1pdHMgdGhlIGBzY3JvbGxMb2FkYCBldmVudC5cbiAgICAgKi9cbiAgICBzY3JvbGxUb1RvcChldmVudDogYW55KTogdm9pZDtcbiAgICBnZXRTZWxlY3Rpb25MYWJlbFZhbHVlKHJvdzogVGFibGVJdGVtW10pOiB7XG4gICAgICAgIHZhbHVlOiBhbnk7XG4gICAgfTtcbiAgICBnZXRFeHBhbmRCdXR0b25BcmlhTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICAgIGdldFNvcnREZXNjZW5kaW5nTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuICAgIGdldFNvcnRBc2NlbmRpbmdMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgZ2V0Q2hlY2tib3hIZWFkZXJMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgZ2V0Q2hlY2tib3hSb3dMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgZ2V0RW5kT2ZEYXRhVGV4dCgpOiBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgZ2V0U2Nyb2xsVG9wVGV4dCgpOiBPYnNlcnZhYmxlPHN0cmluZz47XG4gICAgZ2V0RmlsdGVyVGl0bGUoKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xufVxuIl19