"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatFiles = void 0;
const tslib_1 = require("tslib");
const workspace_1 = require("@nrwl/tao/src/shared/workspace");
const path = require("path");
const get_workspace_layout_1 = require("../utils/get-workspace-layout");
const json_1 = require("../utils/json");
const object_sort_1 = require("@nrwl/tao/src/utils/object-sort");
/**
 * Formats all the created or updated files using Prettier
 * @param host - the file system tree
 */
function formatFiles(host) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let prettier;
        try {
            prettier = yield Promise.resolve().then(() => require('prettier'));
        }
        catch (_a) { }
        updateWorkspaceJsonToMatchFormatVersion(host);
        sortWorkspaceJson(host);
        sortNxJson(host);
        sortTsConfig(host);
        if (!prettier)
            return;
        const files = new Set(host.listChanges().filter((file) => file.type !== 'DELETE'));
        yield Promise.all(Array.from(files).map((file) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const systemPath = path.join(host.root, file.path);
            let options = {
                filepath: systemPath,
            };
            const resolvedOptions = yield prettier.resolveConfig(systemPath);
            if (!resolvedOptions) {
                return;
            }
            options = Object.assign(Object.assign({}, options), resolvedOptions);
            const support = yield prettier.getFileInfo(systemPath);
            if (support.ignored || !support.inferredParser) {
                return;
            }
            try {
                host.write(file.path, prettier.format(file.content.toString('utf-8'), options));
            }
            catch (e) {
                console.warn(`Could not format ${file.path}. Error: "${e.message}"`);
            }
        })));
    });
}
exports.formatFiles = formatFiles;
function updateWorkspaceJsonToMatchFormatVersion(host) {
    const path = get_workspace_layout_1.getWorkspacePath(host);
    if (!path) {
        return;
    }
    try {
        const workspaceJson = json_1.readJson(host, path);
        const reformatted = workspace_1.reformattedWorkspaceJsonOrNull(workspaceJson);
        if (reformatted) {
            json_1.writeJson(host, path, reformatted);
        }
    }
    catch (e) {
        console.error(`Failed to format: ${path}`);
        console.error(e);
    }
}
function sortWorkspaceJson(host) {
    const workspaceJsonPath = get_workspace_layout_1.getWorkspacePath(host);
    if (!path) {
        return;
    }
    try {
        const workspaceJson = json_1.readJson(host, workspaceJsonPath);
        if (Object.entries(workspaceJson.projects).length !== 0) {
            const sortedProjects = object_sort_1.sortObjectByKeys(workspaceJson.projects);
            json_1.writeJson(host, workspaceJsonPath, Object.assign(Object.assign({}, workspaceJson), { projects: sortedProjects }));
        }
    }
    catch (e) {
        // catch noop
    }
}
function sortNxJson(host) {
    try {
        const nxJson = json_1.readJson(host, 'nx.json');
        const sortedProjects = object_sort_1.sortObjectByKeys(nxJson.projects);
        json_1.writeJson(host, 'nx.json', Object.assign(Object.assign({}, nxJson), { projects: sortedProjects }));
    }
    catch (e) {
        // catch noop
    }
}
function sortTsConfig(host) {
    try {
        const tsconfig = json_1.readJson(host, 'tsconfig.base.json');
        const sortedPaths = object_sort_1.sortObjectByKeys(tsconfig.compilerOptions.paths);
        json_1.writeJson(host, 'tsconfig.base.json', Object.assign(Object.assign({}, tsconfig), { compilerOptions: Object.assign(Object.assign({}, tsconfig.compilerOptions), { paths: sortedPaths }) }));
    }
    catch (e) {
        // catch noop
    }
}
//# sourceMappingURL=format-files.js.map