import { InjectionToken, Injectable, NgZone, Optional, Inject, Pipe, NgModule } from '@angular/core';
import { ApolloClient } from 'apollo-client';
import { Observable, queueScheduler, observable, from } from 'rxjs';
import { observeOn, startWith } from 'rxjs/operators';

function fromPromise(promiseFn) {
    return new Observable(subscriber => {
        promiseFn().then(result => {
            if (!subscriber.closed) {
                subscriber.next(result);
                subscriber.complete();
            }
        }, error => {
            if (!subscriber.closed) {
                subscriber.error(error);
            }
        });
        return () => subscriber.unsubscribe();
    });
}
class ZoneScheduler {
    constructor(zone) {
        this.zone = zone;
        this.now = Date.now ? Date.now : () => +new Date();
    }
    schedule(work, delay = 0, state) {
        return this.zone.run(() => queueScheduler.schedule(work, delay, state));
    }
}
// XXX: Apollo's QueryObservable is not compatible with RxJS
// TODO: remove it in one of future releases
// https://github.com/ReactiveX/rxjs/blob/9fb0ce9e09c865920cf37915cc675e3b3a75050b/src/internal/util/subscribeTo.ts#L32
function fixObservable(obs) {
    obs[observable] = () => obs;
    return obs;
}
function wrapWithZone(obs, ngZone) {
    return obs.pipe(observeOn(new ZoneScheduler(ngZone)));
}

class QueryRef {
    constructor(obsQuery, ngZone, options) {
        this.obsQuery = obsQuery;
        const wrapped = wrapWithZone(from(fixObservable(this.obsQuery)), ngZone);
        this.valueChanges = options.useInitialLoading
            ? wrapped.pipe(startWith(Object.assign(Object.assign({}, this.obsQuery.getCurrentResult()), { error: undefined, partial: undefined, stale: true })))
            : wrapped;
        this.queryId = this.obsQuery.queryId;
    }
    // ObservableQuery's methods
    result() {
        return this.obsQuery.result();
    }
    currentResult() {
        return this.obsQuery.currentResult();
    }
    getLastResult() {
        return this.obsQuery.getLastResult();
    }
    getLastError() {
        return this.obsQuery.getLastError();
    }
    resetLastResults() {
        return this.obsQuery.resetLastResults();
    }
    refetch(variables) {
        return this.obsQuery.refetch(variables);
    }
    fetchMore(fetchMoreOptions) {
        return this.obsQuery.fetchMore(fetchMoreOptions);
    }
    subscribeToMore(options) {
        // XXX: there's a bug in apollo-client typings
        // it should not inherit types from ObservableQuery
        return this.obsQuery.subscribeToMore(options);
    }
    updateQuery(mapFn) {
        return this.obsQuery.updateQuery(mapFn);
    }
    stopPolling() {
        return this.obsQuery.stopPolling();
    }
    startPolling(pollInterval) {
        return this.obsQuery.startPolling(pollInterval);
    }
    setOptions(opts) {
        return this.obsQuery.setOptions(opts);
    }
    setVariables(variables, tryFetch = false, fetchResults = true) {
        return this.obsQuery.setVariables(variables, tryFetch, fetchResults);
    }
}

const APOLLO_OPTIONS = new InjectionToken('[apollo-angular] options');
const APOLLO_NAMED_OPTIONS = new InjectionToken('[apollo-angular] named options');

class ApolloBase {
    constructor(ngZone, _client) {
        this.ngZone = ngZone;
        this._client = _client;
    }
    watchQuery(options) {
        return new QueryRef(this.ensureClient().watchQuery(Object.assign({}, options)), this.ngZone, options);
    }
    query(options) {
        return fromPromise(() => this.ensureClient().query(Object.assign({}, options)));
    }
    mutate(options) {
        return fromPromise(() => this.ensureClient().mutate(Object.assign({}, options)));
    }
    subscribe(options, extra) {
        const obs = from(fixObservable(this.ensureClient().subscribe(Object.assign({}, options))));
        return extra && extra.useZone !== true
            ? obs
            : wrapWithZone(obs, this.ngZone);
    }
    /**
     * Get an access to an instance of ApolloClient
     */
    getClient() {
        return this._client;
    }
    /**
     * Set a new instance of ApolloClient
     * Remember to clean up the store before setting a new client.
     *
     * @param client ApolloClient instance
     */
    setClient(client) {
        if (this._client) {
            throw new Error('Client has been already defined');
        }
        this._client = client;
    }
    ensureClient() {
        this.checkInstance();
        return this._client;
    }
    checkInstance() {
        if (!this._client) {
            throw new Error('Client has not been defined yet');
        }
    }
}
class Apollo extends ApolloBase {
    constructor(_ngZone, apolloOptions, apolloNamedOptions) {
        super(_ngZone);
        this._ngZone = _ngZone;
        this.map = new Map();
        if (apolloOptions) {
            this.createDefault(apolloOptions);
        }
        if (apolloNamedOptions && typeof apolloNamedOptions === 'object') {
            for (const name in apolloNamedOptions) {
                if (apolloNamedOptions.hasOwnProperty(name)) {
                    const options = apolloNamedOptions[name];
                    this.createNamed(name, options);
                }
            }
        }
    }
    /**
     * Create an instance of ApolloClient
     * @param options Options required to create ApolloClient
     * @param name client's name
     */
    create(options, name) {
        if (isDefault(name)) {
            this.createDefault(options);
        }
        else {
            this.createNamed(name, options);
        }
    }
    /**
     * Use a default ApolloClient
     */
    default() {
        return this;
    }
    /**
     * Use a named ApolloClient
     * @param name client's name
     */
    use(name) {
        if (isDefault(name)) {
            return this.default();
        }
        return this.map.get(name);
    }
    /**
     * Create a default ApolloClient, same as `apollo.create(options)`
     * @param options ApolloClient's options
     */
    createDefault(options) {
        if (this.getClient()) {
            throw new Error('Apollo has been already created.');
        }
        return this.setClient(new ApolloClient(options));
    }
    /**
     * Create a named ApolloClient, same as `apollo.create(options, name)`
     * @param name client's name
     * @param options ApolloClient's options
     */
    createNamed(name, options) {
        if (this.map.has(name)) {
            throw new Error(`Client ${name} has been already created`);
        }
        this.map.set(name, new ApolloBase(this._ngZone, new ApolloClient(options)));
    }
    /**
     * Remember to clean up the store before removing a client
     * @param name client's name
     */
    removeClient(name) {
        if (isDefault(name)) {
            this._client = undefined;
        }
        else {
            this.map.delete(name);
        }
    }
}
Apollo.decorators = [
    { type: Injectable }
];
Apollo.ctorParameters = () => [
    { type: NgZone },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_OPTIONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [APOLLO_NAMED_OPTIONS,] }] }
];
function isDefault(name) {
    return !name || name === 'default';
}

class Query {
    constructor(apollo) {
        this.apollo = apollo;
        this.client = 'default';
    }
    watch(variables, options) {
        return this.apollo.use(this.client).watchQuery(Object.assign(Object.assign({}, options), { variables, query: this.document }));
    }
    fetch(variables, options) {
        return this.apollo.use(this.client).query(Object.assign(Object.assign({}, options), { variables, query: this.document }));
    }
}
Query.decorators = [
    { type: Injectable }
];
Query.ctorParameters = () => [
    { type: Apollo }
];

class Mutation {
    constructor(apollo) {
        this.apollo = apollo;
        this.client = 'default';
    }
    mutate(variables, options) {
        return this.apollo.use(this.client).mutate(Object.assign(Object.assign({}, options), { variables, mutation: this.document }));
    }
}
Mutation.decorators = [
    { type: Injectable }
];
Mutation.ctorParameters = () => [
    { type: Apollo }
];

class Subscription {
    constructor(apollo) {
        this.apollo = apollo;
        this.client = 'default';
    }
    subscribe(variables, options, extra) {
        return this.apollo.use(this.client).subscribe(Object.assign(Object.assign({}, options), { variables, query: this.document }), extra);
    }
}
Subscription.decorators = [
    { type: Injectable }
];
Subscription.ctorParameters = () => [
    { type: Apollo }
];

class SelectPipe {
    transform(obj, name = '') {
        if (name !== '') {
            return obj && obj.data && obj.data[name];
        }
    }
}
SelectPipe.decorators = [
    { type: Pipe, args: [{
                name: 'select',
            },] }
];

const PROVIDERS = [Apollo];
const DECLARATIONS = [SelectPipe];
class ApolloModule {
}
ApolloModule.decorators = [
    { type: NgModule, args: [{
                providers: PROVIDERS,
                declarations: DECLARATIONS,
                exports: DECLARATIONS,
            },] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { APOLLO_NAMED_OPTIONS, APOLLO_OPTIONS, Apollo, ApolloBase, ApolloModule, Mutation, Query, QueryRef, SelectPipe, Subscription, PROVIDERS as ɵa, DECLARATIONS as ɵb };
//# sourceMappingURL=ngApollo.js.map
