{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-slider.js\n *\n * Copyright 2014, 2022 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Component, HostBinding, Input, Output, EventEmitter, ViewChild, ElementRef, TemplateRef, ViewChildren, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { EventService, UtilsModule } from 'carbon-components-angular/utils';\n/**\n * Used to select from ranges of values. [See here](https://www.carbondesignsystem.com/components/slider/usage) for usage information.\n *\n * [See demo](../../?path=/story/components-slider--advanced)\n *\n * The simplest possible slider usage looks something like:\n * ```html\n * <ibm-slider></ibm-slider>\n * ```\n *\n * That will render a slider without labels or alternative value input. Labels can be provided by\n * elements with `[minLabel]` and `[maxLabel]` attributes, and an `input` (may use the `ibmInput` directive) can be supplied\n * for use as an alternative value field.\n *\n * ex:\n * ```html\n * <!-- full example -->\n * <ibm-slider>\n *\t\t<span minLabel>0GB</span>\n *\t\t<span maxLabel>100GB</span>\n *\t\t<input/>\n *\t</ibm-slider>\n * <!-- with just an input -->\n * <ibm-slider>\n *\t\t<input/>\n *\t</ibm-slider>\n * <!-- with just one label -->\n * <ibm-slider>\n *\t\t<span maxLabel>Maximum</span>\n *\t</ibm-slider>\n * ```\n *\n * Slider supports `NgModel` by default, as well as two way binding to the `value` input.\n *\n * <example-url>../../iframe.html?id=components-slider--advanced</example-url>\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'carbon-components-angular/utils';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [\"track\"];\nconst _c1 = [\"filledTrack\"];\nconst _c2 = [\"range\"];\nconst _c3 = [\"thumbs\"];\n\nfunction Slider_ng_container_0_label_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r9.label);\n  }\n}\n\nfunction Slider_ng_container_0_label_1_2_ng_template_0_Template(rf, ctx) {}\n\nfunction Slider_ng_container_0_label_1_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Slider_ng_container_0_label_1_2_ng_template_0_Template, 0, 0, \"ng-template\", 14);\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r10.label);\n  }\n}\n\nfunction Slider_ng_container_0_label_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"label\", 13);\n    ɵngcc0.ɵɵtemplate(1, Slider_ng_container_0_label_1_ng_container_1_Template, 2, 1, \"ng-container\", 6);\n    ɵngcc0.ɵɵtemplate(2, Slider_ng_container_0_label_1_2_Template, 1, 1, null, 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"for\", ctx_r3.id)(\"id\", ctx_r3.labelId);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r3.isTemplate(ctx_r3.label));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r3.isTemplate(ctx_r3.label));\n  }\n}\n\nconst _c4 = function (a0) {\n  return {\n    left: a0\n  };\n};\n\nfunction Slider_ng_container_0_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 15, 16);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function Slider_ng_container_0_ng_container_6_Template_div_mousedown_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r14);\n      const ctx_r13 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r13.onMouseDown($event);\n    })(\"keydown\", function Slider_ng_container_0_ng_container_6_Template_div_keydown_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r14);\n      const ctx_r15 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r15.onKeyDown($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r4.id)(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(3, _c4, ctx_r4.getFractionComplete(ctx_r4.value) * 100 + \"%\"));\n    ɵngcc0.ɵɵattribute(\"aria-labelledby\", ctx_r4.labelId);\n  }\n}\n\nfunction Slider_ng_container_0_ng_container_7_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 15, 16);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function Slider_ng_container_0_ng_container_7_div_1_Template_div_mousedown_0_listener($event) {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r21);\n      const i_r18 = restoredCtx.index;\n      const ctx_r20 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r20.onMouseDown($event, i_r18);\n    })(\"keydown\", function Slider_ng_container_0_ng_container_7_div_1_Template_div_keydown_0_listener($event) {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r21);\n      const i_r18 = restoredCtx.index;\n      const ctx_r22 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r22.onKeyDown($event, i_r18);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const thumb_r17 = ctx.$implicit;\n    const i_r18 = ctx.index;\n    const ctx_r16 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r16.id + (i_r18 > 0 ? \"-\" + i_r18 : \"\"))(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(3, _c4, ctx_r16.getFractionComplete(thumb_r17) * 100 + \"%\"));\n    ɵngcc0.ɵɵattribute(\"aria-labelledby\", ctx_r16.labelId);\n  }\n}\n\nfunction Slider_ng_container_0_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, Slider_ng_container_0_ng_container_7_div_1_Template, 2, 5, \"div\", 17);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r5.value)(\"ngForTrackBy\", ctx_r5.trackThumbsBy);\n  }\n}\n\nconst _c5 = function (a0) {\n  return {\n    \"bx--slider--disabled\": a0\n  };\n};\n\nfunction Slider_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r24 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, Slider_ng_container_0_label_1_Template, 3, 4, \"label\", 2);\n    ɵngcc0.ɵɵelementStart(2, \"div\", 3)(3, \"label\", 4);\n    ɵngcc0.ɵɵprojection(4);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(5, \"div\", 5);\n    ɵngcc0.ɵɵtemplate(6, Slider_ng_container_0_ng_container_6_Template, 3, 5, \"ng-container\", 6);\n    ɵngcc0.ɵɵtemplate(7, Slider_ng_container_0_ng_container_7_Template, 2, 2, \"ng-container\", 6);\n    ɵngcc0.ɵɵelementStart(8, \"div\", 7, 8);\n    ɵngcc0.ɵɵlistener(\"click\", function Slider_ng_container_0_Template_div_click_8_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r24);\n      const ctx_r23 = ɵngcc0.ɵɵnextContext();\n      return ctx_r23.onClick($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(10, \"div\", 9, 10)(12, \"input\", 11, 12);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(14, \"label\", 4);\n    ɵngcc0.ɵɵprojection(15, 1);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵprojection(16, 2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.label);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r0.bottomRangeId);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(10, _c5, ctx_r0.disabled));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.isRange());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.isRange());\n    ɵngcc0.ɵɵadvance(5);\n    ɵngcc0.ɵɵproperty(\"step\", ctx_r0.step)(\"min\", ctx_r0.min)(\"max\", ctx_r0.max)(\"value\", ctx_r0.value.toString());\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r0.topRangeId);\n  }\n}\n\nfunction Slider_ng_template_1_label_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"label\", 24);\n  }\n}\n\nfunction Slider_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, Slider_ng_template_1_label_0_Template, 1, 0, \"label\", 18);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 19);\n    ɵngcc0.ɵɵelement(2, \"span\", 20);\n    ɵngcc0.ɵɵelementStart(3, \"div\", 21);\n    ɵngcc0.ɵɵelement(4, \"div\", 22)(5, \"div\", 23)(6, \"div\", 9);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelement(7, \"span\", 20);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.label);\n  }\n}\n\nconst _c6 = [[[\"\", \"minLabel\", \"\"]], [[\"\", \"maxLabel\", \"\"]], [[\"input\"]]];\nconst _c7 = [\"[minLabel]\", \"[maxLabel]\", \"input\"];\nlet Slider = /*#__PURE__*/(() => {\n  class Slider {\n    constructor(elementRef, eventService) {\n      this.elementRef = elementRef;\n      this.eventService = eventService;\n      /** The interval for our range */\n\n      this.step = 1;\n      /** Base ID for the slider. The min and max labels get IDs `${this.id}-bottom-range` and `${this.id}-top-range` respectively */\n\n      this.id = `slider-${Slider.count++}`;\n      /** Value used to \"multiply\" the `step` when using arrow keys to select values */\n\n      this.shiftMultiplier = 4;\n      /** Set to `true` for a loading slider */\n\n      this.skeleton = false;\n      /** Set to `true` for a slider without arrow key interactions. */\n\n      this.disableArrowKeys = false;\n      /** Emits every time a new value is selected */\n\n      this.valueChange = new EventEmitter();\n      this.hostClass = true;\n      this.labelId = `${this.id}-label`;\n      this.bottomRangeId = `${this.id}-bottom-range`;\n      this.topRangeId = `${this.id}-top-range`;\n      this.fractionComplete = 0;\n      this.isMouseDown = false;\n      this._min = 0;\n      this._max = 100;\n      this._value = [this.min];\n      this._previousValue = [this.min];\n      this._disabled = false;\n      this._focusedThumbIndex = 0;\n      /** Send changes back to the model */\n\n      this.propagateChange = _ => {};\n      /** Callback to notify the model when our input has been touched */\n\n\n      this.onTouched = () => {};\n    }\n    /** The lower bound of our range */\n\n\n    set min(v) {\n      if (!v) {\n        return;\n      }\n\n      this._min = v; // force the component to update\n\n      this.value = this.value;\n    }\n\n    get min() {\n      return this._min;\n    }\n    /** The upper bound of our range */\n\n\n    set max(v) {\n      if (!v) {\n        return;\n      }\n\n      this._max = v; // force the component to update\n\n      this.value = this.value;\n    }\n\n    get max() {\n      return this._max;\n    }\n    /** Set the initial value. Available for two way binding */\n\n\n    set value(v) {\n      if (!v) {\n        v = [this.min];\n      }\n\n      if (typeof v === \"number\" || typeof v === \"string\") {\n        v = [Number(v)];\n      }\n\n      if (v[0] < this.min) {\n        v[0] = this.min;\n      }\n\n      if (v[0] > this.max) {\n        v[0] = this.max;\n      }\n\n      if (this.isRange()) {\n        if (this._previousValue[0] !== v[0]) {\n          // left moved\n          if (v[0] > v[1] - this.step) {\n            // stop the left handle if surpassing the right one\n            v[0] = v[1] - this.step;\n          } else if (v[0] > this.max) {\n            v[0] = this.max;\n          } else if (v[0] < this.min) {\n            v[0] = this.min;\n          }\n        }\n\n        if (this._previousValue[1] !== v[1]) {\n          // right moved\n          if (v[1] > this.max) {\n            v[1] = this.max;\n          } else if (v[1] < this._value[0] + this.step) {\n            // stop the right handle if surpassing the left one\n            v[1] = this._value[0] + this.step;\n          } else if (v[1] < this.min) {\n            v[1] = this.min;\n          }\n        }\n      }\n\n      this._previousValue = [...this._value]; // store a copy, enable detection which handle moved\n\n      this._value = [...v]; // triggers change detection when ngModel value is an array (for range)\n\n      if (this.isRange() && this.filledTrack) {\n        this.updateTrackRangeWidth();\n      } else if (this.filledTrack) {\n        this.filledTrack.nativeElement.style.transform = `translate(0%, -50%) ${this.scaleX(this.getFractionComplete(v[0]))}`;\n      }\n\n      if (this.inputs && this.inputs.length) {\n        this.inputs.forEach((input, index) => {\n          input.value = this._value[index].toString();\n        });\n      }\n\n      const valueToEmit = this.isRange() ? v : v[0];\n      this.propagateChange(valueToEmit);\n      this.valueChange.emit(valueToEmit);\n    }\n\n    get value() {\n      if (this.isRange()) {\n        return this._value;\n      }\n\n      return this._value[0];\n    }\n    /** Disables the range visually and functionally */\n\n\n    set disabled(v) {\n      this._disabled = v; // for some reason `this.input` never exists here, so we have to query for it here too\n\n      const inputs = this.getInputs();\n\n      if (inputs && inputs.length > 0) {\n        inputs.forEach(input => input.disabled = v);\n      }\n    }\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    ngAfterViewInit() {\n      // bind mousemove and mouseup to the document so we don't have issues tracking the mouse\n      this.eventService.onDocument(\"mousemove\", this.onMouseMove.bind(this));\n      this.eventService.onDocument(\"mouseup\", this.onMouseUp.bind(this)); // apply any values we got from before the view initialized\n\n      this.value = this.value; // TODO: ontouchstart/ontouchmove/ontouchend\n      // set up the optional input\n\n      this.inputs = this.getInputs();\n\n      if (this.inputs && this.inputs.length > 0) {\n        this.inputs.forEach((input, index) => {\n          input.type = \"number\";\n          input.classList.add(\"bx--slider-text-input\");\n          input.classList.add(\"bx--text-input\");\n          input.setAttribute(\"aria-labelledby\", `${this.bottomRangeId} ${this.topRangeId}`);\n          input.value = index < this._value.length ? this._value[index].toString() : this.max.toString(); // bind events on our optional input\n\n          this.eventService.on(input, \"change\", event => this.onChange(event, index));\n\n          if (index === 0) {\n            this.eventService.on(input, \"focus\", this.onFocus.bind(this));\n          }\n        });\n      }\n    }\n\n    trackThumbsBy(index, item) {\n      return index;\n    }\n    /** Register a change propagation function for `ControlValueAccessor` */\n\n\n    registerOnChange(fn) {\n      this.propagateChange = fn;\n    }\n    /** Register a callback to notify when our input has been touched */\n\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /** Receives a value from the model */\n\n\n    writeValue(v) {\n      this.value = v;\n    }\n    /**\n     * Returns the amount of \"completeness\" of a value as a fraction of the total track width\n     */\n\n\n    getFractionComplete(value) {\n      if (!this.track) {\n        return 0;\n      }\n\n      const trackWidth = this.track.nativeElement.getBoundingClientRect().width;\n      return this.convertToPx(value) / trackWidth;\n    }\n    /** Helper function to return the CSS transform `scaleX` function */\n\n\n    scaleX(complete) {\n      return `scaleX(${complete})`;\n    }\n    /** Converts a given px value to a \"real\" value in our range */\n\n\n    convertToValue(pxAmount) {\n      // basic concept borrowed from carbon-components\n      // ref: https://github.com/IBM/carbon-components/blob/43bf3abdc2f8bdaa38aa84e0f733adde1e1e8894/src/components/slider/slider.js#L147-L151\n      const range = this.max - this.min;\n      const trackWidth = this.track.nativeElement.getBoundingClientRect().width;\n      const unrounded = pxAmount / trackWidth;\n      const rounded = Math.round(range * unrounded / this.step) * this.step;\n      return rounded + this.min;\n    }\n    /** Converts a given \"real\" value to a px value we can update the view with */\n\n\n    convertToPx(value) {\n      if (!this.track) {\n        return 0;\n      }\n\n      const trackWidth = this.track.nativeElement.getBoundingClientRect().width;\n\n      if (value >= this.max) {\n        return trackWidth;\n      }\n\n      if (value <= this.min) {\n        return 0;\n      } // account for value shifting by subtracting min from value and max\n\n\n      return Math.round(trackWidth * ((value - this.min) / (this.max - this.min)));\n    }\n    /**\n     * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.\n     *\n     * @argument multiplier Defaults to `1`, multiplied with the step value.\n     */\n\n\n    incrementValue(multiplier = 1, index = 0) {\n      this._value[index] = this._value[index] + this.step * multiplier;\n      this.value = this.value; // run the setter\n    }\n    /**\n     * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.\n     *\n     * @argument multiplier Defaults to `1`, multiplied with the step value.\n     */\n\n\n    decrementValue(multiplier = 1, index = 0) {\n      this._value[index] = this._value[index] - this.step * multiplier;\n      this.value = this.value; // run the setter\n    }\n    /**\n     * Determines if the slider is in range mode.\n     */\n\n\n    isRange() {\n      return this._value.length > 1;\n    }\n    /**\n     * Range mode only.\n     * Updates the track width to span from the low thumb to the high thumb\n     */\n\n\n    updateTrackRangeWidth() {\n      const fraction = this.getFractionComplete(this._value[0]);\n      const fraction2 = this.getFractionComplete(this._value[1]);\n      this.filledTrack.nativeElement.style.transform = `translate(${fraction * 100}%, -50%) ${this.scaleX(fraction2 - fraction)}`;\n    }\n    /** Change handler for the optional input */\n\n\n    onChange(event, index) {\n      this._value[index] = Number(event.target.value);\n      this.value = this.value;\n    }\n    /** Handles clicks on the range track, and setting the value to it's \"real\" equivalent */\n\n\n    onClick(event) {\n      if (this.disabled) {\n        return;\n      }\n\n      const trackLeft = this.track.nativeElement.getBoundingClientRect().left;\n      this._value[0] = this.convertToValue(event.clientX - trackLeft);\n      this.value = this.value;\n    }\n    /** Focus handler for the optional input */\n\n\n    onFocus({\n      target\n    }) {\n      target.select();\n    }\n    /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */\n\n\n    onMouseMove(event) {\n      if (this.disabled || !this.isMouseDown) {\n        return;\n      }\n\n      const track = this.track.nativeElement.getBoundingClientRect();\n      let value;\n\n      if (event.clientX - track.left <= track.width && event.clientX - track.left >= 0) {\n        value = this.convertToValue(event.clientX - track.left);\n      } // if the mouse is beyond the max, set the value to `max`\n\n\n      if (event.clientX - track.left > track.width) {\n        value = this.max;\n      } // if the mouse is below the min, set the value to `min`\n\n\n      if (event.clientX - track.left < 0) {\n        value = this.min;\n      }\n\n      if (value !== undefined) {\n        this._value[this._focusedThumbIndex] = value;\n        this.value = this.value;\n      }\n    }\n    /**\n     * Enables the `onMouseMove` handler\n     *\n     * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.\n     */\n\n\n    onMouseDown(event, index = 0) {\n      event.preventDefault();\n\n      if (this.disabled) {\n        return;\n      }\n\n      this._focusedThumbIndex = index;\n      this.thumbs.toArray()[index].nativeElement.focus();\n      this.isMouseDown = true;\n    }\n    /** Disables the `onMouseMove` handler */\n\n\n    onMouseUp() {\n      this.isMouseDown = false;\n    }\n    /**\n     * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.\n     *\n     * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.\n     */\n\n\n    onKeyDown(event, index = 0) {\n      if (this.disableArrowKeys) {\n        return;\n      }\n\n      const multiplier = event.shiftKey ? this.shiftMultiplier : 1;\n\n      if (event.key === \"ArrowLeft\" || event.key === \"ArrowDown\") {\n        this.decrementValue(multiplier, index);\n        this.thumbs.toArray()[index].nativeElement.focus();\n        event.preventDefault();\n      } else if (event.key === \"ArrowRight\" || event.key === \"ArrowUp\") {\n        this.incrementValue(multiplier, index);\n        this.thumbs.toArray()[index].nativeElement.focus();\n        event.preventDefault();\n      }\n    }\n\n    isTemplate(value) {\n      return value instanceof TemplateRef;\n    }\n    /** Get optional input fields */\n\n\n    getInputs() {\n      return this.elementRef.nativeElement.querySelectorAll(\"input:not([type=range])\");\n    }\n\n  }\n\n  Slider.ɵfac = function Slider_Factory(t) {\n    return new (t || Slider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.EventService));\n  };\n\n  Slider.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Slider,\n    selectors: [[\"ibm-slider\"]],\n    viewQuery: function Slider_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n        ɵngcc0.ɵɵviewQuery(_c3, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.filledTrack = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.range = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbs = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function Slider_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--form-item\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      step: \"step\",\n      id: \"id\",\n      shiftMultiplier: \"shiftMultiplier\",\n      skeleton: \"skeleton\",\n      disableArrowKeys: \"disableArrowKeys\",\n      min: \"min\",\n      value: \"value\",\n      max: \"max\",\n      disabled: \"disabled\",\n      label: \"label\"\n    },\n    outputs: {\n      valueChange: \"valueChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: Slider,\n      multi: true\n    }])],\n    ngContentSelectors: _c7,\n    decls: 3,\n    vars: 2,\n    consts: [[4, \"ngIf\", \"ngIfElse\"], [\"skeletonTemplate\", \"\"], [\"class\", \"bx--label\", 3, \"for\", \"id\", 4, \"ngIf\"], [1, \"bx--slider-container\"], [1, \"bx--slider__range-label\", 3, \"id\"], [1, \"bx--slider\", 3, \"ngClass\"], [4, \"ngIf\"], [1, \"bx--slider__track\", 3, \"click\"], [\"track\", \"\"], [1, \"bx--slider__filled-track\"], [\"filledTrack\", \"\"], [\"aria-label\", \"slider\", \"type\", \"range\", 1, \"bx--slider__input\", 3, \"step\", \"min\", \"max\", \"value\"], [\"range\", \"\"], [1, \"bx--label\", 3, \"for\", \"id\"], [3, \"ngTemplateOutlet\"], [\"role\", \"slider\", \"tabindex\", \"0\", 1, \"bx--slider__thumb\", 3, \"id\", \"ngStyle\", \"mousedown\", \"keydown\"], [\"thumbs\", \"\"], [\"role\", \"slider\", \"class\", \"bx--slider__thumb\", \"tabindex\", \"0\", 3, \"id\", \"ngStyle\", \"mousedown\", \"keydown\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"class\", \"bx--label bx--skeleton\", 4, \"ngIf\"], [1, \"bx--slider-container\", \"bx--skeleton\"], [1, \"bx--slider__range-label\"], [1, \"bx--slider\"], [1, \"bx--slider__thumb\"], [1, \"bx--slider__track\"], [1, \"bx--label\", \"bx--skeleton\"]],\n    template: function Slider_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c6);\n        ɵngcc0.ɵɵtemplate(0, Slider_ng_container_0_Template, 17, 12, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(1, Slider_ng_template_1_Template, 8, 1, \"ng-template\", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n\n      if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(2);\n\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton)(\"ngIfElse\", _r1);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgClass, ɵngcc2.NgStyle, ɵngcc2.NgForOf],\n    encapsulation: 2\n  });\n  /** Used to generate unique IDs */\n\n  Slider.count = 0;\n  /** @nocollapse */\n\n  return Slider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet SliderModule = /*#__PURE__*/(() => {\n  class SliderModule {}\n\n  SliderModule.ɵfac = function SliderModule_Factory(t) {\n    return new (t || SliderModule)();\n  };\n\n  SliderModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SliderModule\n  });\n  SliderModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, UtilsModule]]\n  });\n  return SliderModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SliderModule, {\n    declarations: function () {\n      return [Slider];\n    },\n    imports: function () {\n      return [CommonModule, UtilsModule];\n    },\n    exports: function () {\n      return [Slider];\n    }\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Slider, SliderModule }; //# sourceMappingURL=carbon-components-angular-slider.js.map","map":null,"metadata":{},"sourceType":"module"}