{"ast":null,"code":"/**\n *\n * carbon-angular v0.0.0 | carbon-components-angular-table.js\n *\n * Copyright 2014, 2022 IBM\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Subject, BehaviorSubject, combineLatest, Subscription, fromEvent } from 'rxjs';\nimport { tabbableSelectorIgnoreTabIndex, getFocusElementList } from 'carbon-components-angular/common';\nimport { merge, getScrollbarWidth } from 'carbon-components-angular/utils';\nimport { map } from 'rxjs/operators';\nimport { EventEmitter, Component, Input, Output, HostBinding, Directive, HostListener, ApplicationRef, ElementRef, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { NFormsModule } from 'carbon-components-angular/forms';\nimport { DialogModule } from 'carbon-components-angular/dialog';\nimport { I18n, I18nModule } from 'carbon-components-angular/i18n';\nimport { ButtonModule } from 'carbon-components-angular/button';\nimport { Search, SearchModule } from 'carbon-components-angular/search';\nimport { IconModule } from 'carbon-components-angular/icon';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from 'carbon-components-angular/i18n';\nimport * as ɵngcc2 from '@angular/common';\nimport * as ɵngcc3 from 'carbon-components-angular/button';\nimport * as ɵngcc4 from 'carbon-components-angular/icon';\nimport * as ɵngcc5 from 'carbon-components-angular/dialog';\nimport * as ɵngcc6 from 'carbon-components-angular/checkbox';\nimport * as ɵngcc7 from 'carbon-components-angular/radio';\n\nfunction TableToolbar_div_1_p_8_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"span\");\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const legacyText_r6 = ctx.ngIf;\n    const n_r2 = ɵngcc0.ɵɵnextContext().ngIf;\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(n_r2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", legacyText_r6, \" \");\n  }\n}\n\nfunction TableToolbar_div_1_p_8_ng_template_3_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵpipe(2, \"async\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r8 = ɵngcc0.ɵɵnextContext(4);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, ctx_r8._batchTextSingle.subject));\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    count: a0\n  };\n};\n\nfunction TableToolbar_div_1_p_8_ng_template_3_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵpipe(2, \"async\");\n    ɵngcc0.ɵɵpipe(3, \"i18nReplace\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const n_r2 = ɵngcc0.ɵɵnextContext(2).ngIf;\n    const ctx_r9 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(2, 1, ɵngcc0.ɵɵpipeBind2(3, 3, ctx_r9._batchTextMultiple.subject, ɵngcc0.ɵɵpureFunction1(6, _c0, n_r2))));\n  }\n}\n\nfunction TableToolbar_div_1_p_8_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TableToolbar_div_1_p_8_ng_template_3_span_0_Template, 3, 3, \"span\", 10);\n    ɵngcc0.ɵɵtemplate(1, TableToolbar_div_1_p_8_ng_template_3_span_1_Template, 4, 8, \"span\", 10);\n  }\n\n  if (rf & 2) {\n    const n_r2 = ɵngcc0.ɵɵnextContext().ngIf;\n    ɵngcc0.ɵɵproperty(\"ngIf\", n_r2 === 1);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", n_r2 !== 1);\n  }\n}\n\nfunction TableToolbar_div_1_p_8_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"p\", 7);\n    ɵngcc0.ɵɵtemplate(1, TableToolbar_div_1_p_8_ng_container_1_Template, 4, 2, \"ng-container\", 8);\n    ɵngcc0.ɵɵpipe(2, \"async\");\n    ɵngcc0.ɵɵtemplate(3, TableToolbar_div_1_p_8_ng_template_3_Template, 2, 2, \"ng-template\", null, 9, ɵngcc0.ɵɵtemplateRefExtractor);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const _r4 = ɵngcc0.ɵɵreference(4);\n\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ɵngcc0.ɵɵpipeBind1(2, 2, ctx_r1._batchTextLegacy.subject))(\"ngIfElse\", _r4);\n  }\n}\n\nconst _c1 = function (a0) {\n  return {\n    \"bx--batch-actions--active\": a0\n  };\n};\n\nfunction TableToolbar_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵelementStart(2, \"div\", 3);\n    ɵngcc0.ɵɵprojection(3, 1);\n    ɵngcc0.ɵɵelementStart(4, \"button\", 4);\n    ɵngcc0.ɵɵlistener(\"click\", function TableToolbar_div_1_Template_button_click_4_listener() {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ctx_r12.onCancel();\n    });\n    ɵngcc0.ɵɵtext(5);\n    ɵngcc0.ɵɵpipe(6, \"async\");\n    ɵngcc0.ɵɵelementEnd()();\n    ɵngcc0.ɵɵelementStart(7, \"div\", 5);\n    ɵngcc0.ɵɵtemplate(8, TableToolbar_div_1_p_8_Template, 5, 4, \"p\", 6);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(9, _c1, ctx_r0.selected));\n    ɵngcc0.ɵɵattribute(\"aria-label\", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r0.actionBarLabel.subject));\n    ɵngcc0.ɵɵadvance(4);\n    ɵngcc0.ɵɵproperty(\"tabindex\", ctx_r0.selected ? 0 : -1);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ɵngcc0.ɵɵpipeBind1(6, 7, ctx_r0._cancelText.subject), \" \");\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.count);\n  }\n}\n\nconst _c2 = [\"*\", [[\"ibm-table-toolbar-actions\"]]];\n\nconst _c3 = function (a0) {\n  return {\n    \"bx--table-toolbar--small\": a0\n  };\n};\n\nconst _c4 = [\"*\", \"ibm-table-toolbar-actions\"];\nconst _c5 = [\"*\"];\n\nfunction TableToolbarSearch_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 5);\n  }\n}\n\nfunction TableToolbarSearch_ng_template_4_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 10);\n    ɵngcc0.ɵɵlistener(\"click\", function TableToolbarSearch_ng_template_4_button_2_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r8);\n      const ctx_r7 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r7.openSearch();\n    });\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(1, \"svg\", 11);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction TableToolbarSearch_ng_template_4__svg_svg_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"svg\", 11);\n  }\n}\n\nfunction TableToolbarSearch_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"input\", 6, 7);\n    ɵngcc0.ɵɵlistener(\"input\", function TableToolbarSearch_ng_template_4_Template_input_input_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.onSearch($event.target.value);\n    })(\"keyup.enter\", function TableToolbarSearch_ng_template_4_Template_input_keyup_enter_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r10);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.onEnter();\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(2, TableToolbarSearch_ng_template_4_button_2_Template, 2, 0, \"button\", 8);\n    ɵngcc0.ɵɵtemplate(3, TableToolbarSearch_ng_template_4__svg_svg_3_Template, 1, 0, \"svg\", 9);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"type\", ctx_r2.tableSearch || !ctx_r2.toolbar ? \"text\" : \"search\")(\"id\", ctx_r2.id)(\"value\", ctx_r2.value)(\"autocomplete\", ctx_r2.autocomplete)(\"placeholder\", ctx_r2.placeholder)(\"disabled\", ctx_r2.disabled)(\"required\", ctx_r2.required);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r2.tableSearch && ctx_r2.toolbar);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.tableSearch || !ctx_r2.toolbar);\n  }\n}\n\nconst _c6 = function (a0) {\n  return {\n    \"bx--search-close--hidden\": a0\n  };\n};\n\nfunction TableToolbarSearch_button_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function TableToolbarSearch_button_6_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext();\n      return ctx_r12.clearSearch();\n    });\n    ɵngcc0.ɵɵelementStart(1, \"span\", 13);\n    ɵngcc0.ɵɵtext(2);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(3, \"svg\", 14);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(3, _c6, !ctx_r3.value || ctx_r3.value.length === 0))(\"title\", ctx_r3.clearButtonTitle);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r3.clearButtonTitle);\n  }\n}\n\nconst _c7 = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {\n  return {\n    \"bx--search--sm\": a0,\n    \"bx--search--lg\": a1,\n    \"bx--search--xl\": a2,\n    \"bx--search--light\": a3,\n    \"bx--skeleton\": a4,\n    \"bx--search--expandable\": a5,\n    \"bx--search--expanded\": a6,\n    \"bx--toolbar-search\": a7,\n    \"bx--toolbar-search--active\": a8,\n    \"bx--toolbar-search-container-persistent\": a9,\n    \"bx--toolbar-search-container-expandable\": a10,\n    \"bx--toolbar-search-container-active\": a11\n  };\n};\n\nconst _c8 = function () {\n  return {\n    \"overflow-y\": \"scroll\"\n  };\n};\n\nfunction Table_tbody_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"tbody\", 6);\n    ɵngcc0.ɵɵlistener(\"deselectRow\", function Table_tbody_2_Template_tbody_deselectRow_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext();\n      return ctx_r6.onSelectRow($event);\n    })(\"scroll\", function Table_tbody_2_Template_tbody_scroll_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.onScroll($event);\n    })(\"selectRow\", function Table_tbody_2_Template_tbody_selectRow_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.onSelectRow($event);\n    })(\"rowClick\", function Table_tbody_2_Template_tbody_rowClick_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.onRowClick($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"checkboxRowLabel\", ctx_r0.getCheckboxRowLabel())(\"enableSingleSelect\", ctx_r0.enableSingleSelect)(\"expandButtonAriaLabel\", ctx_r0.expandButtonAriaLabel)(\"model\", ctx_r0.model)(\"size\", ctx_r0.size)(\"ngStyle\", ɵngcc0.ɵɵpureFunction0(9, _c8))(\"selectionLabelColumn\", ctx_r0.selectionLabelColumn)(\"showSelectionColumn\", ctx_r0.showSelectionColumn)(\"skeleton\", ctx_r0.skeleton);\n  }\n}\n\nfunction Table_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0);\n  }\n}\n\nfunction Table_ng_template_6_Template(rf, ctx) {}\n\nfunction Table_tr_7_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"tr\")(1, \"td\", 7)(2, \"div\", 8);\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(3, \"svg\", 9);\n    ɵngcc0.ɵɵelement(4, \"circle\", 10);\n    ɵngcc0.ɵɵelementEnd()()()();\n  }\n}\n\nfunction Table_tr_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"tr\")(1, \"td\", 11)(2, \"h5\");\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵpipe(4, \"async\");\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(5, \"button\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function Table_tr_8_Template_button_click_5_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r12);\n      const ctx_r11 = ɵngcc0.ɵɵnextContext();\n      return ctx_r11.scrollToTop($event);\n    });\n    ɵngcc0.ɵɵtext(6);\n    ɵngcc0.ɵɵpipe(7, \"async\");\n    ɵngcc0.ɵɵelementEnd()()();\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind1(4, 2, ctx_r5.getEndOfDataText()));\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ɵngcc0.ɵɵpipeBind1(7, 4, ctx_r5.getScrollTopText()), \" \");\n  }\n}\n\nconst _c9 = function (a0) {\n  return {\n    \"bx--data-table--sticky-header\": a0\n  };\n};\n\nconst _c10 = [\"ibmTableHead\", \"\"];\n\nconst _c11 = function (a0) {\n  return {\n    \"bx--table-expand-v2\": a0\n  };\n};\n\nfunction TableHead_ng_container_0_th_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"th\", 6);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(2, _c11, ctx_r1.stickyHeader))(\"id\", ctx_r1.model.getId(\"expand\"));\n  }\n}\n\nfunction TableHead_ng_container_0_th_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"th\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r2.model.getId(\"select\"));\n  }\n}\n\nfunction TableHead_ng_container_0_th_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"th\", 8);\n    ɵngcc0.ɵɵlistener(\"change\", function TableHead_ng_container_0_th_4_Template_th_change_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r7);\n      const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r6.onSelectAllCheckboxChange();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"checked\", ctx_r3.selectAllCheckbox)(\"indeterminate\", ctx_r3.selectAllCheckboxSomeSelected)(\"ariaLabel\", ctx_r3.getCheckboxHeaderLabel())(\"size\", ctx_r3.size)(\"skeleton\", ctx_r3.skeleton)(\"name\", ctx_r3.model.getHeaderId(\"select\"))(\"id\", ctx_r3.model.getId(\"select\"));\n  }\n}\n\nfunction TableHead_ng_container_0_ng_container_5_th_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"th\", 10);\n    ɵngcc0.ɵɵlistener(\"sort\", function TableHead_ng_container_0_ng_container_5_th_1_Template_th_sort_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const i_r9 = ɵngcc0.ɵɵnextContext().index;\n      const ctx_r11 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r11.sort.emit(i_r9);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r14 = ɵngcc0.ɵɵnextContext();\n    const column_r8 = ctx_r14.$implicit;\n    const i_r9 = ctx_r14.index;\n    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassMap(column_r8.className);\n    ɵngcc0.ɵɵproperty(\"ngStyle\", column_r8.style)(\"sortable\", ctx_r10.sortable)(\"skeleton\", ctx_r10.skeleton)(\"id\", ctx_r10.model.getId(i_r9))(\"column\", column_r8)(\"skeleton\", ctx_r10.skeleton)(\"filterTitle\", ctx_r10.getFilterTitle());\n    ɵngcc0.ɵɵattribute(\"colspan\", column_r8.colSpan)(\"rowspan\", column_r8.rowSpan);\n  }\n}\n\nfunction TableHead_ng_container_0_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableHead_ng_container_0_ng_container_5_th_1_Template, 1, 11, \"th\", 9);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const column_r8 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", column_r8 && column_r8.visible);\n  }\n}\n\nconst _c12 = function (a0) {\n  return {\n    \"width\": a0,\n    \"padding\": 0,\n    \"border\": 0\n  };\n};\n\nfunction TableHead_ng_container_0_th_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"th\", 11);\n  }\n\n  if (rf & 2) {\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngStyle\", ɵngcc0.ɵɵpureFunction1(1, _c12, ctx_r5.scrollbarWidth + \"px\"));\n  }\n}\n\nfunction TableHead_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"tr\");\n    ɵngcc0.ɵɵtemplate(2, TableHead_ng_container_0_th_2_Template, 1, 4, \"th\", 1);\n    ɵngcc0.ɵɵtemplate(3, TableHead_ng_container_0_th_3_Template, 1, 1, \"th\", 2);\n    ɵngcc0.ɵɵtemplate(4, TableHead_ng_container_0_th_4_Template, 1, 7, \"th\", 3);\n    ɵngcc0.ɵɵtemplate(5, TableHead_ng_container_0_ng_container_5_Template, 2, 1, \"ng-container\", 4);\n    ɵngcc0.ɵɵtemplate(6, TableHead_ng_container_0_th_6_Template, 1, 3, \"th\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.model.hasExpandableRows());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && ctx_r0.enableSingleSelect);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && !ctx_r0.enableSingleSelect);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.model.header);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && ctx_r0.stickyHeader && ctx_r0.scrollbarWidth);\n  }\n}\n\nconst _c13 = [\"ibmTableHeadCell\", \"\"];\n\nfunction TableHeadCell_button_0_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 9);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r3.column.data, \" \");\n  }\n}\n\nfunction TableHeadCell_button_0_4_ng_template_0_Template(rf, ctx) {}\n\nconst _c14 = function (a0) {\n  return {\n    data: a0\n  };\n};\n\nfunction TableHeadCell_button_0_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TableHeadCell_button_0_4_ng_template_0_Template, 0, 0, \"ng-template\", 10);\n  }\n\n  if (rf & 2) {\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r4.column.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c14, ctx_r4.column.data));\n  }\n}\n\nfunction TableHeadCell_button_0__svg_svg_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 11);\n    ɵngcc0.ɵɵelement(1, \"path\", 12);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nfunction TableHeadCell_button_0__svg_svg_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 13);\n    ɵngcc0.ɵɵelement(1, \"path\", 14);\n    ɵngcc0.ɵɵelementEnd();\n  }\n}\n\nconst _c15 = function (a0, a1) {\n  return {\n    \"bx--table-sort--active\": a0,\n    \"bx--table-sort--ascending\": a1\n  };\n};\n\nfunction TableHeadCell_button_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 3);\n    ɵngcc0.ɵɵlistener(\"click\", function TableHeadCell_button_0_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.onClick();\n    });\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵelementStart(2, \"span\", 4);\n    ɵngcc0.ɵɵtemplate(3, TableHeadCell_button_0_div_3_Template, 2, 1, \"div\", 5);\n    ɵngcc0.ɵɵtemplate(4, TableHeadCell_button_0_4_Template, 1, 4, null, 6);\n    ɵngcc0.ɵɵtemplate(5, TableHeadCell_button_0__svg_svg_5_Template, 2, 0, \"svg\", 7);\n    ɵngcc0.ɵɵtemplate(6, TableHeadCell_button_0__svg_svg_6_Template, 2, 0, \"svg\", 8);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(9, _c15, ctx_r0.column.sorted, ctx_r0.column.ascending));\n    ɵngcc0.ɵɵattribute(\"aria-label\", ɵngcc0.ɵɵpipeBind1(1, 7, ctx_r0.column.sorted && ctx_r0.column.ascending ? ctx_r0.getSortDescendingLabel() : ctx_r0.getSortAscendingLabel()));\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"title\", ctx_r0.column.title);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && !ctx_r0.column.template);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && ctx_r0.column.template);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton);\n  }\n}\n\nfunction TableHeadCell_div_1_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 17);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"title\", ctx_r10.column.data);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r10.column.data);\n  }\n}\n\nfunction TableHeadCell_div_1_ng_template_2_Template(rf, ctx) {}\n\nfunction TableHeadCell_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 15);\n    ɵngcc0.ɵɵtemplate(1, TableHeadCell_div_1_span_1_Template, 2, 2, \"span\", 16);\n    ɵngcc0.ɵɵtemplate(2, TableHeadCell_div_1_ng_template_2_Template, 0, 0, \"ng-template\", 10);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.column.template);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.column.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(3, _c14, ctx_r1.column.data));\n  }\n}\n\nfunction TableHeadCell_button_2_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵnamespaceHTML();\n    ɵngcc0.ɵɵelementStart(0, \"span\");\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r12 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r12.column.filterCount, \" \");\n  }\n}\n\nconst _c16 = function (a0) {\n  return {\n    \"active\": a0\n  };\n};\n\nfunction TableHeadCell_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"button\", 18);\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(2, \"svg\", 19);\n    ɵngcc0.ɵɵelement(3, \"path\", 20);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵtemplate(4, TableHeadCell_button_2_span_4_Template, 2, 1, \"span\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(7, _c16, ctx_r2.column.filterCount > 0))(\"ibmTooltip\", ctx_r2.column.filterTemplate)(\"title\", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r2.getFilterTitle()))(\"data\", ctx_r2.column.filterData);\n    ɵngcc0.ɵɵadvance(4);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r2.column.filterCount > 0);\n  }\n}\n\nconst _c17 = [\"ibmTableHeadCheckbox\", \"\"];\n\nfunction TableHeadCheckbox_ibm_checkbox_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"ibm-checkbox\", 1);\n    ɵngcc0.ɵɵlistener(\"checkedChange\", function TableHeadCheckbox_ibm_checkbox_0_Template_ibm_checkbox_checkedChange_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.change.emit();\n    });\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"size\", ctx_r0.size !== \"sm\" ? \"md\" : \"sm\")(\"name\", ctx_r0.name)(\"checked\", ctx_r0.checked)(\"indeterminate\", ctx_r0.indeterminate)(\"aria-label\", ɵngcc0.ɵɵpipeBind1(1, 5, ctx_r0.getAriaLabel()));\n  }\n}\n\nconst _c18 = [\"ibmTableHeadExpand\", \"\"];\nconst _c19 = [\"ibmTableBody\", \"\"];\n\nconst _c20 = function (a0, a1, a2, a3) {\n  return {\n    \"tbody_row--success\": a0,\n    \"tbody_row--warning\": a1,\n    \"tbody_row--info\": a2,\n    \"tbody_row--error\": a3\n  };\n};\n\nfunction TableBody_ng_container_0_ng_container_1_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"tr\", 4);\n    ɵngcc0.ɵɵlistener(\"selectRow\", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_selectRow_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const i_r3 = ɵngcc0.ɵɵnextContext().index;\n      const ctx_r7 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r7.onRowCheckboxChange(i_r3);\n    })(\"deselectRow\", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_deselectRow_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const i_r3 = ɵngcc0.ɵɵnextContext().index;\n      const ctx_r10 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r10.onRowCheckboxChange(i_r3);\n    })(\"expandRow\", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_expandRow_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const i_r3 = ɵngcc0.ɵɵnextContext().index;\n      const ctx_r12 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r12.model.expandRow(i_r3, !ctx_r12.model.isRowExpanded(i_r3));\n    })(\"rowClick\", function TableBody_ng_container_0_ng_container_1_tr_1_Template_tr_rowClick_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const i_r3 = ɵngcc0.ɵɵnextContext().index;\n      const ctx_r14 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r14.onRowClick(i_r3);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r16 = ɵngcc0.ɵɵnextContext();\n    const i_r3 = ctx_r16.index;\n    const row_r2 = ctx_r16.$implicit;\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassMap(ctx_r4.model.rowsClass[i_r3] ? ctx_r4.model.rowsClass[i_r3] : null);\n    ɵngcc0.ɵɵproperty(\"model\", ctx_r4.model)(\"row\", row_r2)(\"size\", ctx_r4.size)(\"selected\", ctx_r4.model.isRowSelected(i_r3))(\"expandable\", ctx_r4.model.isRowExpandable(i_r3))(\"expanded\", ctx_r4.model.isRowExpanded(i_r3))(\"checkboxLabel\", ctx_r4.getCheckboxRowLabel())(\"expandButtonAriaLabel\", ctx_r4.getExpandButtonAriaLabel())(\"showSelectionColumn\", ctx_r4.showSelectionColumn)(\"enableSingleSelect\", ctx_r4.enableSingleSelect)(\"skeleton\", ctx_r4.skeleton)(\"ngClass\", ɵngcc0.ɵɵpureFunction4(14, _c20, !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === \"success\", !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === \"warning\", !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === \"info\", !ctx_r4.model.isRowSelected(i_r3) && ctx_r4.model.getRowContext(i_r3) === \"error\"));\n  }\n}\n\nfunction TableBody_ng_container_0_ng_container_1_tr_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tr\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r17 = ɵngcc0.ɵɵnextContext();\n    const row_r2 = ctx_r17.$implicit;\n    const i_r3 = ctx_r17.index;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"row\", row_r2)(\"expanded\", ctx_r5.model.isRowExpanded(i_r3))(\"skeleton\", ctx_r5.skeleton);\n  }\n}\n\nfunction TableBody_ng_container_0_ng_container_1_ng_container_3_tr_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"tr\", 7);\n  }\n\n  if (rf & 2) {\n    const expandedDataRow_r19 = ctx.$implicit;\n    const ctx_r18 = ɵngcc0.ɵɵnextContext(4);\n    ɵngcc0.ɵɵproperty(\"model\", ctx_r18.model)(\"showSelectionColumnCheckbox\", false)(\"showSelectionColumn\", ctx_r18.showSelectionColumn)(\"row\", expandedDataRow_r19)(\"size\", ctx_r18.size)(\"skeleton\", ctx_r18.skeleton);\n  }\n}\n\nfunction TableBody_ng_container_0_ng_container_1_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_ng_container_3_tr_1_Template, 1, 6, \"tr\", 6);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const row_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r6.firstExpandedDataInRow(row_r2));\n  }\n}\n\nfunction TableBody_ng_container_0_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_tr_1_Template, 1, 19, \"tr\", 2);\n    ɵngcc0.ɵɵtemplate(2, TableBody_ng_container_0_ng_container_1_tr_2_Template, 1, 3, \"tr\", 3);\n    ɵngcc0.ɵɵtemplate(3, TableBody_ng_container_0_ng_container_1_ng_container_3_Template, 2, 1, \"ng-container\", 0);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const row_r2 = ctx.$implicit;\n    const i_r3 = ctx.index;\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r1.model.isRowFiltered(i_r3));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.model.isRowExpandable(i_r3) && !ctx_r1.shouldExpandAsTable(row_r2) && !ctx_r1.model.isRowFiltered(i_r3));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r1.model.isRowExpandable(i_r3) && ctx_r1.shouldExpandAsTable(row_r2) && ctx_r1.model.isRowExpanded(i_r3) && !ctx_r1.model.isRowFiltered(i_r3));\n  }\n}\n\nfunction TableBody_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableBody_ng_container_0_ng_container_1_Template, 4, 3, \"ng-container\", 1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.model.data);\n  }\n}\n\nconst _c21 = [\"ibmTableRow\", \"\"];\n\nfunction TableRowComponent_ng_container_0_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 4);\n    ɵngcc0.ɵɵlistener(\"expandRow\", function TableRowComponent_ng_container_0_td_1_Template_td_expandRow_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r6);\n      const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r5.expandRow.emit();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"expanded\", ctx_r1.expanded)(\"expandable\", ctx_r1.expandable)(\"skeleton\", ctx_r1.skeleton)(\"ariaLabel\", ctx_r1.getExpandButtonAriaLabel())(\"headers\", ctx_r1.model.getHeaderId(\"expand\"));\n  }\n}\n\nfunction TableRowComponent_ng_container_0_ng_container_2_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"td\");\n  }\n}\n\nfunction TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 7);\n    ɵngcc0.ɵɵlistener(\"change\", function TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template_td_change_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r11);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r10.onSelectionChange();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r9 = ɵngcc0.ɵɵnextContext(3);\n    ɵngcc0.ɵɵproperty(\"size\", ctx_r9.size)(\"selected\", ctx_r9.selected)(\"label\", ctx_r9.getCheckboxLabel())(\"row\", ctx_r9.row)(\"skeleton\", ctx_r9.skeleton)(\"headers\", ctx_r9.model.getHeaderId(\"select\"));\n  }\n}\n\nfunction TableRowComponent_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableRowComponent_ng_container_0_ng_container_2_td_1_Template, 1, 0, \"td\", 5);\n    ɵngcc0.ɵɵtemplate(2, TableRowComponent_ng_container_0_ng_container_2_ng_template_2_Template, 1, 6, \"ng-template\", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const _r8 = ɵngcc0.ɵɵreference(3);\n\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r2.showSelectionColumnCheckbox)(\"ngIfElse\", _r8);\n  }\n}\n\nfunction TableRowComponent_ng_container_0_td_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 8);\n    ɵngcc0.ɵɵlistener(\"change\", function TableRowComponent_ng_container_0_td_3_Template_td_change_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r13);\n      const ctx_r12 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r12.onSelectionChange();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"selected\", ctx_r3.selected)(\"label\", ctx_r3.getCheckboxLabel())(\"row\", ctx_r3.row)(\"skeleton\", ctx_r3.skeleton)(\"headers\", ctx_r3.model.getHeaderId(\"select\"));\n  }\n}\n\nfunction TableRowComponent_ng_container_0_ng_container_4_td_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 11);\n    ɵngcc0.ɵɵlistener(\"click\", function TableRowComponent_ng_container_0_ng_container_4_td_1_Template_td_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r19);\n      const ctx_r18 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r18.onRowClick();\n    })(\"keydown.enter\", function TableRowComponent_ng_container_0_ng_container_4_td_1_Template_td_keydown_enter_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r19);\n      const ctx_r20 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r20.onRowClick();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r21 = ɵngcc0.ɵɵnextContext();\n    const j_r15 = ctx_r21.index;\n    const item_r14 = ctx_r21.$implicit;\n    const ctx_r16 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassMap(ctx_r16.model.getHeader(j_r15).className);\n    ɵngcc0.ɵɵproperty(\"headers\", ctx_r16.model.getHeaderId(j_r15, item_r14.colSpan))(\"item\", item_r14)(\"title\", item_r14.title)(\"ngStyle\", ctx_r16.model.getHeader(j_r15).style)(\"skeleton\", ctx_r16.skeleton);\n    ɵngcc0.ɵɵattribute(\"colspan\", item_r14.colSpan)(\"rowspan\", item_r14.rowSpan);\n  }\n}\n\nfunction TableRowComponent_ng_container_0_ng_container_4_td_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"td\", 12);\n    ɵngcc0.ɵɵlistener(\"click\", function TableRowComponent_ng_container_0_ng_container_4_td_2_Template_td_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r23);\n      const ctx_r22 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r22.onRowClick();\n    })(\"keydown.enter\", function TableRowComponent_ng_container_0_ng_container_4_td_2_Template_td_keydown_enter_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r23);\n      const ctx_r24 = ɵngcc0.ɵɵnextContext(3);\n      return ctx_r24.onRowClick();\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r25 = ɵngcc0.ɵɵnextContext();\n    const j_r15 = ctx_r25.index;\n    const item_r14 = ctx_r25.$implicit;\n    const ctx_r17 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"headers\", ctx_r17.model.getHeaderId(j_r15, item_r14.colSpan))(\"item\", item_r14)(\"title\", item_r14.title)(\"skeleton\", ctx_r17.skeleton);\n    ɵngcc0.ɵɵattribute(\"colspan\", item_r14.colSpan)(\"rowspan\", item_r14.rowSpan);\n  }\n}\n\nfunction TableRowComponent_ng_container_0_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableRowComponent_ng_container_0_ng_container_4_td_1_Template, 1, 9, \"td\", 9);\n    ɵngcc0.ɵɵtemplate(2, TableRowComponent_ng_container_0_ng_container_4_td_2_Template, 1, 6, \"td\", 10);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r14 = ctx.$implicit;\n    const j_r15 = ctx.index;\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", item_r14 && ctx_r4.model.getHeader(j_r15) && ctx_r4.model.getHeader(j_r15).visible);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", item_r14 && ctx_r4.model.getHeader(j_r15) == null);\n  }\n}\n\nfunction TableRowComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, TableRowComponent_ng_container_0_td_1_Template, 1, 5, \"td\", 1);\n    ɵngcc0.ɵɵtemplate(2, TableRowComponent_ng_container_0_ng_container_2_Template, 4, 2, \"ng-container\", 0);\n    ɵngcc0.ɵɵtemplate(3, TableRowComponent_ng_container_0_td_3_Template, 1, 5, \"td\", 2);\n    ɵngcc0.ɵɵtemplate(4, TableRowComponent_ng_container_0_ng_container_4_Template, 3, 2, \"ng-container\", 3);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.model.hasExpandableRows());\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && !ctx_r0.enableSingleSelect);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r0.skeleton && ctx_r0.showSelectionColumn && ctx_r0.enableSingleSelect);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.row);\n  }\n}\n\nconst _c22 = [\"ibmTableExpandedRow\", \"\"];\n\nfunction TableExpandedRow_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r0.firstExpandedDataInRow(ctx_r0.row), \" \");\n  }\n}\n\nfunction TableExpandedRow_ng_template_2_Template(rf, ctx) {}\n\nconst _c23 = [\"ibmTableData\", \"\"];\n\nfunction TableData_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.item.data);\n  }\n}\n\nfunction TableData_1_ng_template_0_Template(rf, ctx) {}\n\nfunction TableData_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, TableData_1_ng_template_0_Template, 0, 0, \"ng-template\", 1);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r1.item.template)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c14, ctx_r1.item.data));\n  }\n}\n\nconst _c24 = [\"ibmTableCheckbox\", \"\"];\n\nfunction TableCheckbox_ibm_checkbox_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"ibm-checkbox\", 1);\n    ɵngcc0.ɵɵlistener(\"change\", function TableCheckbox_ibm_checkbox_0_Template_ibm_checkbox_change_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.change.emit();\n    });\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵpipe(2, \"i18nReplace\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"name\", ctx_r0.name)(\"aria-label\", ɵngcc0.ɵɵpipeBind1(1, 5, ɵngcc0.ɵɵpipeBind2(2, 7, ctx_r0.getLabel(), ctx_r0.getSelectionLabelValue(ctx_r0.row))))(\"size\", ctx_r0.size !== \"sm\" ? \"md\" : \"sm\")(\"checked\", ctx_r0.selected)(\"disabled\", ctx_r0.disabled);\n  }\n}\n\nconst _c25 = [\"ibmTableRadio\", \"\"];\n\nfunction TableRadio_ibm_radio_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"ibm-radio\", 1);\n    ɵngcc0.ɵɵlistener(\"change\", function TableRadio_ibm_radio_0_Template_ibm_radio_change_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.change.emit();\n    });\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵpipe(2, \"i18nReplace\");\n    ɵngcc0.ɵɵpipe(3, \"async\");\n    ɵngcc0.ɵɵpipe(4, \"i18nReplace\");\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"ariaLabel\", ɵngcc0.ɵɵpipeBind1(3, 8, ɵngcc0.ɵɵpipeBind2(4, 10, ctx_r0.getLabel(), ctx_r0.getSelectionLabelValue(ctx_r0.row))))(\"checked\", ctx_r0.selected);\n    ɵngcc0.ɵɵattribute(\"aria-label\", ɵngcc0.ɵɵpipeBind1(1, 3, ɵngcc0.ɵɵpipeBind2(2, 5, ctx_r0.getLabel(), ctx_r0.getSelectionLabelValue(ctx_r0.row))));\n  }\n}\n\nconst _c26 = [\"ibmTableExpandButton\", \"\"];\n\nfunction TableExpandButton_button_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 1);\n    ɵngcc0.ɵɵlistener(\"click\", function TableExpandButton_button_0_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r2);\n      const ctx_r1 = ɵngcc0.ɵɵnextContext();\n      return ctx_r1.expandRow.emit();\n    });\n    ɵngcc0.ɵɵpipe(1, \"async\");\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(2, \"svg\", 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"aria-label\", ɵngcc0.ɵɵpipeBind1(1, 1, ctx_r0.getAriaLabel()));\n  }\n}\n\nclass TableHeaderItem {\n  /**\n   * Creates an instance of TableHeaderItem.\n   */\n  constructor(rawData) {\n    /**\n     * Defines if column under this TableHeaderItem should be displayed.\n     *\n     */\n    this.visible = true;\n    /**\n     * Disables sorting by default.\n     *\n     */\n\n    this.sorted = false;\n    /**\n     * Enables sorting on click by default.\n     * If false then this column won't show a sorting arrow at all.\n     *\n     */\n\n    this.sortable = true;\n    /**\n     * Number of applied filters.\n     *\n     * `filter()` should set it to appropriate number.\n     *\n     */\n\n    this.filterCount = 0;\n    /**\n     * The number of rows to span\n     * **NOTE:** not supported by the default carbon table\n     */\n\n    this.rowSpan = 1;\n    /**\n     * The number of columns to span\n     */\n\n    this.colSpan = 1;\n    /**\n     * Style for the column, applied to every element in the column.\n     *\n     * ngStyle-like format\n     *\n     */\n\n    this.style = {};\n    /**\n     * used in `ascending`\n     *\n     * @protected\n     */\n\n    this._ascending = true; // defaults so we dont leave things empty\n\n    const defaults = {\n      data: \"\",\n      visible: this.visible,\n      style: this.style,\n      filterCount: this.filterCount,\n      filterData: {\n        data: \"\"\n      }\n    }; // fill our object with provided props, and fallback to defaults\n\n    const data = Object.assign({}, defaults, rawData);\n\n    for (let property of Object.getOwnPropertyNames(data)) {\n      if (data.hasOwnProperty(property)) {\n        this[property] = data[property];\n      }\n    }\n  }\n  /**\n   * If true, sort is set to ascending, if false descending will be true.\n   *\n   */\n\n\n  set ascending(asc) {\n    this._ascending = asc;\n  }\n\n  get ascending() {\n    return this._ascending;\n  }\n  /**\n   * If true, sort is set to descending, if false ascending will be true.\n   *\n   */\n\n\n  set descending(desc) {\n    this._ascending = !desc;\n  }\n\n  get descending() {\n    return !this._ascending;\n  }\n\n  get title() {\n    if (this._title) {\n      return this._title;\n    }\n\n    if (!this.data) {\n      return \"\";\n    }\n\n    if (typeof this.data === \"string\") {\n      return this.data;\n    }\n\n    if (this.data.toString && this.data.constructor !== {}.constructor) {\n      return this.data.toString();\n    } // data can’t be reasonably converted to an end user readable string\n\n\n    return \"\";\n  }\n\n  set title(title) {\n    this._title = title;\n  }\n  /**\n   * Used for sorting rows of the table.\n   *\n   * Override to enable different sorting.\n   *\n   * < 0 if `one` should go before `two`\n   * > 0 if `one` should go after `two`\n   * 0 if it doesn't matter (they are the same)\n   */\n\n\n  compare(one, two) {\n    if (!one || !two) {\n      return 0;\n    }\n\n    if (typeof one.data === \"string\") {\n      return one.data.localeCompare(two.data);\n    }\n\n    if (one.data < two.data) {\n      return -1;\n    } else if (one.data > two.data) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n  /**\n   * Used to filter rows in the table.\n   *\n   * Override to make a custom filter.\n   *\n   * Even though there is just one filter function, there can be multiple filters.\n   * When implementing filter, set `filterCount` before returning.\n   *\n   * `true` to hide the row\n   * `false` to show the row\n   */\n\n\n  filter(item) {\n    this.filterCount = 0;\n    return false;\n  }\n\n}\n\nclass TableItem {\n  /**\n   * Creates an instance of TableItem.\n   */\n  constructor(rawData) {\n    /**\n     * The number of rows to span\n     */\n    this.rowSpan = 1;\n    /**\n     * The number of columns to span\n     */\n\n    this.colSpan = 1; // defaults so we dont leave things empty\n\n    const defaults = {\n      data: \"\"\n    }; // fill our object with provided props, and fallback to defaults\n\n    const data = Object.assign({}, defaults, rawData);\n\n    for (const property of Object.getOwnPropertyNames(data)) {\n      if (data.hasOwnProperty(property)) {\n        this[property] = data[property];\n      }\n    }\n  }\n\n  get title() {\n    if (typeof this._title === \"string\") {\n      return this._title;\n    }\n\n    if (!this.data) {\n      return \"\";\n    }\n\n    if (typeof this.data === \"string\") {\n      return this.data;\n    }\n\n    if (this.data.toString && this.data.constructor !== {}.constructor) {\n      return this.data.toString();\n    } // data can’t be reasonably converted to an end user readable string\n\n\n    return \"\";\n  }\n\n  set title(title) {\n    this._title = title;\n  }\n\n}\n/**\n * TableModel represents a data model for two-dimensional data. It's used for all things table\n * (table component, table toolbar, pagination, etc)\n *\n * TableModel manages its internal data integrity very well if you use the provided helper\n * functions for modifying rows and columns and assigning header and data in that order.\n *\n * It also provides direct access to the data so you can read and modify it.\n * If you change the structure of the data (by directly pushing into the arrays or otherwise),\n * keep in mind to keep the data structure intact.\n *\n * Header length and length of every line in the data should be equal.\n *\n * If they are not consistent, unexpected things will happen.\n *\n * Use the provided functions when in doubt.\n */\n\n\nlet TableModel = /*#__PURE__*/(() => {\n  class TableModel {\n    constructor() {\n      this.dataChange = new EventEmitter();\n      this.rowsSelectedChange = new EventEmitter();\n      this.rowsExpandedChange = new EventEmitter();\n      /**\n       * Gets emitted when `selectAll` is called. Emits false if all rows are deselected and true if\n       * all rows are selected.\n       */\n\n      this.selectAllChange = new Subject();\n      /**\n       * Contains information about selection state of rows in the table.\n       */\n\n      this.rowsSelected = [];\n      /**\n       * Contains information about expanded state of rows in the table.\n       */\n\n      this.rowsExpanded = [];\n      /**\n       * Contains information about the context of the row.\n       *\n       * It affects styling of the row to reflect the context.\n       *\n       * string can be one of `\"success\" | \"warning\" | \"info\" | \"error\" | \"\"` and it's\n       * empty or undefined by default\n       */\n\n      this.rowsContext = [];\n      /**\n       * Contains class name(s) of the row.\n       *\n       * It affects styling of the row to reflect the appended class name(s).\n       *\n       * It's empty or undefined by default\n       */\n\n      this.rowsClass = [];\n      /**\n       * Contains information about the header cells of the table.\n       */\n\n      this.header = [];\n      /**\n       * Tracks the current page.\n       */\n\n      this.currentPage = 1;\n      /**\n       * Length of page.\n       */\n\n      this.pageLength = 10;\n      /**\n       * Set to true when there is no more data to load in the table\n       */\n\n      this.isEnd = false;\n      /**\n       * Set to true when lazy loading to show loading indicator\n       */\n\n      this.isLoading = false;\n      /**\n       * Used in `data`\n       */\n\n      this._data = [[]];\n      /**\n       * The number of models instantiated, this is to make sure each table has a different\n       * model count for unique id generation.\n       */\n\n      this.tableModelCount = 0;\n      this.tableModelCount = TableModel.COUNT++;\n    }\n    /**\n     * Sets data of the table.\n     *\n     * Make sure all rows are the same length to keep the column count accurate.\n     */\n\n\n    set data(newData) {\n      if (!newData || Array.isArray(newData) && newData.length === 0) {\n        newData = [[]];\n      }\n\n      this._data = newData; // init rowsSelected\n\n      this.rowsSelected = new Array(this._data.length).fill(false);\n      this.rowsExpanded = new Array(this._data.length).fill(false); // init rowsContext\n\n      this.rowsContext = new Array(this._data.length); // init rowsClass\n\n      this.rowsClass = new Array(this._data.length); // only create a fresh header if necessary (header doesn't exist or differs in length)\n\n      if (this.header == null || this.header.length !== this._data[0].length && this._data[0].length > 0) {\n        let header = new Array();\n\n        for (let i = 0; i < this._data[0].length; i++) {\n          header.push(new TableHeaderItem());\n        }\n\n        this.header = header;\n      }\n\n      this.dataChange.emit();\n    }\n    /**\n     * Gets the full data.\n     *\n     * You can use it to alter individual `TableItem`s but if you need to change\n     * table structure, use `addRow()` and/or `addColumn()`\n     */\n\n\n    get data() {\n      return this._data;\n    }\n    /**\n     * Manually set data length in case the data in the table doesn't\n     * correctly reflect all the data that table is to display.\n     *\n     * Example: if you have multiple pages of data that table will display\n     * but you're loading one at a time.\n     *\n     * Set to `null` to reset to default behavior.\n     */\n\n\n    set totalDataLength(length) {\n      // if this function is called without a parameter we need to set to null to avoid having undefined != null\n      this._totalDataLength = isNaN(length) ? null : length;\n    }\n    /**\n     * Total length of data that table has access to, or the amount manually set\n     */\n\n\n    get totalDataLength() {\n      // if manually set data length\n      if (this._totalDataLength !== null && this._totalDataLength >= 0) {\n        return this._totalDataLength;\n      } // if empty dataset\n\n\n      if (this.data && this.data.length === 1 && this.data[0].length === 0) {\n        return 0;\n      }\n\n      return this.data.length;\n    }\n    /**\n     * Returns an id for the given column\n     *\n     * @param column the column to generate an id for\n     * @param row the row of the header to generate an id for\n     */\n\n\n    getId(column, row = 0) {\n      return `table-header-${row}-${column}-${this.tableModelCount}`;\n    }\n    /**\n     * Returns the id of the header. Used to link the cells with headers (or headers with headers)\n     *\n     * @param column the column to start getting headers for\n     * @param colSpan the number of columns to get headers for (defaults to 1)\n     */\n\n\n    getHeaderId(column, colSpan = 1) {\n      if (column === \"select\" || column === \"expand\") {\n        return this.getId(column);\n      }\n\n      let ids = [];\n\n      for (let i = column; i >= 0; i--) {\n        if (this.header[i]) {\n          for (let j = 0; j < colSpan; j++) {\n            ids.push(this.getId(i + j));\n          }\n\n          break;\n        }\n      }\n\n      return ids.join(\" \");\n    }\n    /**\n     * Finds closest header by trying the `column` and then working its way to the left\n     *\n     * @param column the target column\n     */\n\n\n    getHeader(column) {\n      if (!this.header) {\n        return null;\n      }\n\n      for (let i = column; i >= 0; i--) {\n        const headerCell = this.header[i];\n\n        if (headerCell) {\n          return headerCell;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Returns how many rows is currently selected\n     */\n\n\n    selectedRowsCount() {\n      let count = 0;\n\n      if (this.rowsSelected) {\n        this.rowsSelected.forEach(rowSelected => {\n          if (rowSelected) {\n            count++;\n          }\n        });\n      }\n\n      return count;\n    }\n    /**\n     * Returns how many rows is currently expanded\n     */\n\n\n    expandedRowsCount() {\n      let count = 0;\n\n      if (this.rowsExpanded) {\n        this.rowsExpanded.forEach(rowExpanded => {\n          if (rowExpanded) {\n            count++;\n          }\n        });\n      }\n\n      return count;\n    }\n    /**\n     * Returns `index`th row of the table.\n     *\n     * Negative index starts from the end. -1 being the last element.\n     *\n     * @param index\n     */\n\n\n    row(index) {\n      return this.data[this.realRowIndex(index)];\n    }\n    /**\n     * Adds a row to the `index`th row or appends to table if index not provided.\n     *\n     * If row is shorter than other rows or not provided, it will be padded with\n     * empty `TableItem` elements.\n     *\n     * If row is longer than other rows, others will be extended to match so no data is lost.\n     *\n     * If called on an empty table with no parameters, it creates a 1x1 table.\n     *\n     * Negative index starts from the end. -1 being the last element.\n     *\n     * @param [row]\n     * @param [index]\n     */\n\n\n    addRow(row, index) {\n      // if table empty create table with row\n      if (!this.data || this.data.length === 0 || this.data[0].length === 0) {\n        let newData = new Array();\n        newData.push(row ? row : [new TableItem()]); // row or one empty one column row\n\n        this.data = newData;\n        return;\n      }\n\n      let realRow = row;\n      const columnCount = this.data[0].length;\n\n      if (row == null) {\n        realRow = new Array();\n\n        for (let i = 0; i < columnCount; i++) {\n          realRow.push(new TableItem());\n        }\n      }\n\n      if (realRow.length < columnCount) {\n        // extend the length of realRow\n        const difference = columnCount - realRow.length;\n\n        for (let i = 0; i < difference; i++) {\n          realRow.push(new TableItem());\n        }\n      } else if (realRow.length > columnCount) {\n        // extend the length of header\n        let difference = realRow.length - this.header.length;\n\n        for (let j = 0; j < difference; j++) {\n          this.header.push(new TableHeaderItem());\n        } // extend the length of every other row\n\n\n        for (let i = 0; i < this.data.length; i++) {\n          let currentRow = this.data[i];\n          difference = realRow.length - currentRow.length;\n\n          for (let j = 0; j < difference; j++) {\n            currentRow.push(new TableItem());\n          }\n        }\n      }\n\n      if (index == null) {\n        this.data.push(realRow); // update rowsSelected property for length\n\n        this.rowsSelected.push(false); // update rowsExpanded property for length\n\n        this.rowsExpanded.push(false); // update rowsContext property for length\n\n        this.rowsContext.push(undefined); // update rowsClass property for length\n\n        this.rowsClass.push(undefined);\n      } else {\n        const ri = this.realRowIndex(index);\n        this.data.splice(ri, 0, realRow); // update rowsSelected property for length\n\n        this.rowsSelected.splice(ri, 0, false); // update rowsExpanded property for length\n\n        this.rowsExpanded.splice(ri, 0, false); // update rowsContext property for length\n\n        this.rowsContext.splice(ri, 0, undefined); // update rowsClass property for length\n\n        this.rowsClass.splice(ri, 0, undefined);\n      }\n\n      this.dataChange.emit();\n    }\n    /**\n     * Deletes `index`th row.\n     *\n     * Negative index starts from the end. -1 being the last element.\n     *\n     * @param index\n     */\n\n\n    deleteRow(index) {\n      const rri = this.realRowIndex(index);\n      this.data.splice(rri, 1);\n      this.rowsSelected.splice(rri, 1);\n      this.rowsExpanded.splice(rri, 1);\n      this.rowsContext.splice(rri, 1);\n      this.rowsClass.splice(rri, 1);\n      this.dataChange.emit();\n    }\n\n    hasExpandableRows() {\n      return this.data.some(data => data.some(d => d && d.expandedData)); // checking for some in 2D array\n    }\n\n    isRowExpandable(index) {\n      return this.data[index].some(d => d && d.expandedData);\n    }\n\n    isRowExpanded(index) {\n      return this.rowsExpanded[index];\n    }\n\n    getRowContext(index) {\n      return this.rowsContext[index];\n    }\n    /**\n     * Returns `index`th column of the table.\n     *\n     * Negative index starts from the end. -1 being the last element.\n     *\n     * @param index\n     */\n\n\n    column(index) {\n      let column = new Array();\n      const ri = this.realColumnIndex(index);\n      const rc = this.data.length;\n\n      for (let i = 0; i < rc; i++) {\n        const row = this.data[i];\n        column.push(row[ri]);\n      }\n\n      return column;\n    }\n    /**\n     * Adds a column to the `index`th column or appends to table if index not provided.\n     *\n     * If column is shorter than other columns or not provided, it will be padded with\n     * empty `TableItem` elements.\n     *\n     * If column is longer than other columns, others will be extended to match so no data is lost.\n     *\n     * If called on an empty table with no parameters, it creates a 1x1 table.\n     *\n     * Negative index starts from the end. -1 being the last element.\n     *\n     * @param [column]\n     * @param [index]\n     */\n\n\n    addColumn(column, index) {\n      // if table empty create table with row\n      if (!this.data || this.data.length === 0 || this.data[0].length === 0) {\n        let newData = new Array();\n\n        if (column == null) {\n          newData.push([new TableItem()]);\n        } else {\n          for (let i = 0; i < column.length; i++) {\n            let item = column[i];\n            newData.push([item]);\n          }\n        }\n\n        this.data = newData;\n        return;\n      }\n\n      let rc = this.data.length; // row count\n\n      let ci = this.realColumnIndex(index); // append missing rows\n\n      for (let i = 0; column != null && i < column.length - rc; i++) {\n        this.addRow();\n      }\n\n      rc = this.data.length;\n\n      if (index == null) {\n        // append to end\n        for (let i = 0; i < rc; i++) {\n          let row = this.data[i];\n          row.push(column == null || column[i] == null ? new TableItem() : column[i]);\n        } // update header if not already set by user\n\n\n        if (this.header.length < this.data[0].length) {\n          this.header.push(new TableHeaderItem());\n        }\n      } else {\n        if (index >= this.data[0].length) {\n          // if trying to append\n          ci++;\n        } // insert\n\n\n        for (let i = 0; i < rc; i++) {\n          let row = this.data[i];\n          row.splice(ci, 0, column == null || column[i] == null ? new TableItem() : column[i]);\n        } // update header if not already set by user\n\n\n        if (this.header.length < this.data[0].length) {\n          this.header.splice(ci, 0, new TableHeaderItem());\n        }\n      }\n\n      this.dataChange.emit();\n    }\n    /**\n     * Deletes `index`th column.\n     *\n     * Negative index starts from the end. -1 being the last element.\n     *\n     * @param index\n     */\n\n\n    deleteColumn(index) {\n      const rci = this.realColumnIndex(index);\n      const rowCount = this.data.length;\n\n      for (let i = 0; i < rowCount; i++) {\n        this.data[i].splice(rci, 1);\n      } // update header if not already set by user\n\n\n      if (this.header.length > this.data[0].length) {\n        this.header.splice(rci, 1);\n      }\n\n      this.dataChange.emit();\n    }\n\n    moveColumn(indexFrom, indexTo) {\n      const headerFrom = this.header[indexFrom];\n      this.addColumn(this.column(indexFrom), indexTo);\n      this.deleteColumn(indexFrom + (indexTo < indexFrom ? 1 : 0));\n      this.header[indexTo + (indexTo > indexFrom ? -1 : 0)] = headerFrom;\n    }\n    /**\n     * Sorts the data currently present in the model based on `compare()`\n     *\n     * Direction is set by `ascending` and `descending` properties of `TableHeaderItem`\n     * in `index`th column.\n     *\n     * @param index The column based on which it's sorting\n     */\n\n\n    sort(index) {\n      this.pushRowStateToModelData();\n      this.data.sort((a, b) => (this.header[index].descending ? -1 : 1) * this.header[index].compare(a[index], b[index]));\n      this.popRowStateFromModelData();\n      this.header.forEach(column => column.sorted = false);\n      this.header[index].sorted = true;\n    }\n    /**\n     * Appends `rowsSelected` and `rowsExpanded` info to model data.\n     *\n     * When sorting rows, do this first so information about row selection\n     * gets sorted with the other row info.\n     *\n     * Call `popRowSelectionFromModelData()` after sorting to make everything\n     * right with the world again.\n     */\n\n\n    pushRowStateToModelData() {\n      for (let i = 0; i < this.data.length; i++) {\n        const rowSelectedMark = new TableItem();\n        rowSelectedMark.data = this.rowsSelected[i];\n        this.data[i].push(rowSelectedMark);\n        const rowExpandedMark = new TableItem();\n        rowExpandedMark.data = this.rowsExpanded[i];\n        this.data[i].push(rowExpandedMark);\n        const rowContext = new TableItem();\n        rowContext.data = this.rowsContext[i];\n        this.data[i].push(rowContext);\n        const rowClass = new TableItem();\n        rowClass.data = this.rowsClass[i];\n        this.data[i].push(rowClass);\n      }\n    }\n    /**\n     * Restores `rowsSelected` from data pushed by `pushRowSelectionToModelData()`\n     *\n     * Call after sorting data (if you previously pushed to maintain selection order)\n     * to make everything right with the world again.\n     */\n\n\n    popRowStateFromModelData() {\n      for (let i = 0; i < this.data.length; i++) {\n        this.rowsClass[i] = this.data[i].pop().data;\n        this.rowsContext[i] = this.data[i].pop().data;\n        this.rowsExpanded[i] = !!this.data[i].pop().data;\n        this.rowsSelected[i] = !!this.data[i].pop().data;\n      }\n    }\n    /**\n     * Checks if row is filtered out.\n     *\n     * @param index\n     * @returns true if any of the filters in header filters out the `index`th row\n     */\n\n\n    isRowFiltered(index) {\n      const realIndex = this.realRowIndex(index);\n      return this.header.some((item, i) => item && item.filter(this.row(realIndex)[i]));\n    }\n    /**\n     * Select/deselect `index`th row based on value\n     *\n     * @param index index of the row to select\n     * @param value state to set the row to. Defaults to `true`\n     */\n\n\n    selectRow(index, value = true) {\n      if (this.isRowDisabled(index)) {\n        return;\n      }\n\n      this.rowsSelected[index] = value;\n      this.rowsSelectedChange.emit(index);\n    }\n    /**\n     * Selects or deselects all rows in the model\n     *\n     * @param value state to set all rows to. Defaults to `true`\n     */\n\n\n    selectAll(value = true) {\n      if (this.data.length >= 1 && this.data[0].length >= 1) {\n        for (let i = 0; i < this.rowsSelected.length; i++) {\n          this.selectRow(i, value);\n        }\n      }\n\n      this.selectAllChange.next(value);\n    }\n\n    isRowSelected(index) {\n      return this.rowsSelected[index];\n    }\n    /**\n     * Checks if row is disabled or not.\n     */\n\n\n    isRowDisabled(index) {\n      const row = this.data[index];\n      return !!row.disabled;\n    }\n    /**\n     * Expands/Collapses `index`th row based on value\n     *\n     * @param index index of the row to expand or collapse\n     * @param value expanded state of the row. `true` is expanded and `false` is collapsed\n     */\n\n\n    expandRow(index, value = true) {\n      this.rowsExpanded[index] = value;\n      this.rowsExpandedChange.emit(index);\n    }\n    /**\n     * Gets the true index of a row based on it's relative position.\n     * Like in Python, positive numbers start from the top and\n     * negative numbers start from the bottom.\n     *\n     * @param index\n     */\n\n\n    realRowIndex(index) {\n      return this.realIndex(index, this.data.length);\n    }\n    /**\n     * Gets the true index of a column based on it's relative position.\n     * Like in Python, positive numbers start from the top and\n     * negative numbers start from the bottom.\n     *\n     * @param index\n     */\n\n\n    realColumnIndex(index) {\n      return this.realIndex(index, this.data[0].length);\n    }\n    /**\n     * Generic function to calculate the real index of something.\n     * Used by `realRowIndex()` and `realColumnIndex()`\n     *\n     * @param index\n     * @param length\n     */\n\n\n    realIndex(index, length) {\n      if (index == null) {\n        return length - 1;\n      } else if (index >= 0) {\n        return index >= length ? length - 1 : index;\n      } else {\n        return -index >= length ? 0 : length + index;\n      }\n    }\n\n  }\n\n  /**\n   * The number of models instantiated, used for (among other things) unique id generation\n   */\n  TableModel.COUNT = 0;\n  /**\n   * The table toolbar is reserved for global table actions such as table settings, complex filter, export, or editing table data.\n   *\n   * ## Basic usage\n   *\n   * ```html\n   * <ibm-table-toolbar [model]=\"model\">\n   *\t\t<ibm-table-toolbar-actions>\n   *\t\t\t<button ibmButton=\"primary\">\n   *\t\t\t\tDelete\n   *\t\t\t\t<svg ibmIcon=\"delete\" size=\"16\" class=\"bx--btn__icon\"></svg>\n   *\t\t\t</button>\n   *\t\t\t<button ibmButton=\"primary\">\n   *\t\t\t\tSave\n   *\t\t\t\t<svg ibmIcon=\"save\" size=\"16\" class=\"bx--btn__icon\"></svg>\n   *\t\t\t</button>\n   *\t\t\t<button ibmButton=\"primary\">\n   *\t\t\t\tDownload\n   *\t\t\t\t<svg ibmIcon=\"download\" size=\"16\" class=\"bx--btn__icon\"></svg>\n   *\t\t\t</button>\n   *\t\t</ibm-table-toolbar-actions>\n   *\t\t\t<ibm-table-toolbar-content>\n   *\t\t\t<ibm-table-toolbar-search [expandable]=\"true\"></ibm-table-toolbar-search>\n   *\t\t\t<button ibmButton=\"toolbar-action\">\n   *\t\t\t\t<svg ibmIcon=\"settings\" size=\"16\" class=\"bx--toolbar-action__icon\"></svg>\n   *\t\t\t</button>\n   *\t\t\t<button ibmButton=\"primary\" size=\"sm\">\n   *\t\t\t\tPrimary Button\n   *\t\t\t\t<svg ibmIcon=\"add\" size=\"20\" class=\"bx--btn__icon\"></svg>\n   *\t\t\t</button>\n   *\t\t</ibm-table-toolbar-content>\n   *\t</ibm-table-toolbar>\n   * ```\n   *\n   */\n\n  return TableModel;\n})();\nlet TableToolbar = /*#__PURE__*/(() => {\n  class TableToolbar {\n    constructor(i18n) {\n      this.i18n = i18n;\n      this.size = \"md\";\n      this.cancel = new EventEmitter();\n      this.actionBarLabel = this.i18n.getOverridable(\"TABLE_TOOLBAR.ACTION_BAR\");\n      this._cancelText = this.i18n.getOverridable(\"TABLE_TOOLBAR.CANCEL\");\n      this._batchTextLegacy = this.i18n.getOverridable(\"TABLE_TOOLBAR.BATCH_TEXT\");\n      this._batchTextSingle = this.i18n.getOverridable(\"TABLE_TOOLBAR.BATCH_TEXT_SINGLE\");\n      this._batchTextMultiple = this.i18n.getOverridable(\"TABLE_TOOLBAR.BATCH_TEXT_MULTIPLE\");\n    }\n\n    set batchText(value) {\n      if (typeof value === \"object\") {\n        this._batchTextSingle.override(value.SINGLE);\n\n        this._batchTextMultiple.override(value.MULTIPLE);\n      } else {\n        // For compatibility with old code\n        this._batchTextLegacy.override(value);\n      }\n    }\n\n    set ariaLabel(value) {\n      this.actionBarLabel.override(value.ACTION_BAR);\n    }\n\n    set cancelText(value) {\n      this._cancelText.override(value.CANCEL);\n    }\n\n    get cancelText() {\n      return {\n        CANCEL: this._cancelText.value\n      };\n    }\n\n    get count() {\n      return this.model.totalDataLength > 0 ? this.model.rowsSelected.reduce((previous, current) => previous + (current ? 1 : 0), 0) : 0;\n    }\n\n    get selected() {\n      return this.model.totalDataLength > 0 ? this.model.rowsSelected.some(item => item) : false;\n    }\n\n    onCancel() {\n      this.model.selectAll(false);\n      this.cancel.emit();\n    }\n\n  }\n\n  TableToolbar.ɵfac = function TableToolbar_Factory(t) {\n    return new (t || TableToolbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableToolbar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableToolbar,\n    selectors: [[\"ibm-table-toolbar\"]],\n    inputs: {\n      size: \"size\",\n      batchText: \"batchText\",\n      ariaLabel: \"ariaLabel\",\n      cancelText: \"cancelText\",\n      model: \"model\"\n    },\n    outputs: {\n      cancel: \"cancel\"\n    },\n    ngContentSelectors: _c4,\n    decls: 3,\n    vars: 4,\n    consts: [[1, \"bx--table-toolbar\", 3, \"ngClass\"], [\"class\", \"bx--batch-actions\", 3, \"ngClass\", 4, \"ngIf\"], [1, \"bx--batch-actions\", 3, \"ngClass\"], [1, \"bx--action-list\"], [\"ibmButton\", \"primary\", 1, \"bx--batch-summary__cancel\", 3, \"tabindex\", \"click\"], [1, \"bx--batch-summary\"], [\"class\", \"bx--batch-summary__para\", 4, \"ngIf\"], [1, \"bx--batch-summary__para\"], [4, \"ngIf\", \"ngIfElse\"], [\"batchTextBlock\", \"\"], [4, \"ngIf\"]],\n    template: function TableToolbar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c2);\n        ɵngcc0.ɵɵelementStart(0, \"section\", 0);\n        ɵngcc0.ɵɵtemplate(1, TableToolbar_div_1_Template, 9, 11, \"div\", 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(2, _c3, ctx.size === \"sm\"));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, ɵngcc3.Button],\n    pipes: [ɵngcc2.AsyncPipe, ɵngcc1.ReplacePipe],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableToolbar;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableToolbarActions = /*#__PURE__*/(() => {\n  class TableToolbarActions {}\n\n  TableToolbarActions.ɵfac = function TableToolbarActions_Factory(t) {\n    return new (t || TableToolbarActions)();\n  };\n\n  TableToolbarActions.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableToolbarActions,\n    selectors: [[\"ibm-table-toolbar-actions\"]],\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 0,\n    template: function TableToolbarActions_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TableToolbarActions;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableToolbarSearch = /*#__PURE__*/(() => {\n  class TableToolbarSearch extends Search {\n    constructor() {\n      super(...arguments);\n      this.tableSearch = true;\n      this.hostClass = true;\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        if (this.value) {\n          this.openSearch();\n        }\n      });\n    }\n\n  }\n\n  TableToolbarSearch.ɵfac = /*@__PURE__*/function () {\n    let ɵTableToolbarSearch_BaseFactory;\n    return function TableToolbarSearch_Factory(t) {\n      return (ɵTableToolbarSearch_BaseFactory || (ɵTableToolbarSearch_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TableToolbarSearch)))(t || TableToolbarSearch);\n    };\n  }();\n\n  TableToolbarSearch.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableToolbarSearch,\n    selectors: [[\"ibm-table-toolbar-search\"]],\n    hostVars: 2,\n    hostBindings: function TableToolbarSearch_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--toolbar-content\", ctx.hostClass);\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: TableToolbarSearch,\n      multi: true\n    }]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 7,\n    vars: 20,\n    consts: [[\"role\", \"search\", \"tabindex\", \"0\", 1, \"bx--search\", 3, \"ngClass\", \"click\"], [1, \"bx--label\", 3, \"for\"], [\"class\", \"bx--search-input\", 4, \"ngIf\", \"ngIfElse\"], [\"enableInput\", \"\"], [\"class\", \"bx--search-close\", 3, \"ngClass\", \"title\", \"click\", 4, \"ngIf\"], [1, \"bx--search-input\"], [1, \"bx--search-input\", 3, \"type\", \"id\", \"value\", \"autocomplete\", \"placeholder\", \"disabled\", \"required\", \"input\", \"keyup.enter\"], [\"input\", \"\"], [\"class\", \"bx--toolbar-search__btn\", \"aria-label\", \"Open search\", 3, \"click\", 4, \"ngIf\"], [\"ibmIcon\", \"search\", \"class\", \"bx--search-magnifier-icon\", \"size\", \"16\", 4, \"ngIf\"], [\"aria-label\", \"Open search\", 1, \"bx--toolbar-search__btn\", 3, \"click\"], [\"ibmIcon\", \"search\", \"size\", \"16\", 1, \"bx--search-magnifier-icon\"], [1, \"bx--search-close\", 3, \"ngClass\", \"title\", \"click\"], [1, \"bx--visually-hidden\"], [\"ibmIcon\", \"close\", \"size\", \"16\"]],\n    template: function TableToolbarSearch_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"click\", function TableToolbarSearch_Template_div_click_0_listener() {\n          return ctx.openSearch();\n        });\n        ɵngcc0.ɵɵelementStart(1, \"label\", 1);\n        ɵngcc0.ɵɵtext(2);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(3, TableToolbarSearch_div_3_Template, 1, 0, \"div\", 2);\n        ɵngcc0.ɵɵtemplate(4, TableToolbarSearch_ng_template_4_Template, 4, 9, \"ng-template\", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵtemplate(6, TableToolbarSearch_button_6_Template, 4, 5, \"button\", 4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(5);\n\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunctionV(7, _c7, [ctx.size === \"sm\", ctx.size === \"md\", ctx.size === \"xl\", ctx.theme === \"light\", ctx.skeleton, ctx.expandable && !ctx.tableSearch, ctx.expandable && !ctx.tableSearch && ctx.active, ctx.toolbar && !ctx.expandable, ctx.toolbar && !ctx.expandable && ctx.active, ctx.tableSearch && !ctx.expandable, ctx.tableSearch && ctx.expandable, ctx.tableSearch && ctx.expandable && ctx.active]));\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"for\", ctx.id);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate(ctx.label);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.skeleton)(\"ngIfElse\", _r1);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.tableSearch || !ctx.toolbar);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, ɵngcc4.IconDirective],\n    encapsulation: 2\n  });\n  return TableToolbarSearch;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableToolbarContent = /*#__PURE__*/(() => {\n  class TableToolbarContent {\n    constructor() {\n      this.class = true;\n    }\n\n  }\n\n  TableToolbarContent.ɵfac = function TableToolbarContent_Factory(t) {\n    return new (t || TableToolbarContent)();\n  };\n\n  TableToolbarContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableToolbarContent,\n    selectors: [[\"ibm-table-toolbar-content\"]],\n    hostVars: 2,\n    hostBindings: function TableToolbarContent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--toolbar-content\", ctx.class);\n      }\n    },\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 0,\n    template: function TableToolbarContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TableToolbarContent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableContainer = /*#__PURE__*/(() => {\n  class TableContainer {\n    constructor() {\n      this.containerClass = true;\n    }\n\n  }\n\n  TableContainer.ɵfac = function TableContainer_Factory(t) {\n    return new (t || TableContainer)();\n  };\n\n  TableContainer.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableContainer,\n    selectors: [[\"ibm-table-container\"]],\n    hostVars: 2,\n    hostBindings: function TableContainer_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--data-table-container\", ctx.containerClass);\n      }\n    },\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 0,\n    template: function TableContainer_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block }\"]\n  });\n  return TableContainer;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeader = /*#__PURE__*/(() => {\n  class TableHeader {\n    constructor() {\n      this.headerClass = true;\n      this.displayStyle = \"block\";\n    }\n\n  }\n\n  TableHeader.ɵfac = function TableHeader_Factory(t) {\n    return new (t || TableHeader)();\n  };\n\n  TableHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableHeader,\n    selectors: [[\"ibm-table-header\"]],\n    hostVars: 4,\n    hostBindings: function TableHeader_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.displayStyle);\n        ɵngcc0.ɵɵclassProp(\"bx--data-table-header\", ctx.headerClass);\n      }\n    },\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 0,\n    template: function TableHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TableHeader;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeaderTitle = /*#__PURE__*/(() => {\n  class TableHeaderTitle {\n    constructor() {\n      this.titleClass = true;\n      this.role = \"caption\";\n    }\n\n  }\n\n  TableHeaderTitle.ɵfac = function TableHeaderTitle_Factory(t) {\n    return new (t || TableHeaderTitle)();\n  };\n\n  TableHeaderTitle.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TableHeaderTitle,\n    selectors: [[\"\", \"ibmTableHeaderTitle\", \"\"]],\n    hostVars: 3,\n    hostBindings: function TableHeaderTitle_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role);\n        ɵngcc0.ɵɵclassProp(\"bx--data-table-header__title\", ctx.titleClass);\n      }\n    }\n  });\n  return TableHeaderTitle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeadCellLabel = /*#__PURE__*/(() => {\n  class TableHeadCellLabel {\n    constructor() {\n      this.baseClass = true;\n    }\n\n  }\n\n  TableHeadCellLabel.ɵfac = function TableHeadCellLabel_Factory(t) {\n    return new (t || TableHeadCellLabel)();\n  };\n\n  TableHeadCellLabel.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TableHeadCellLabel,\n    selectors: [[\"\", \"ibmTableHeadCellLabel\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableHeadCellLabel_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--table-header-label\", ctx.baseClass);\n      }\n    }\n  });\n  return TableHeadCellLabel;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeaderDescription = /*#__PURE__*/(() => {\n  class TableHeaderDescription {\n    constructor() {\n      this.descriptionClass = true;\n      this.role = \"summary\";\n    }\n\n  }\n\n  TableHeaderDescription.ɵfac = function TableHeaderDescription_Factory(t) {\n    return new (t || TableHeaderDescription)();\n  };\n\n  TableHeaderDescription.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TableHeaderDescription,\n    selectors: [[\"\", \"ibmTableHeaderDescription\", \"\"]],\n    hostVars: 3,\n    hostBindings: function TableHeaderDescription_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role);\n        ɵngcc0.ɵɵclassProp(\"bx--data-table-header__description\", ctx.descriptionClass);\n      }\n    }\n  });\n  return TableHeaderDescription;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet ExpandedRowHover = /*#__PURE__*/(() => {\n  class ExpandedRowHover {\n    addHoverClass(event) {\n      event.target.previousElementSibling.classList.add(\"bx--expandable-row--hover\");\n    }\n\n    removeHoverClass(event) {\n      event.target.previousElementSibling.classList.remove(\"bx--expandable-row--hover\");\n    }\n\n  }\n\n  ExpandedRowHover.ɵfac = function ExpandedRowHover_Factory(t) {\n    return new (t || ExpandedRowHover)();\n  };\n\n  ExpandedRowHover.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ExpandedRowHover,\n    selectors: [[\"\", \"ibmExpandedRowHover\", \"\"]],\n    hostBindings: function ExpandedRowHover_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mouseenter\", function ExpandedRowHover_mouseenter_HostBindingHandler($event) {\n          return ctx.addHoverClass($event);\n        })(\"mouseleave\", function ExpandedRowHover_mouseleave_HostBindingHandler($event) {\n          return ctx.removeHoverClass($event);\n        });\n      }\n    }\n  });\n  return ExpandedRowHover;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * `DataGridInteractionModel` provides centralized control over arbitrary 2d grids, following the w3 specs.\n *\n * Refs:\n *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html\n *  - https://www.w3.org/TR/wai-aria-practices/#grid\n *\n * Example usage (taken from `table.component`):\n```typescript\n// a standard HTML table\nconst table = this.elementRef.nativeElement.querySelector(\"table\") as HTMLTableElement;\n\n// `TableDomAdapter` implements `TableAdapter` and provides a consistent interface to query rows and columns in a table\nconst tableAdapter = new TableDomAdapter(table);\n\n// the keydown events that we'll use for keyboard navigation of the table\nconst keydownEventStream = fromEvent<KeyboardEvent>(table, \"keydown\");\n\n// the click events we'll use to ensure focus is updated correctly on click\nconst clickEventStream = fromEvent<MouseEvent>(table, \"click\");\n\n// the `DataGridInteractionModel` instance!\nthis.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);\n\n// subscribe to the combined position updates\nthis.interactionModel.position.subscribe(event => {\n    const [currentRow, currentColumn] = event.current;\n    const [previousRow, previousColumn] = event.previous;\n\n    // query the TableAdapter for the cell at the current row and column ...\n    const currentElement = tableAdapter.getCell(currentRow, currentColumn);\n    // ... and make it focusable it\n    Table.setTabIndex(currentElement, 0);\n\n    // if the model has just initialized don't focus or reset anything\n    if (previousRow === -1 || previousColumn === -1) { return; }\n\n    // query the TableAdapter for the cell at the previous row and column ...\n    const previousElement = tableAdapter.getCell(previousRow, previousColumn);\n    // ... and make it unfocusable (now there is only a single focusable cell)\n    Table.setTabIndex(previousElement, -1);\n\n    // finally, focus the current cell (skipped during initilzation)\n    Table.focus(currentElement);\n});\n```\n */\n\n\nclass DataGridInteractionModel {\n  /**\n   * `DataGridInteractionModel` requires knowledge of events, and a representation of your table/grid to be useful.\n   *\n   * @param keyboardEventStream an Observable of KeyboardEvents. Should be scoped to the table container.\n   * @param clickEventStream an Observable of ClickEvents. should only include clicks that take action on items known by the TableAdapter\n   * @param tableAdapter an instance of a concrete class that implements TableAdapter. The standard carbon table uses TableDomAdapter\n   */\n  constructor(keyboardEventStream, clickEventStream, tableAdapter) {\n    this.keyboardEventStream = keyboardEventStream;\n    this.clickEventStream = clickEventStream;\n    this.tableAdapter = tableAdapter;\n    /**\n     * Internal subject to handle changes in row\n     */\n\n    this.rowSubject = new BehaviorSubject({\n      current: 0,\n      previous: -1\n    });\n    /**\n     * Internal subject to handle changes in column\n     */\n\n    this.columnSubject = new BehaviorSubject({\n      current: 0,\n      previous: -1\n    });\n    this.rowIndex = this.rowSubject.asObservable();\n    this.columnIndex = this.columnSubject.asObservable();\n    this.position = combineLatest(this.rowIndex, this.columnIndex).pipe(map(positions => {\n      const [row, column] = positions;\n      return {\n        current: [row.current, column.current],\n        previous: [row.previous, column.previous]\n      };\n    }));\n    this.keyboardEventStream.subscribe(this.handleKeyboardEvent.bind(this));\n    this.clickEventStream.subscribe(this.handleClickEvent.bind(this));\n  }\n  /**\n   * The latest value emitted by the rowSubject\n   */\n\n\n  get currentRow() {\n    return this.rowSubject.getValue().current;\n  }\n  /**\n   * The latest value emitted by the columnSubject\n   */\n\n\n  get currentColumn() {\n    return this.columnSubject.getValue().current;\n  }\n  /**\n   * The last column as reported by the adapter\n   */\n\n\n  get lastColumn() {\n    return this.tableAdapter.lastColumnIndex;\n  }\n  /**\n   * The last row as reported by the adapter\n   */\n\n\n  get lastRow() {\n    return this.tableAdapter.lastRowIndex;\n  }\n  /**\n   * Handles moving the position according to the w3 datagrid navigation specs\n   *\n   * Refs:\n   *  - https://www.w3.org/TR/wai-aria-practices/examples/grid/dataGrids.html\n   *  - https://www.w3.org/TR/wai-aria-practices/#grid\n   *\n   * @param event the KeyboardEvent to handle\n   */\n\n\n  handleKeyboardEvent(event) {\n    const currentCell = this.tableAdapter.getCell(this.currentRow, this.currentColumn);\n    let currentColumn = this.tableAdapter.findColumnIndex(currentCell);\n    let currentRow = this.tableAdapter.findRowIndex(currentCell);\n\n    switch (event.key) {\n      case \"Right\": // IE specific value\n\n      case \"ArrowRight\":\n        event.preventDefault(); // add the colspan since findColumnIndex will return the\n        // first column containing the cell (of N columns it may span)\n        // and we want to navigate to the next \"real\" column\n\n        this.goToColumn(currentColumn + currentCell.colSpan);\n        break;\n\n      case \"Left\": // IE specific value\n\n      case \"ArrowLeft\":\n        event.preventDefault(); // we only ever need to subtract 1 from the column, since findColumnIndex returns the\n        // first of N columns containing the cell\n\n        this.goToColumn(currentColumn - 1);\n        break;\n\n      case \"Down\": // IE specific value\n\n      case \"ArrowDown\":\n        event.preventDefault();\n        this.goToRow(currentRow + currentCell.rowSpan);\n        break;\n\n      case \"Up\": // IE specific value\n\n      case \"ArrowUp\":\n        event.preventDefault();\n        this.goToRow(currentRow - 1);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n\n        if (event.ctrlKey) {\n          this.goTo({\n            row: 0,\n            column: 0\n          });\n        } else {\n          this.goToColumn(0);\n        }\n\n        break;\n\n      case \"End\":\n        event.preventDefault();\n\n        if (event.ctrlKey) {\n          this.goTo({\n            row: this.lastRow,\n            column: this.lastColumn\n          });\n        } else {\n          this.goToColumn(this.lastColumn);\n        }\n\n        break;\n    }\n  }\n  /**\n   * Handles moving the position to the clicked cell\n   *\n   * @param event the MouseEvent to handle\n   */\n\n\n  handleClickEvent(event) {\n    const cell = event.target.closest(\"td, th\");\n    const [rowIndex, cellIndex] = this.tableAdapter.findIndex(cell);\n    this.goTo({\n      row: rowIndex,\n      column: cellIndex\n    });\n  }\n  /**\n   * Jump to a specific column without changing the row\n   *\n   * @param index column to jump to\n   */\n\n\n  goToColumn(index) {\n    if (index > this.lastColumn || index < 0) {\n      return;\n    }\n\n    this.goTo({\n      row: this.currentRow,\n      column: index\n    });\n  }\n  /**\n   * Jump to a specific row without changing the column\n   *\n   * @param index row to jump to\n   */\n\n\n  goToRow(index) {\n    if (index > this.lastRow || index < 0) {\n      return;\n    }\n\n    this.goTo({\n      row: index,\n      column: this.currentColumn\n    });\n  }\n  /**\n   * Jump to the specified row and column\n   *\n   * @param param0 an object that contains `row` and `column` properties\n   */\n\n\n  goTo({\n    row,\n    column\n  }) {\n    this.rowSubject.next({\n      current: row,\n      previous: this.currentRow\n    });\n    this.columnSubject.next({\n      current: column,\n      previous: this.currentColumn\n    });\n  }\n  /**\n   * Convenience method to reset the tab indexes on a standard carbon table.\n   * For custom tables you may want to reset the indexes manually and simply call `.reset()`\n   */\n\n\n  resetTabIndexes(newTabIndex = -1) {\n    for (let i = 0; i < this.tableAdapter.lastRowIndex; i++) {\n      const row = this.tableAdapter.getRow(i);\n\n      for (const cell of Array.from(row.cells)) {\n        const tabbableElements = getFocusElementList(cell, tabbableSelectorIgnoreTabIndex);\n        tabbableElements.forEach(node => node.tabIndex = newTabIndex);\n        cell.tabIndex = newTabIndex;\n      }\n    }\n\n    this.reset();\n  }\n  /**\n   * Resets the models focus position\n   */\n\n\n  reset() {\n    this.rowSubject.next({\n      current: 0,\n      previous: -1\n    });\n    this.columnSubject.next({\n      current: 0,\n      previous: -1\n    });\n  }\n\n}\n/**\n * An abstract class that represents a cell in a table\n */\n\n\nclass TableCellAdapter {}\n/**\n * An abstract class that represents a row in a table\n */\n\n\nclass TableRowAdapter {}\n/**\n * An abstract representation of a table that provides\n * a standard interface to query 2d tables for cell and row information.\n */\n\n\nclass TableAdapter {\n  /**\n   * The last accessible column in the table\n   */\n  get lastColumnIndex() {\n    return;\n  }\n  /**\n   * The last accessible row in the table\n   */\n\n\n  get lastRowIndex() {\n    return;\n  }\n  /**\n   * Returns a cell from the table\n   *\n   * @param row index of the row\n   * @param column index of the column\n   */\n\n\n  getCell(row, column) {\n    return;\n  }\n  /**\n   * Returns a row from the table\n   *\n   * @param column index of the column\n   */\n\n\n  getColumn(column) {\n    return;\n  }\n  /**\n   * Returns a row from the table\n   *\n   * @param row index of the row\n   */\n\n\n  getRow(row) {\n    return;\n  }\n  /**\n   * Finds the column index of a given cell\n   *\n   * @param cell the cell to search for\n   */\n\n\n  findColumnIndex(cell) {\n    return;\n  }\n  /**\n   * Finds the row index of a given cell\n   *\n   * @param cell the cell to search for\n   */\n\n\n  findRowIndex(cell) {\n    return;\n  }\n  /**\n   * Finds the row and column index of a given cell\n   *\n   * @param cell the cell to search for\n   * @returns a tuple that follows the `[row, column]` convention\n   */\n\n\n  findIndex(cell) {\n    return;\n  }\n\n}\n\nvar TableDomSpanDirection = /*#__PURE__*/(() => {\n  (function (TableDomSpanDirection) {\n    TableDomSpanDirection[\"colSpan\"] = \"colSpan\";\n    TableDomSpanDirection[\"rowSpan\"] = \"rowSpan\";\n  })(TableDomSpanDirection || (TableDomSpanDirection = {}));\n\n  return TableDomSpanDirection;\n})();\n\n/**\n * A concrete implementation of `TableAdapter`\n *\n * Provides standard and consistent access to table cells and rows\n */\nclass TableDomAdapter {\n  /**\n   * `TableDomAdapter` works on a normal HTML table structure.\n   * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.\n   *\n   * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.\n   *\n   * @param tableElement the root HTML table element.\n   */\n  constructor(tableElement) {\n    this.tableElement = tableElement;\n  }\n  /**\n   * The last accessible column in the table\n   */\n\n\n  get lastColumnIndex() {\n    return this.getRealRowLength(this.tableElement.rows[0]);\n  }\n  /**\n   * The last accessible row in the table\n   */\n\n\n  get lastRowIndex() {\n    return this.tableElement.rows.length - 1;\n  }\n  /**\n   * Returns a cell from the table taking colspans in to account.\n   *\n   * @param row index of the row\n   * @param column index of the column\n   */\n\n\n  getCell(row, column) {\n    const col = this.getColumn(column);\n    return this.findCellInColumn(col, row).cell;\n  }\n  /**\n   * Returns a column from the table, using the `id` and `headers` attributes\n   *\n   * See here for more detail these attributes: https://www.w3.org/TR/WCAG20-TECHS/H43.html\n   *\n   * @param column the index of the column\n   */\n\n\n  getColumn(column) {\n    const firstHeader = Array.from(this.tableElement.rows[0].cells);\n    const {\n      cell: header,\n      realIndex: realColumnIndex\n    } = this.findCellInRow(firstHeader, column);\n    const linkedCells = [];\n\n    for (let i = 1; i < this.tableElement.rows.length; i++) {\n      const row = this.tableElement.rows[i]; // query for any cells that are linked to the given header id\n      // `~=` matches values in space separated lists - so `[headers~='foo']` would match `headers=\"foo bar\"` and `headers=\"foo\"`\n      // but not `headers=\"bar\"` or `headers=\"bar baz\"`\n\n      const linkedRowCells = row.querySelectorAll(`[headers~='${header.id}']`); // if we have more than one cell, get the one that is closest to the column\n\n      if (linkedRowCells.length > 1) {\n        const {\n          cell\n        } = this.findCellInRow(Array.from(linkedRowCells), column - realColumnIndex);\n        linkedCells.push(cell);\n      } else if (linkedRowCells[0]) {\n        linkedCells.push(linkedRowCells[0]);\n      }\n    } // return an empty array if we can't find any linked cells\n    // returning anything else would be a lie\n\n\n    if (!linkedCells) {\n      return [];\n    }\n\n    return [header, ...linkedCells];\n  }\n  /**\n   * Returns a row from the table\n   *\n   * @param row index of the row\n   */\n\n\n  getRow(row) {\n    return this.tableElement.rows[row];\n  }\n  /**\n   * Finds the column index of a given cell\n   *\n   * @param cell the cell to search for\n   */\n\n\n  findColumnIndex(cell) {\n    const row = this.getRow(this.findRowIndex(cell));\n\n    if (!row) {\n      return;\n    } // if the cell has linked headers we can do a more accurate lookup\n\n\n    if (cell && cell.headers) {\n      const ids = cell.headers.split(\" \");\n      const headerRows = Array.from(this.tableElement.tHead.rows);\n      const indexes = []; // start from the last row and work up\n\n      for (const headerRow of headerRows.reverse()) {\n        const headerCells = Array.from(headerRow.cells);\n        const header = headerCells.find(headerCell => ids.includes(headerCell.id)); // if we have a matching header, find it's index (adjusting for colspans)\n\n        if (header) {\n          // this is borrowed from below\n          let cellIndex = 0;\n\n          for (const c of headerCells) {\n            if (c === header) {\n              break;\n            }\n\n            cellIndex += c.colSpan;\n          }\n\n          indexes.push(cellIndex);\n        }\n      } // sort the indexes largest to smallest to find the closest matching header index\n\n\n      const firstIndex = indexes.sort((a, b) => b - a)[0]; // search the row for cells that share the header\n\n      let similarCells = [];\n\n      for (const id of ids) {\n        // there's no selector that will match two space separated lists,\n        // so we have to iterate through the ids and query the row for each\n        const rowCells = Array.from(row.querySelectorAll(`[headers~='${id}']`));\n\n        for (const rowCell of rowCells) {\n          // only keep one set of cells\n          if (!similarCells.includes(rowCell)) {\n            similarCells.push(rowCell);\n          }\n        }\n      } // DOM order is not preserved, so we have to sort the row\n\n\n      similarCells = similarCells.sort((a, b) => a.cellIndex - b.cellIndex); // return the header index plus any adjustment within that headers column\n\n      return firstIndex + similarCells.indexOf(cell);\n    } // fallback if the cell isn't linked to any headers\n\n\n    let cellIndex = 0;\n\n    for (const c of Array.from(row.cells)) {\n      if (c === cell) {\n        break;\n      }\n\n      cellIndex += c.colSpan;\n    }\n\n    return cellIndex;\n  }\n  /**\n   * Finds the row index of a given cell\n   *\n   * @param cell the cell to search for\n   */\n\n\n  findRowIndex(cell) {\n    for (const row of Array.from(this.tableElement.rows)) {\n      if (row.contains(cell)) {\n        return row.rowIndex;\n      }\n    }\n  }\n  /**\n   * Finds the row and column index of a given cell\n   *\n   * @param cell the cell to search for\n   * @returns a tuple that follows the `[row, column]` convention\n   */\n\n\n  findIndex(cell) {\n    return [this.findRowIndex(cell), this.findColumnIndex(cell)];\n  }\n  /**\n   * Helper function that returns the \"real\" length of a row.\n   * Only accurate with regard to colspans (though that's sufficient for it's uses here)\n   *\n   * TODO: Take rowSpan into account\n   *\n   * @param row the row to get the length of\n   */\n\n\n  getRealRowLength(row) {\n    // start at -1 since the colspans will sum to 1 index greater than the total\n    return Array.from(row.cells).reduce((count, cell) => count + cell.colSpan, -1);\n  }\n  /**\n   * Finds a cell and it's real index given an array of cells, a target index, and the spanning direction\n   *\n   * @param cells An array of cells to search\n   * @param targetIndex The index we think the cell is located at\n   * @param spanDirection The direction of the cell spans. Should be `\"colSpan\"` for a row and `\"rowSpan\"` for a column\n   */\n\n\n  findCell(cells, targetIndex, spanDirection) {\n    // rows/cols can have fewer total cells than the actual table\n    // the model pretends all rows/cols behave the same (with col/row spans > 1 being N cells long)\n    // this maps that view to the HTML view (col/row spans > 1 are one element, so the array is shorter)\n    let realIndex = 0; // i is only used for iterating the cells\n\n    for (let i = 0; i < targetIndex;) {\n      // skip the next N cells\n      i += cells[realIndex][spanDirection]; // don't bump realIndex if i now exceeds the cell we're shooting for\n\n      if (i > targetIndex) {\n        break;\n      } // finally, increment realIndex (to keep it generally in step with i)\n\n\n      realIndex++;\n    }\n\n    return {\n      cell: cells[realIndex],\n      realIndex\n    };\n  }\n  /**\n   * Helper method around `findCell`, searches based on a row of cells\n   *\n   * @param row the row of elements to search\n   * @param index the index of the element\n   */\n\n\n  findCellInRow(row, index) {\n    return this.findCell(row, index, TableDomSpanDirection.colSpan);\n  }\n  /**\n   * Helper method around `findCell`, searches based on a column of cells\n   *\n   * @param col the column of elements to search\n   * @param index the index of the element\n   */\n\n\n  findCellInColumn(col, index) {\n    return this.findCell(col, index, TableDomSpanDirection.rowSpan);\n  }\n\n}\n/**\n * Build your table with this component by extending things that differ from default.\n *\n * [See demo](../../?path=/story/components-table--basic)\n *\n * Instead of the usual write-your-own-html approach you had with `<table>`,\n * carbon table uses model-view-controller approach.\n *\n * Here, you create a view (with built-in controller) and provide it a model.\n * Changes you make to the model are reflected in the view. Provide same model you use\n * in the table to the `<ibm-pagination>` components.\n * They provide a different view over the same data.\n *\n * ## Basic usage\n *\n * ```html\n * <ibm-table [model]=\"model\"></ibm-table>\n * ```\n *\n * ```typescript\n * public model = new TableModel();\n *\n * this.model.data = [\n * \t[new TableItem({data: \"asdf\"}), new TableItem({data: \"qwer\"})],\n * \t[new TableItem({data: \"csdf\"}), new TableItem({data: \"zwer\"})],\n * \t[new TableItem({data: \"bsdf\"}), new TableItem({data: \"swer\"})],\n * \t[new TableItem({data: \"csdf\"}), new TableItem({data: \"twer\"})]\n * ];\n * ```\n *\n * ## Customization\n *\n * If you have custom data in your table, you need a way to display it. You can do that\n * by providing a template to `TableItem`.\n *\n * ```html\n * <ng-template #customTableItemTemplate let-data=\"data\">\n * \t<a [routerLink]=\"data.link\">{{data.name}} {{data.surname}}</a>\n * </ng-template>\n * ```\n *\n * ```typescript\n * customTableItemTemplate: TemplateRef<any>;\n *\n * this.customModel.data = [\n * \t[new TableItem({data: \"asdf\"}), new TableItem({data: {name: \"Lessy\", link: \"/table\"}, template: this.customTableItemTemplate})],\n * \t[new TableItem({data: \"csdf\"}), new TableItem({data: \"swer\"})],\n * \t[new TableItem({data: \"bsdf\"}), new TableItem({data: {name: \"Alice\", surname: \"Bob\"}, template: this.customTableItemTemplate})],\n * \t[new TableItem({data: \"csdf\"}), new TableItem({data: \"twer\"})],\n * ];\n * ```\n *\n * ### Sorting and filtering\n *\n * In case you need custom sorting and/or filtering you should subclass `TableHeaderItem`\n * and override needed functions.\n *\n * ```typescript\n * class FilterableHeaderItem extends TableHeaderItem {\n * \t// custom filter function\n * \tfilter(item: TableItem): boolean {\n * \t\tif (typeof item.data === \"string\" && item.data.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||\n * \t\titem.data.name && item.data.name.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0 ||\n * \t\titem.data.surname && item.data.surname.toLowerCase().indexOf(this.filterData.data.toLowerCase()) >= 0) {\n * \t\t\treturn false;\n * \t\t}\n * \t\treturn true;\n * \t}\n *\n * \tset filterCount(n) {}\n * \tget filterCount() {\n * \t\treturn (this.filterData && this.filterData.data && this.filterData.data.length > 0) ? 1 : 0;\n * \t}\n *\n * \t// used for custom sorting\n * \tcompare(one: TableItem, two: TableItem) {\n * \t\tconst stringOne = (one.data.name || one.data.surname || one.data).toLowerCase();\n * \t\tconst stringTwo = (two.data.name || two.data.surname || two.data).toLowerCase();\n *\n * \t\tif (stringOne > stringTwo) {\n * \t\t\treturn 1;\n * \t\t} else if (stringOne < stringTwo) {\n * \t\t\treturn -1;\n * \t\t} else {\n * \t\t\treturn 0;\n * \t\t}\n * \t}\n * }\n * ```\n *\n * If you want to do your sorting on the backend or query for sorted data as a result of user\n * clicking the table header, check table [`sort`](#sort) output documentation\n *\n * See `TableHeaderItem` class for more information.\n *\n * ## No data template\n *\n * When table has no data to show, it can show a message you provide it instead.\n *\n * ```html\n * <ibm-table [model]=\"model\">No data.</ibm-table>\n * ```\n *\n * ... will show `No data.` message, but you can get creative and provide any template you want\n * to replace table's default `tbody`.\n *\n * ## Use pagination as table footer\n *\n * ```html\n * <ibm-pagination [model]=\"model\" (selectPage)=\"selectPage($event)\"></ibm-pagination>\n * ```\n *\n * `selectPage()` function should fetch the data from backend, create new `data`, apply it to `model.data`,\n * and update `model.currentPage`.\n *\n * If the data your server returns is a two dimensional array of objects, it would look something like this:\n *\n * ```typescript\n * selectPage(page) {\n * \tthis.getPage(page).then((data: Array<Array<any>>) => {\n * \t\t// set the data and update page\n * \t\tthis.model.data = this.prepareData(data);\n * \t\tthis.model.currentPage = page;\n * \t});\n * }\n *\n * protected prepareData(data: Array<Array<any>>) {\n * \t// create new data from the service data\n * \tlet newData = [];\n * \tdata.forEach(dataRow => {\n * \t\tlet row = [];\n * \t\tdataRow.forEach(dataElement => {\n * \t\t\trow.push(new TableItem({\n * \t\t\t\tdata: dataElement,\n * \t\t\t\ttemplate: typeof dataElement === \"string\" ? undefined : this.paginationTableItemTemplate\n * \t\t\t\t// your template can handle all the data types so you don't have to conditionally set it\n * \t\t\t\t// you can also set different templates for different columns based on index\n * \t\t\t}));\n * \t\t});\n * \t\tnewData.push(row);\n * \t});\n * \treturn newData;\n * }\n * ```\n *\n * <example-url>../../iframe.html?id=components-table--basic</example-url>\n */\n\n\nlet Table = /*#__PURE__*/(() => {\n  class Table {\n    /**\n     * Creates an instance of Table.\n     */\n    constructor(elementRef, applicationRef, i18n) {\n      this.elementRef = elementRef;\n      this.applicationRef = applicationRef;\n      this.i18n = i18n;\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      /**\n       * Set to `true` for a loading table.\n       */\n\n      this.skeleton = false;\n      /**\n       * Setting sortable to false will disable all headers including headers which are sortable. Is is\n       * possible to set the sortable state on the header item to disable/enable sorting for only some headers.\n       */\n\n      this.sortable = true;\n      this.noBorder = true;\n      /**\n       * Controls whether to show the selection checkboxes column or not.\n       */\n\n      this.showSelectionColumn = true;\n      /**\n       * Controls whether to enable multiple or single row selection.\n       */\n\n      this.enableSingleSelect = false;\n      /**\n       * Distance (in px) from the bottom that view has to reach before\n       * `scrollLoad` event is emitted.\n       */\n\n      this.scrollLoadDistance = 0;\n      /**\n       * Set to `true` to enable users to resize columns.\n       *\n       * Works for columns with width set in pixels.\n       *\n       */\n\n      this.columnsResizable = false;\n      /**\n       * Set to `true` to enable users to drag and drop columns.\n       *\n       * Changing the column order in table changes table model. Be aware of it when you add additional data\n       * to the model.\n       *\n       */\n\n      this.columnsDraggable = false;\n      /**\n       * Set to `false` to remove table rows (zebra) stripes.\n       */\n\n      this.striped = true;\n      /**\n       * Set to `true` to stick the header to the top of the table\n       */\n\n      this.stickyHeader = false;\n      /**\n       * Emits an index of the column that wants to be sorted.\n       *\n       * If no observers are provided (default), table will attempt to do a simple sort of the data loaded\n       * into the model.\n       *\n       * If an observer is provided, table will not attempt any sorting of its own and it is up to the observer\n       * to sort the table. This is what you typically want if you're using a backend query to get the sorted\n       * data or want to sort data across multiple pages.\n       *\n       * Usage:\n       *\n       * ```typescript\n       * @Component({\n       * \tselector: \"app-table\",\n       * \ttemplate: `\n       * \t\t<ibm-table\n       * \t\t\t[model]=\"model\"\n       * \t\t\t(sort)=\"simpleSort($event)\">\n       * \t\t\tNo data.\n       * \t\t</ibm-table>\n       * \t`\n       * })\n       * export class TableApp implements OnInit, OnChanges {\n       * \t@Input() model = new TableModel();\n       *\n       * \tngOnInit() {\n       * \t\tthis.model.header = [\n       * \t\t\tnew TableHeaderItem({ data: \"Name\" }),\n       * \t\t\tnew TableHeaderItem({ data: \"hwer\" })\n       * \t\t];\n       *\n       * \t\tthis.model.data = [\n       * \t\t\t[new TableItem({ data: \"Name 1\" }), new TableItem({ data: \"qwer\" })],\n       * \t\t\t[new TableItem({ data: \"Name 3\" }), new TableItem({ data: \"zwer\" })],\n       * \t\t\t[new TableItem({ data: \"Name 2\" }), new TableItem({ data: \"swer\" })],\n       * \t\t\t[new TableItem({ data: \"Name 4\" }), new TableItem({data: \"twer\"})],\n       * \t\t\t[new TableItem({ data: \"Name 5\" }), new TableItem({data: \"twer\"})],\n       * \t\t\t[new TableItem({ data: \"Name 6\" }), new TableItem({data: \"twer\"})]\n       * \t\t];\n       * \t}\n       *\n       * \tsimpleSort(index: number) {\n       * \t\t// this function does a simple sort, which is the default for the table and if that's\n       * \t\t// all you want, you don't need to do this.\n       *\n       * \t\t// here you can query your backend and update the model.data based on the result\n       * \t\tif (this.model.header[index].sorted) {\n       * \t\t\t// if already sorted flip sorting direction\n       * \t\t\tthis.model.header[index].ascending = this.model.header[index].descending;\n       * \t\t}\n       * \t\tthis.model.sort(index);\n       * \t}\n       * }\n       * ```\n       */\n\n      this.sort = new EventEmitter();\n      /**\n       * Emits if all rows are selected.\n       *\n       * @param model\n       */\n\n      this.selectAll = new EventEmitter();\n      /**\n       * Emits if all rows are deselected.\n       *\n       * @param model\n       */\n\n      this.deselectAll = new EventEmitter();\n      /**\n       * Emits if a single row is selected.\n       *\n       * @param ({model: this.model, selectedRowIndex: index})\n       */\n\n      this.selectRow = new EventEmitter();\n      /**\n       * Emits if a single row is deselected.\n       *\n       * @param ({model: this.model, deselectedRowIndex: index})\n       */\n\n      this.deselectRow = new EventEmitter();\n      /**\n       * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.\n       */\n\n      this.rowClick = new EventEmitter();\n      /**\n       * Emits when table requires more data to be loaded.\n       */\n\n      this.scrollLoad = new EventEmitter();\n      /**\n       * Controls if all checkboxes are viewed as selected.\n       */\n\n      this.selectAllCheckbox = false;\n      /**\n       * Controls the indeterminate state of the header checkbox.\n       */\n\n      this.selectAllCheckboxSomeSelected = false;\n      this.isColumnDragging = false;\n      this.columnDraggedHoverIndex = -1;\n      this.columnDraggedPosition = \"\";\n      this._isDataGrid = false; // flag to prevent getters/setters from querying the view before it's fully instantiated\n\n      this.isViewReady = false;\n      this.subscriptions = new Subscription();\n      this._expandButtonAriaLabel = this.i18n.getOverridable(\"TABLE.EXPAND_BUTTON\");\n      this._sortDescendingLabel = this.i18n.getOverridable(\"TABLE.SORT_DESCENDING\");\n      this._sortAscendingLabel = this.i18n.getOverridable(\"TABLE.SORT_ASCENDING\");\n      this._checkboxHeaderLabel = this.i18n.getOverridable(\"TABLE.CHECKBOX_HEADER\");\n      this._checkboxRowLabel = this.i18n.getOverridable(\"TABLE.CHECKBOX_ROW\");\n      this._endOfDataText = this.i18n.getOverridable(\"TABLE.END_OF_DATA\");\n      this._scrollTopText = this.i18n.getOverridable(\"TABLE.SCROLL_TOP\");\n      this._filterTitle = this.i18n.getOverridable(\"TABLE.FILTER\");\n    }\n    /**\n     * Creates a skeleton model with a row and column count specified by the user\n     *\n     * Example:\n     *\n     * ```typescript\n     * this.model = Table.skeletonModel(5, 5);\n     * ```\n     */\n\n\n    static skeletonModel(rowCount, columnCount) {\n      const model = new TableModel();\n      let header = new Array();\n      let data = new Array();\n      let row = new Array();\n\n      for (let i = 0; i < columnCount; i++) {\n        header.push(new TableHeaderItem());\n        row.push(new TableItem());\n      }\n\n      for (let i = 0; i < rowCount - 1; i++) {\n        data.push(row);\n      }\n\n      model.header = header;\n      model.data = data;\n      return model;\n    }\n\n    static setTabIndex(element, index) {\n      const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);\n\n      if (element.firstElementChild && element.firstElementChild.classList.contains(\"bx--table-sort\") && focusElementList.length > 0) {\n        focusElementList[0].tabIndex = index;\n      } else {\n        element.tabIndex = index;\n      }\n    }\n\n    static focus(element) {\n      const focusElementList = getFocusElementList(element, tabbableSelectorIgnoreTabIndex);\n\n      if (element.firstElementChild && element.firstElementChild.classList.contains(\"bx--table-sort\") && focusElementList.length > 0) {\n        focusElementList[0].focus();\n      } else {\n        element.focus();\n      }\n    }\n    /**\n     * `TableModel` with data the table is to display.\n     */\n\n\n    set model(m) {\n      if (this._model) {\n        this.subscriptions.unsubscribe(); // Need to create a new subscription instance here because unsubscribing prevents any new subscriptions\n        // from being added for some reason. When a new model is set, none of the subscriptions would exist.\n\n        this.subscriptions = new Subscription();\n      }\n\n      this._model = m;\n\n      const rowsChange = this._model.rowsSelectedChange.subscribe(() => this.updateSelectAllCheckbox());\n\n      const dataChange = this._model.dataChange.subscribe(() => {\n        if (this.isDataGrid) {\n          this.resetTabIndex();\n        }\n\n        this.updateSelectAllCheckbox();\n      });\n\n      this.subscriptions.add(rowsChange);\n      this.subscriptions.add(dataChange);\n\n      if (this.isDataGrid) {\n        const expandedChange = this._model.rowsExpandedChange.subscribe(() => {\n          // Allows the expanded row to have a focus state when it exists in the DOM\n          setTimeout(() => {\n            const expandedRows = this.elementRef.nativeElement.querySelectorAll(\".bx--expandable-row:not(.bx--parent-row)\");\n            Array.from(expandedRows).forEach(row => {\n              if (row.firstElementChild.tabIndex === undefined || row.firstElementChild.tabIndex !== -1) {\n                row.firstElementChild.tabIndex = -1;\n              }\n            });\n          });\n        });\n\n        this.subscriptions.add(expandedChange);\n      }\n    }\n\n    get model() {\n      return this._model;\n    }\n    /**\n     * Set to `true` for a data grid with keyboard interactions.\n     */\n\n\n    set isDataGrid(value) {\n      this._isDataGrid = value;\n\n      if (this.isViewReady) {\n        if (value) {\n          this.enableDataGridInteractions();\n        } else {\n          this.disableDataGridInteractions();\n        }\n      }\n    }\n\n    get isDataGrid() {\n      return this._isDataGrid;\n    }\n\n    set expandButtonAriaLabel(value) {\n      this._expandButtonAriaLabel.override(value);\n    }\n\n    get expandButtonAriaLabel() {\n      return this._expandButtonAriaLabel.value;\n    }\n\n    set sortDescendingLabel(value) {\n      this._sortDescendingLabel.override(value);\n    }\n\n    get sortDescendingLabel() {\n      return this._sortDescendingLabel.value;\n    }\n\n    set sortAscendingLabel(value) {\n      this._sortAscendingLabel.override(value);\n    }\n\n    get sortAscendingLabel() {\n      return this._sortAscendingLabel.value;\n    }\n    /**\n     * Expects an object that contains some or all of:\n     * ```\n     * {\n     *\t\t\"FILTER\": \"Filter\",\n     *\t\t\"END_OF_DATA\": \"You've reached the end of your content\",\n     *\t\t\"SCROLL_TOP\": \"Scroll to top\",\n     *\t\t\"CHECKBOX_HEADER\": \"Select all rows\",\n     *\t\t\"CHECKBOX_ROW\": \"Select row\"\n     * }\n     * ```\n     */\n\n\n    set translations(value) {\n      const valueWithDefaults = merge(this.i18n.getMultiple(\"TABLE\"), value);\n\n      this._filterTitle.override(valueWithDefaults.FILTER);\n\n      this._endOfDataText.override(valueWithDefaults.END_OF_DATA);\n\n      this._scrollTopText.override(valueWithDefaults.SCROLL_TOP);\n\n      this._checkboxHeaderLabel.override(valueWithDefaults.CHECKBOX_HEADER);\n\n      this._checkboxRowLabel.override(valueWithDefaults.CHECKBOX_ROW);\n    }\n\n    get noData() {\n      return !this.model.data || this.model.data.length === 0 || this.model.data.length === 1 && this.model.data[0].length === 0;\n    }\n\n    ngAfterViewInit() {\n      this.isViewReady = true;\n\n      if (this.isDataGrid) {\n        this.enableDataGridInteractions();\n      }\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.unsubscribe();\n\n      if (this.positionSubscription) {\n        this.positionSubscription.unsubscribe();\n      }\n    }\n\n    enableDataGridInteractions() {\n      // if we have an `interactioModel` we've already enabled datagrid\n      if (this.interactionModel) {\n        return;\n      }\n\n      const table = this.elementRef.nativeElement.querySelector(\"table\");\n      const tableAdapter = new TableDomAdapter(table);\n      const keydownEventStream = fromEvent(table, \"keydown\");\n      const clickEventStream = fromEvent(table, \"click\");\n      this.interactionModel = new DataGridInteractionModel(keydownEventStream, clickEventStream, tableAdapter);\n      this.positionSubscription = this.interactionModel.position.subscribe(event => {\n        const [currentRow, currentColumn] = event.current;\n        const [previousRow, previousColumn] = event.previous;\n        const currentElement = tableAdapter.getCell(currentRow, currentColumn);\n        Table.setTabIndex(currentElement, 0); // if the model has just initialized don't focus or reset anything\n\n        if (previousRow === -1 || previousColumn === -1) {\n          return;\n        } // Make the previous cell unfocusable (if it's not the current)\n\n\n        if (previousRow !== currentRow || previousColumn !== currentColumn) {\n          const previousElement = tableAdapter.getCell(previousRow, previousColumn);\n          Table.setTabIndex(previousElement, -1);\n        }\n\n        Table.focus(currentElement);\n      }); // call this after assigning `this.interactionModel` since it depends on it\n\n      this.resetTabIndex();\n    }\n\n    disableDataGridInteractions() {\n      // unsubscribe first so we don't cause the focus to fly around\n      if (this.positionSubscription) {\n        this.positionSubscription.unsubscribe();\n      } // undo tab indexing (also resets the model)\n\n\n      this.resetTabIndex(0); // null out the model ref\n\n      this.interactionModel = null;\n    }\n\n    onSelectAll() {\n      this.model.selectAll(true);\n      this.selectAll.emit(this.model);\n    }\n\n    onDeselectAll() {\n      this.model.selectAll(false);\n      this.deselectAll.emit(this.model);\n    }\n\n    onSelectRow(event) {\n      // check for the existence of the selectedRowIndex property\n      if (Object.keys(event).includes(\"selectedRowIndex\")) {\n        if (this.enableSingleSelect) {\n          this.model.selectAll(false);\n        }\n\n        this.model.selectRow(event.selectedRowIndex, true);\n        this.selectRow.emit(event);\n      } else {\n        this.model.selectRow(event.deselectedRowIndex, false);\n        this.deselectRow.emit(event);\n      }\n    }\n\n    onRowClick(index) {\n      this.rowClick.emit(index);\n    }\n\n    updateSelectAllCheckbox() {\n      const selectedRowsCount = this.model.selectedRowsCount();\n\n      if (selectedRowsCount <= 0) {\n        // reset select all checkbox if nothing selected\n        this.selectAllCheckbox = false;\n        this.selectAllCheckboxSomeSelected = false;\n      } else if (selectedRowsCount < this.model.data.length) {\n        this.selectAllCheckbox = true;\n        this.selectAllCheckboxSomeSelected = true;\n      } else {\n        this.selectAllCheckbox = true;\n        this.selectAllCheckboxSomeSelected = false;\n      }\n    }\n\n    resetTabIndex(newTabIndex = -1) {\n      // ensure the view is ready for the reset before we preform the actual reset\n      setTimeout(() => {\n        // reset all the tabIndexes we can find\n        const focusElementList = getFocusElementList(this.elementRef.nativeElement, tabbableSelectorIgnoreTabIndex);\n\n        if (focusElementList) {\n          focusElementList.forEach(tabbable => {\n            tabbable.tabIndex = newTabIndex;\n          });\n        } // reset interaction model positions and tabIndexes\n\n\n        if (this.interactionModel) {\n          this.interactionModel.resetTabIndexes(newTabIndex);\n        }\n      });\n    }\n\n    columnResizeStart(event, column) {\n      this.columnResizeWidth = parseInt(column.style.width, 10);\n      this.columnResizeMouseX = event.clientX;\n      event.preventDefault();\n      this.mouseMoveSubscription = fromEvent(document.body, \"mousemove\").subscribe(event => {\n        this.columnResizeProgress(event, column);\n      });\n      this.mouseUpSubscription = fromEvent(document.body, \"mouseup\").subscribe(event => {\n        this.columnResizeEnd(event, column);\n      });\n    }\n\n    columnResizeProgress(event, column) {\n      const move = event.clientX - this.columnResizeMouseX;\n      column.style.width = `${this.columnResizeWidth + move}px`;\n    }\n\n    columnResizeEnd(event, column) {\n      this.mouseMoveSubscription.unsubscribe();\n      this.mouseUpSubscription.unsubscribe();\n    }\n    /**\n     * Triggered when the user scrolls on the `<tbody>` element.\n     * Emits the `scrollLoad` event.\n     */\n\n\n    onScroll(event) {\n      const distanceFromBottom = event.target.scrollHeight - event.target.clientHeight - event.target.scrollTop;\n\n      if (distanceFromBottom <= this.scrollLoadDistance) {\n        this.scrollLoad.emit(this.model);\n      } else {\n        this.model.isEnd = false;\n      }\n    }\n\n    columnDragStart(event, columnIndex) {\n      this.isColumnDragging = true;\n      this.columnDraggedHoverIndex = columnIndex;\n      event.dataTransfer.setData(\"columnIndex\", JSON.stringify(columnIndex));\n    }\n\n    columnDragEnd(event, columnIndex) {\n      this.isColumnDragging = false;\n      this.columnDraggedHoverIndex = -1;\n    }\n\n    columnDragEnter(event, position, columnIndex) {\n      this.columnDraggedPosition = position;\n      this.columnDraggedHoverIndex = columnIndex;\n    }\n\n    columnDragLeave(event, position, columnIndex) {\n      this.columnDraggedPosition = \"\";\n    }\n\n    columnDragover(event, position, columnIndex) {\n      this.columnDraggedHoverIndex = columnIndex;\n      this.columnDraggedPosition = position; // needed to tell browser to allow dropping\n\n      event.preventDefault();\n    }\n\n    columnDrop(event, position, columnIndex) {\n      this.isColumnDragging = false;\n      this.columnDraggedHoverIndex = -1;\n      this.columnDraggedPosition = \"\";\n      this.model.moveColumn(parseInt(event.dataTransfer.getData(\"columnIndex\"), 10), columnIndex + (position === \"right\" ? 1 : 0));\n    }\n\n    doSort(index) {\n      if (this.sort.observers.length === 0) {\n        // no sort provided so do the simple sort\n        if (this.model.header[index].sorted) {\n          // if already sorted flip sorting direction\n          this.model.header[index].ascending = this.model.header[index].descending;\n        }\n\n        this.model.sort(index);\n      }\n\n      this.sort.emit(index);\n    }\n    /**\n     * Triggered when the user scrolls on the `<tbody>` element.\n     * Emits the `scrollLoad` event.\n     */\n\n\n    scrollToTop(event) {\n      event.target.parentElement.parentElement.parentElement.parentElement.children[1].scrollTop = 0;\n      this.model.isEnd = false;\n    }\n\n    getSelectionLabelValue(row) {\n      if (!this.selectionLabelColumn) {\n        return {\n          value: this.i18n.get().TABLE.ROW\n        };\n      }\n\n      return {\n        value: row[this.selectionLabelColumn].data\n      };\n    }\n\n    getExpandButtonAriaLabel() {\n      return this._expandButtonAriaLabel.subject;\n    }\n\n    getSortDescendingLabel() {\n      return this._sortDescendingLabel.subject;\n    }\n\n    getSortAscendingLabel() {\n      return this._sortAscendingLabel.subject;\n    }\n\n    getCheckboxHeaderLabel() {\n      return this._checkboxHeaderLabel.subject;\n    }\n\n    getCheckboxRowLabel() {\n      return this._checkboxRowLabel.subject;\n    }\n\n    getEndOfDataText() {\n      return this._endOfDataText.subject;\n    }\n\n    getScrollTopText() {\n      return this._scrollTopText.subject;\n    }\n\n    getFilterTitle() {\n      return this._filterTitle.subject;\n    }\n\n  }\n\n  Table.ɵfac = function Table_Factory(t) {\n    return new (t || Table)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  Table.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: Table,\n    selectors: [[\"ibm-table\"]],\n    hostVars: 2,\n    hostBindings: function Table_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--data-table_inner-container\", ctx.stickyHeader);\n      }\n    },\n    inputs: {\n      size: \"size\",\n      skeleton: \"skeleton\",\n      sortable: \"sortable\",\n      noBorder: \"noBorder\",\n      showSelectionColumn: \"showSelectionColumn\",\n      enableSingleSelect: \"enableSingleSelect\",\n      scrollLoadDistance: \"scrollLoadDistance\",\n      columnsResizable: \"columnsResizable\",\n      columnsDraggable: \"columnsDraggable\",\n      striped: \"striped\",\n      stickyHeader: \"stickyHeader\",\n      model: \"model\",\n      isDataGrid: \"isDataGrid\",\n      expandButtonAriaLabel: \"expandButtonAriaLabel\",\n      sortDescendingLabel: \"sortDescendingLabel\",\n      sortAscendingLabel: \"sortAscendingLabel\",\n      translations: \"translations\",\n      footerTemplate: \"footerTemplate\",\n      selectionLabelColumn: \"selectionLabelColumn\"\n    },\n    outputs: {\n      sort: \"sort\",\n      selectAll: \"selectAll\",\n      deselectAll: \"deselectAll\",\n      selectRow: \"selectRow\",\n      deselectRow: \"deselectRow\",\n      rowClick: \"rowClick\",\n      scrollLoad: \"scrollLoad\"\n    },\n    ngContentSelectors: _c5,\n    decls: 9,\n    vars: 26,\n    consts: [[\"ibmTable\", \"\", 3, \"sortable\", \"noBorder\", \"ngClass\", \"size\", \"striped\", \"skeleton\"], [\"ibmTableHead\", \"\", 3, \"sortable\", \"checkboxHeaderLabel\", \"filterTitle\", \"model\", \"size\", \"selectAllCheckbox\", \"selectAllCheckboxSomeSelected\", \"showSelectionColumn\", \"enableSingleSelect\", \"skeleton\", \"sortAscendingLabel\", \"sortDescendingLabel\", \"stickyHeader\", \"deselectAll\", \"selectAll\", \"sort\"], [\"ibmTableBody\", \"\", 3, \"checkboxRowLabel\", \"enableSingleSelect\", \"expandButtonAriaLabel\", \"model\", \"size\", \"ngStyle\", \"selectionLabelColumn\", \"showSelectionColumn\", \"skeleton\", \"deselectRow\", \"scroll\", \"selectRow\", \"rowClick\", 4, \"ngIf\", \"ngIfElse\"], [\"noDataTemplate\", \"\"], [3, \"ngTemplateOutlet\"], [4, \"ngIf\"], [\"ibmTableBody\", \"\", 3, \"checkboxRowLabel\", \"enableSingleSelect\", \"expandButtonAriaLabel\", \"model\", \"size\", \"ngStyle\", \"selectionLabelColumn\", \"showSelectionColumn\", \"skeleton\", \"deselectRow\", \"scroll\", \"selectRow\", \"rowClick\"], [1, \"table_loading-indicator\"], [1, \"bx--loading\", \"bx--loading--small\"], [\"viewBox\", \"-75 -75 150 150\", 1, \"bx--loading__svg\"], [\"cx\", \"0\", \"cy\", \"0\", \"r\", \"37.5\", 1, \"bx--loading__stroke\"], [1, \"table_end-indicator\"], [1, \"btn--secondary-sm\", 3, \"click\"]],\n    template: function Table_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"table\", 0)(1, \"thead\", 1);\n        ɵngcc0.ɵɵlistener(\"deselectAll\", function Table_Template_thead_deselectAll_1_listener() {\n          return ctx.onDeselectAll();\n        })(\"selectAll\", function Table_Template_thead_selectAll_1_listener() {\n          return ctx.onSelectAll();\n        })(\"sort\", function Table_Template_thead_sort_1_listener($event) {\n          return ctx.doSort($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(2, Table_tbody_2_Template, 1, 10, \"tbody\", 2);\n        ɵngcc0.ɵɵtemplate(3, Table_ng_template_3_Template, 1, 0, \"ng-template\", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);\n        ɵngcc0.ɵɵelementStart(5, \"tfoot\");\n        ɵngcc0.ɵɵtemplate(6, Table_ng_template_6_Template, 0, 0, \"ng-template\", 4);\n        ɵngcc0.ɵɵtemplate(7, Table_tr_7_Template, 5, 0, \"tr\", 5);\n        ɵngcc0.ɵɵtemplate(8, Table_tr_8_Template, 8, 6, \"tr\", 5);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        const _r1 = ɵngcc0.ɵɵreference(4);\n\n        ɵngcc0.ɵɵproperty(\"sortable\", ctx.sortable)(\"noBorder\", ctx.noBorder)(\"ngClass\", ɵngcc0.ɵɵpureFunction1(24, _c9, ctx.stickyHeader))(\"size\", ctx.size)(\"striped\", ctx.striped)(\"skeleton\", ctx.skeleton);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"sortable\", ctx.sortable)(\"checkboxHeaderLabel\", ctx.getCheckboxHeaderLabel())(\"filterTitle\", ctx.getFilterTitle())(\"model\", ctx.model)(\"size\", ctx.size)(\"selectAllCheckbox\", ctx.selectAllCheckbox)(\"selectAllCheckboxSomeSelected\", ctx.selectAllCheckboxSomeSelected)(\"showSelectionColumn\", ctx.showSelectionColumn)(\"enableSingleSelect\", ctx.enableSingleSelect)(\"skeleton\", ctx.skeleton)(\"sortAscendingLabel\", ctx.sortAscendingLabel)(\"sortDescendingLabel\", ctx.sortDescendingLabel)(\"stickyHeader\", ctx.stickyHeader);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.noData)(\"ngIfElse\", _r1);\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.footerTemplate);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model.isLoading);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model.isEnd);\n      }\n    },\n    directives: function () {\n      return [TableDirective, ɵngcc2.NgClass, TableHead, ɵngcc2.NgIf, TableBody, ɵngcc2.NgStyle, ɵngcc2.NgTemplateOutlet];\n    },\n    pipes: function () {\n      return [ɵngcc2.AsyncPipe];\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return Table;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableDirective = /*#__PURE__*/(() => {\n  class TableDirective {\n    constructor() {\n      this.sortable = true;\n      this.noBorder = true;\n      this.striped = false;\n      this.skeleton = false;\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      this.tableClass = true;\n    }\n\n    get compactClass() {\n      return this.size === \"sm\";\n    }\n\n    get tallClass() {\n      return this.size === \"lg\";\n    }\n\n    get shortClass() {\n      return this.size === \"sh\";\n    }\n\n  }\n\n  TableDirective.ɵfac = function TableDirective_Factory(t) {\n    return new (t || TableDirective)();\n  };\n\n  TableDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TableDirective,\n    selectors: [[\"\", \"ibmTable\", \"\"]],\n    hostVars: 16,\n    hostBindings: function TableDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--data-table--sort\", ctx.sortable)(\"bx--data-table--no-border\", ctx.noBorder)(\"bx--data-table--zebra\", ctx.striped)(\"bx--skeleton\", ctx.skeleton)(\"bx--data-table\", ctx.tableClass)(\"bx--data-table--compact\", ctx.compactClass)(\"bx--data-table--tall\", ctx.tallClass)(\"bx--data-table--short\", ctx.shortClass);\n      }\n    },\n    inputs: {\n      sortable: \"sortable\",\n      noBorder: \"noBorder\",\n      striped: \"striped\",\n      skeleton: \"skeleton\",\n      size: \"size\"\n    }\n  });\n  return TableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A subcomponent that creates the thead of the table\n *\n * ## Basic usage\n *\n * ```html\n * \t<thead ibmTableHead [model]=\"model\"></thead>\n * ```\n */\n\n\nlet TableHead = /*#__PURE__*/(() => {\n  class TableHead {\n    constructor(i18n) {\n      this.i18n = i18n;\n      this.showSelectionColumn = true;\n      this.enableSingleSelect = false;\n      this.selectAllCheckboxSomeSelected = false;\n      this.selectAllCheckbox = false;\n      this.skeleton = false;\n      this.stickyHeader = false;\n      /**\n       * Setting sortable to false will disable all headers including headers which are sortable. Is is\n       * possible to set the sortable state on the header item to disable/enable sorting for only some headers.\n       */\n\n      this.sortable = true;\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      /**\n       * Emits an index of the column that wants to be sorted.\n       */\n\n      this.sort = new EventEmitter();\n      /**\n       * Emits if all rows are selected.\n       *\n       * @param model\n       */\n\n      this.selectAll = new EventEmitter();\n      /**\n       * Emits if all rows are deselected.\n       *\n       * @param model\n       */\n\n      this.deselectAll = new EventEmitter();\n      this.scrollbarWidth = 0;\n      this._checkboxHeaderLabel = this.i18n.getOverridable(\"TABLE.CHECKBOX_HEADER\");\n      this._sortDescendingLabel = this.i18n.getOverridable(\"TABLE.SORT_DESCENDING\");\n      this._sortAscendingLabel = this.i18n.getOverridable(\"TABLE.SORT_ASCENDING\");\n      this._filterTitle = this.i18n.getOverridable(\"TABLE.FILTER\");\n    }\n\n    set checkboxHeaderLabel(value) {\n      this._checkboxHeaderLabel.override(value);\n    }\n\n    get checkboxHeaderLabel() {\n      return this._checkboxHeaderLabel.value;\n    }\n\n    set sortDescendingLabel(value) {\n      this._sortDescendingLabel.override(value);\n    }\n\n    get sortDescendingLabel() {\n      return this._sortDescendingLabel.value;\n    }\n\n    set sortAscendingLabel(value) {\n      this._sortAscendingLabel.override(value);\n    }\n\n    get sortAscendingLabel() {\n      return this._sortAscendingLabel.value;\n    }\n\n    set filterTitle(value) {\n      this._filterTitle.override(value);\n    }\n\n    get filterTitle() {\n      return this._filterTitle.value;\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.scrollbarWidth = getScrollbarWidth();\n      });\n    }\n\n    onSelectAllCheckboxChange() {\n      if (!this.selectAllCheckbox && !this.selectAllCheckboxSomeSelected) {\n        this.selectAll.emit(this.model);\n      } else {\n        this.deselectAll.emit(this.model);\n      }\n    }\n\n    getCheckboxHeaderLabel() {\n      return this._checkboxHeaderLabel.subject;\n    }\n\n    getSortDescendingLabel() {\n      return this._sortDescendingLabel.subject;\n    }\n\n    getSortAscendingLabel() {\n      return this._sortAscendingLabel.subject;\n    }\n\n    getFilterTitle() {\n      return this._filterTitle.subject;\n    }\n\n  }\n\n  TableHead.ɵfac = function TableHead_Factory(t) {\n    return new (t || TableHead)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableHead.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableHead,\n    selectors: [[\"\", \"ibmTableHead\", \"\"]],\n    inputs: {\n      showSelectionColumn: \"showSelectionColumn\",\n      enableSingleSelect: \"enableSingleSelect\",\n      selectAllCheckboxSomeSelected: \"selectAllCheckboxSomeSelected\",\n      selectAllCheckbox: \"selectAllCheckbox\",\n      skeleton: \"skeleton\",\n      stickyHeader: \"stickyHeader\",\n      sortable: \"sortable\",\n      size: \"size\",\n      checkboxHeaderLabel: \"checkboxHeaderLabel\",\n      sortDescendingLabel: \"sortDescendingLabel\",\n      sortAscendingLabel: \"sortAscendingLabel\",\n      filterTitle: \"filterTitle\",\n      model: \"model\"\n    },\n    outputs: {\n      sort: \"sort\",\n      selectAll: \"selectAll\",\n      deselectAll: \"deselectAll\"\n    },\n    attrs: _c10,\n    ngContentSelectors: _c5,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"ibmTableHeadExpand\", \"\", \"scope\", \"col\", 3, \"ngClass\", \"id\", 4, \"ngIf\"], [\"scope\", \"col\", \"style\", \"width: 0;\", 3, \"id\", 4, \"ngIf\"], [\"ibmTableHeadCheckbox\", \"\", \"scope\", \"col\", 3, \"checked\", \"indeterminate\", \"ariaLabel\", \"size\", \"skeleton\", \"name\", \"id\", \"change\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"scope\", \"col\", 3, \"ngStyle\", 4, \"ngIf\"], [\"ibmTableHeadExpand\", \"\", \"scope\", \"col\", 3, \"ngClass\", \"id\"], [\"scope\", \"col\", 2, \"width\", \"0\", 3, \"id\"], [\"ibmTableHeadCheckbox\", \"\", \"scope\", \"col\", 3, \"checked\", \"indeterminate\", \"ariaLabel\", \"size\", \"skeleton\", \"name\", \"id\", \"change\"], [\"ibmTableHeadCell\", \"\", \"scope\", \"col\", 3, \"ngStyle\", \"class\", \"sortable\", \"skeleton\", \"id\", \"column\", \"filterTitle\", \"sort\", 4, \"ngIf\"], [\"ibmTableHeadCell\", \"\", \"scope\", \"col\", 3, \"ngStyle\", \"sortable\", \"skeleton\", \"id\", \"column\", \"filterTitle\", \"sort\"], [\"scope\", \"col\", 3, \"ngStyle\"]],\n    template: function TableHead_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, TableHead_ng_container_0_Template, 7, 5, \"ng-container\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgIf, TableHeadExpand, ɵngcc2.NgClass, TableHeadCheckbox, ɵngcc2.NgForOf, TableHeadCell, ɵngcc2.NgStyle];\n    },\n    styles: [\".bx--table-expand-v2[_ngcontent-%COMP%] {\\n\\t\\t\\tpadding-left: 2.5rem;\\n\\t\\t}\"]\n  });\n  /** @nocollapse */\n\n  return TableHead;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeadCell = /*#__PURE__*/(() => {\n  class TableHeadCell {\n    constructor(i18n) {\n      this.i18n = i18n;\n      this.skeleton = false;\n      this.sortable = true;\n      /**\n       * Notifies that the column should be sorted\n       */\n\n      this.sort = new EventEmitter();\n      this.theadAction = false;\n      this._sortDescendingLabel = this.i18n.getOverridable(\"TABLE.SORT_DESCENDING\");\n      this._sortAscendingLabel = this.i18n.getOverridable(\"TABLE.SORT_ASCENDING\");\n      this._filterTitle = this.i18n.getOverridable(\"TABLE.FILTER\");\n    }\n\n    set sortDescendingLabel(value) {\n      this._sortDescendingLabel.override(value);\n    }\n\n    get sortDescendingLabel() {\n      return this._sortDescendingLabel.value;\n    }\n\n    set sortAscendingLabel(value) {\n      this._sortAscendingLabel.override(value);\n    }\n\n    get sortAscendingLabel() {\n      return this._sortAscendingLabel.value;\n    }\n\n    set filterTitle(value) {\n      this._filterTitle.override(value);\n    }\n\n    get filterTitle() {\n      return this._filterTitle.value;\n    }\n\n    ngOnChanges() {\n      // Since it's not an input, and it touches the view, we're using `ngOnChanges`\n      // `get`ters have caused issues in the past with the view updating outside of change detection\n      this.theadAction = !!this.column.filterTemplate || this.sort.observers.length > 0;\n    }\n\n    getSortDescendingLabel() {\n      return this._sortDescendingLabel.subject.pipe(this.sortLabelMap());\n    }\n\n    getSortAscendingLabel() {\n      return this._sortAscendingLabel.subject.pipe(this.sortLabelMap());\n    }\n\n    getFilterTitle() {\n      return this._filterTitle.subject;\n    }\n\n    onClick() {\n      if (!this.skeleton) {\n        this.sort.emit();\n      }\n    }\n\n    sortLabelMap() {\n      return map(str => {\n        if (this.column.ariaSortLabel) {\n          return this.column.ariaSortLabel;\n        }\n\n        if (this.column.formatSortLabel) {\n          return this.column.formatSortLabel(str, this.column.ariaSortLabel);\n        }\n\n        return `${this.column.data} - ${str}`;\n      });\n    }\n\n  }\n\n  TableHeadCell.ɵfac = function TableHeadCell_Factory(t) {\n    return new (t || TableHeadCell)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableHeadCell.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableHeadCell,\n    selectors: [[\"\", \"ibmTableHeadCell\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableHeadCell_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"thead_action\", ctx.theadAction);\n      }\n    },\n    inputs: {\n      skeleton: \"skeleton\",\n      sortable: \"sortable\",\n      sortDescendingLabel: \"sortDescendingLabel\",\n      sortAscendingLabel: \"sortAscendingLabel\",\n      filterTitle: \"filterTitle\",\n      column: \"column\"\n    },\n    outputs: {\n      sort: \"sort\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    attrs: _c13,\n    decls: 3,\n    vars: 3,\n    consts: [[\"class\", \"bx--table-sort\", \"aria-live\", \"polite\", 3, \"ngClass\", \"click\", 4, \"ngIf\"], [\"class\", \"bx--table-header-label\", 4, \"ngIf\"], [\"type\", \"button\", \"aria-expanded\", \"false\", \"aria-haspopup\", \"true\", \"trigger\", \"click\", \"placement\", \"bottom,top\", 3, \"ngClass\", \"ibmTooltip\", \"title\", \"data\", 4, \"ngIf\"], [\"aria-live\", \"polite\", 1, \"bx--table-sort\", 3, \"ngClass\", \"click\"], [\"tabindex\", \"-1\", 1, \"bx--table-sort__flex\", 3, \"title\"], [\"ibmTableHeadCellLabel\", \"\", 4, \"ngIf\"], [4, \"ngIf\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"style\", \"will-change: transform;\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"class\", \"bx--table-sort__icon\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\", 4, \"ngIf\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"style\", \"will-change: transform;\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"class\", \"bx--table-sort__icon-unsorted\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\", 4, \"ngIf\"], [\"ibmTableHeadCellLabel\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\", 1, \"bx--table-sort__icon\", 2, \"will-change\", \"transform\"], [\"d\", \"M12.3 9.3l-3.8 3.8V1h-1v12.1L3.7 9.3 3 10l5 5 5-5z\"], [\"focusable\", \"false\", \"preserveAspectRatio\", \"xMidYMid meet\", \"xmlns\", \"http://www.w3.org/2000/svg\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", \"aria-hidden\", \"true\", 1, \"bx--table-sort__icon-unsorted\", 2, \"will-change\", \"transform\"], [\"d\", \"M13.8 10.3L12 12.1V2h-1v10.1l-1.8-1.8-.7.7 3 3 3-3zM4.5 2l-3 3 .7.7L4 3.9V14h1V3.9l1.8 1.8.7-.7z\"], [1, \"bx--table-header-label\"], [3, \"title\", 4, \"ngIf\"], [3, \"title\"], [\"type\", \"button\", \"aria-expanded\", \"false\", \"aria-haspopup\", \"true\", \"trigger\", \"click\", \"placement\", \"bottom,top\", 3, \"ngClass\", \"ibmTooltip\", \"title\", \"data\"], [\"xmlns\", \"http://www.w3.org/2000/svg\", \"width\", \"16\", \"height\", \"16\", \"viewBox\", \"0 0 16 16\", 1, \"icon--sm\"], [\"d\", \"M0 0v3l6 8v5h4v-5l6-8V0H0zm9 10.7V15H7v-4.3L1.3 3h13.5L9 10.7z\"]],\n    template: function TableHeadCell_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TableHeadCell_button_0_Template, 7, 12, \"button\", 0);\n        ɵngcc0.ɵɵtemplate(1, TableHeadCell_div_1_Template, 3, 5, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(2, TableHeadCell_button_2_Template, 5, 9, \"button\", 2);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.sortable && ctx.sort.observers.length > 0 && ctx.column.sortable);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton && ctx.sort.observers.length === 0 || ctx.sort.observers.length > 0 && !ctx.column.sortable || !ctx.sortable);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.column.filterTemplate);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgClass, TableHeadCellLabel, ɵngcc2.NgTemplateOutlet, ɵngcc5.TooltipDirective],\n    pipes: [ɵngcc2.AsyncPipe],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableHeadCell;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeadCheckbox = /*#__PURE__*/(() => {\n  class TableHeadCheckbox {\n    constructor(i18n) {\n      this.i18n = i18n;\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      this.checked = false;\n      this.indeterminate = false;\n      this.skeleton = false;\n      this.name = `select-all-${TableHeadCheckbox.tableSelectAllCount++}`;\n      this.change = new EventEmitter();\n      this.hostClass = true;\n      this._ariaLabel = this.i18n.getOverridable(\"TABLE.CHECKBOX_HEADER\");\n    }\n\n    set ariaLabel(value) {\n      this._ariaLabel.override(value);\n    }\n\n    get ariaLabel() {\n      return this._ariaLabel.value;\n    }\n\n    getAriaLabel() {\n      return this._ariaLabel.subject;\n    }\n\n  }\n\n  TableHeadCheckbox.ɵfac = function TableHeadCheckbox_Factory(t) {\n    return new (t || TableHeadCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableHeadCheckbox.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableHeadCheckbox,\n    selectors: [[\"\", \"ibmTableHeadCheckbox\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableHeadCheckbox_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--table-column-checkbox\", ctx.hostClass);\n      }\n    },\n    inputs: {\n      size: \"size\",\n      checked: \"checked\",\n      indeterminate: \"indeterminate\",\n      skeleton: \"skeleton\",\n      name: \"name\",\n      ariaLabel: \"ariaLabel\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    attrs: _c17,\n    decls: 1,\n    vars: 1,\n    consts: [[\"inline\", \"true\", 3, \"size\", \"name\", \"checked\", \"indeterminate\", \"aria-label\", \"checkedChange\", 4, \"ngIf\"], [\"inline\", \"true\", 3, \"size\", \"name\", \"checked\", \"indeterminate\", \"aria-label\", \"checkedChange\"]],\n    template: function TableHeadCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TableHeadCheckbox_ibm_checkbox_0_Template, 2, 7, \"ibm-checkbox\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc6.Checkbox],\n    pipes: [ɵngcc2.AsyncPipe],\n    styles: [\"[_nghost-%COMP%] { width: 10px; }\"]\n  });\n  TableHeadCheckbox.tableSelectAllCount = 0;\n  /** @nocollapse */\n\n  return TableHeadCheckbox;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableHeadExpand = /*#__PURE__*/(() => {\n  class TableHeadExpand {\n    constructor() {\n      this.hostClass = true;\n    }\n\n  }\n\n  TableHeadExpand.ɵfac = function TableHeadExpand_Factory(t) {\n    return new (t || TableHeadExpand)();\n  };\n\n  TableHeadExpand.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableHeadExpand,\n    selectors: [[\"\", \"ibmTableHeadExpand\", \"\"]],\n    hostVars: 2,\n    hostBindings: function TableHeadExpand_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"bx--table-expand\", ctx.hostClass);\n      }\n    },\n    attrs: _c18,\n    ngContentSelectors: _c5,\n    decls: 1,\n    vars: 0,\n    template: function TableHeadExpand_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return TableHeadExpand;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableBody = /*#__PURE__*/(() => {\n  class TableBody {\n    constructor(i18n) {\n      this.i18n = i18n;\n      /**\n       * Controls whether to enable multiple or single row selection.\n       */\n\n      this.enableSingleSelect = false;\n      /**\n       * Controls whether to show the selection checkboxes column or not.\n       */\n\n      this.showSelectionColumn = true;\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      this.skeleton = false;\n      /**\n       * Emits if a single row is selected.\n       *\n       * @param ({model: this.model, selectedRowIndex: index})\n       */\n\n      this.selectRow = new EventEmitter();\n      /**\n       * Emits if a single row is deselected.\n       *\n       * @param ({model: this.model, deselectedRowIndex: index})\n       */\n\n      this.deselectRow = new EventEmitter();\n      /**\n       * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.\n       */\n\n      this.rowClick = new EventEmitter();\n      this._checkboxRowLabel = this.i18n.getOverridable(\"TABLE.CHECKBOX_ROW\");\n      this._expandButtonAriaLabel = this.i18n.getOverridable(\"TABLE.EXPAND_BUTTON\");\n    }\n\n    set expandButtonAriaLabel(value) {\n      this._expandButtonAriaLabel.override(value);\n    }\n\n    get expandButtonAriaLabel() {\n      return this._expandButtonAriaLabel.value;\n    }\n\n    set checkboxRowLabel(value) {\n      this._checkboxRowLabel.override(value);\n    }\n\n    get checkboxRowLabel() {\n      return this._checkboxRowLabel.value;\n    }\n    /**\n     * Triggered when a single row is clicked.\n     * Updates the header checkbox state.\n     * Emits the `selectRow` or `deselectRow` event.\n     */\n\n\n    onRowCheckboxChange(index) {\n      if (this.model.isRowSelected(index)) {\n        this.deselectRow.emit({\n          model: this.model,\n          deselectedRowIndex: index\n        });\n      } else {\n        this.selectRow.emit({\n          model: this.model,\n          selectedRowIndex: index\n        });\n      }\n    }\n\n    onRowClick(index) {\n      this.rowClick.emit(index);\n    }\n\n    getCheckboxRowLabel() {\n      return this._checkboxRowLabel.subject;\n    }\n\n    getExpandButtonAriaLabel() {\n      return this._expandButtonAriaLabel.subject;\n    }\n\n    firstExpandedDataInRow(row) {\n      const found = row.find(d => d.expandedData);\n\n      if (found) {\n        return found.expandedData;\n      }\n\n      return found;\n    }\n\n    shouldExpandAsTable(row) {\n      return row.some(d => d.expandAsTable);\n    }\n\n  }\n\n  TableBody.ɵfac = function TableBody_Factory(t) {\n    return new (t || TableBody)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableBody.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableBody,\n    selectors: [[\"\", \"ibmTableBody\", \"\"]],\n    inputs: {\n      enableSingleSelect: \"enableSingleSelect\",\n      showSelectionColumn: \"showSelectionColumn\",\n      size: \"size\",\n      skeleton: \"skeleton\",\n      expandButtonAriaLabel: \"expandButtonAriaLabel\",\n      checkboxRowLabel: \"checkboxRowLabel\",\n      model: \"model\",\n      selectionLabelColumn: \"selectionLabelColumn\"\n    },\n    outputs: {\n      selectRow: \"selectRow\",\n      deselectRow: \"deselectRow\",\n      rowClick: \"rowClick\"\n    },\n    attrs: _c19,\n    ngContentSelectors: _c5,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"ibmTableRow\", \"\", 3, \"model\", \"row\", \"size\", \"selected\", \"expandable\", \"expanded\", \"checkboxLabel\", \"expandButtonAriaLabel\", \"showSelectionColumn\", \"enableSingleSelect\", \"skeleton\", \"class\", \"ngClass\", \"selectRow\", \"deselectRow\", \"expandRow\", \"rowClick\", 4, \"ngIf\"], [\"ibmTableExpandedRow\", \"\", \"ibmExpandedRowHover\", \"\", 3, \"row\", \"expanded\", \"skeleton\", 4, \"ngIf\"], [\"ibmTableRow\", \"\", 3, \"model\", \"row\", \"size\", \"selected\", \"expandable\", \"expanded\", \"checkboxLabel\", \"expandButtonAriaLabel\", \"showSelectionColumn\", \"enableSingleSelect\", \"skeleton\", \"ngClass\", \"selectRow\", \"deselectRow\", \"expandRow\", \"rowClick\"], [\"ibmTableExpandedRow\", \"\", \"ibmExpandedRowHover\", \"\", 3, \"row\", \"expanded\", \"skeleton\"], [\"ibmTableRow\", \"\", 3, \"model\", \"showSelectionColumnCheckbox\", \"showSelectionColumn\", \"row\", \"size\", \"skeleton\", 4, \"ngFor\", \"ngForOf\"], [\"ibmTableRow\", \"\", 3, \"model\", \"showSelectionColumnCheckbox\", \"showSelectionColumn\", \"row\", \"size\", \"skeleton\"]],\n    template: function TableBody_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, TableBody_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgIf, ɵngcc2.NgForOf, TableRowComponent, ɵngcc2.NgClass, TableExpandedRow, ExpandedRowHover];\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableBody;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableRowComponent = /*#__PURE__*/(() => {\n  class TableRowComponent {\n    constructor(i18n) {\n      this.i18n = i18n;\n      this.expanded = false;\n      this.expandable = false;\n      this.selected = false;\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      /**\n       * Controls whether to enable multiple or single row selection.\n       */\n\n      this.enableSingleSelect = false;\n      /**\n       * Controls whether to show the selection checkboxes column or not.\n       */\n\n      this.showSelectionColumn = true;\n      /**\n       * Shows or hide the checkbox in the selection column when `showSelectionColumn`\n       * is set to true\n       */\n\n      this.showSelectionColumnCheckbox = true;\n      this.skeleton = false;\n      /**\n       * Emits when the row is selected.\n       */\n\n      this.selectRow = new EventEmitter();\n      /**\n       * Emits when the row is deselected.\n       */\n\n      this.deselectRow = new EventEmitter();\n      /**\n       * Emits when the row is expanded\n       */\n\n      this.expandRow = new EventEmitter();\n      /**\n       * Emits when a row is clicked regardless of `enableSingleSelect` or `showSelectionColumn`.\n       * Should only get emitted when a row item is selected excluding expand buttons,\n       * checkboxes, or radios.\n       */\n\n      this.rowClick = new EventEmitter();\n      this._checkboxLabel = this.i18n.getOverridable(\"TABLE.CHECKBOX_ROW\");\n      this._expandButtonAriaLabel = this.i18n.getOverridable(\"TABLE.EXPAND_BUTTON\");\n    }\n\n    set expandButtonAriaLabel(value) {\n      this._expandButtonAriaLabel.override(value);\n    }\n\n    get expandButtonAriaLabel() {\n      return this._expandButtonAriaLabel.value;\n    }\n\n    set checkboxLabel(value) {\n      this._checkboxLabel.override(value);\n    }\n\n    get checkboxLabel() {\n      return this._checkboxLabel.value;\n    }\n\n    get selectedClass() {\n      return this.selected;\n    }\n\n    get parentRowClass() {\n      return this.expandable;\n    }\n\n    get expandableRowClass() {\n      return this.expanded;\n    }\n\n    get selectableClass() {\n      return false; // this.singleSelect\n    }\n\n    get isParentRow() {\n      return this.expandable ? true : null;\n    }\n\n    get isAccessible() {\n      return this.enableSingleSelect && !this.showSelectionColumn ? 0 : null;\n    }\n\n    onHostClick() {\n      if (this.enableSingleSelect && !this.showSelectionColumn) {\n        this.onSelectionChange();\n      }\n    }\n\n    onRowClick() {\n      this.rowClick.emit();\n    }\n\n    onSelectionChange() {\n      if (this.selected) {\n        this.deselectRow.emit();\n      } else {\n        this.selectRow.emit();\n      }\n    }\n\n    getCheckboxLabel() {\n      return this._checkboxLabel.subject;\n    }\n\n    getExpandButtonAriaLabel() {\n      return this._expandButtonAriaLabel.subject;\n    }\n\n  }\n\n  TableRowComponent.ɵfac = function TableRowComponent_Factory(t) {\n    return new (t || TableRowComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableRowComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableRowComponent,\n    selectors: [[\"\", \"ibmTableRow\", \"\"]],\n    hostVars: 10,\n    hostBindings: function TableRowComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function TableRowComponent_click_HostBindingHandler() {\n          return ctx.onHostClick();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-parent-row\", ctx.isParentRow)(\"tabindex\", ctx.isAccessible);\n        ɵngcc0.ɵɵclassProp(\"bx--data-table--selected\", ctx.selectedClass)(\"bx--parent-row\", ctx.parentRowClass)(\"bx--expandable-row\", ctx.expandableRowClass)(\"tbody_row--selectable\", ctx.selectableClass);\n      }\n    },\n    inputs: {\n      expanded: \"expanded\",\n      expandable: \"expandable\",\n      selected: \"selected\",\n      size: \"size\",\n      enableSingleSelect: \"enableSingleSelect\",\n      showSelectionColumn: \"showSelectionColumn\",\n      showSelectionColumnCheckbox: \"showSelectionColumnCheckbox\",\n      skeleton: \"skeleton\",\n      expandButtonAriaLabel: \"expandButtonAriaLabel\",\n      checkboxLabel: \"checkboxLabel\",\n      model: \"model\",\n      row: \"row\",\n      selectionLabelColumn: \"selectionLabelColumn\"\n    },\n    outputs: {\n      selectRow: \"selectRow\",\n      deselectRow: \"deselectRow\",\n      expandRow: \"expandRow\",\n      rowClick: \"rowClick\"\n    },\n    attrs: _c21,\n    ngContentSelectors: _c5,\n    decls: 2,\n    vars: 1,\n    consts: [[4, \"ngIf\"], [\"ibmTableExpandButton\", \"\", \"class\", \"bx--table-expand-v2\", 3, \"expanded\", \"expandable\", \"skeleton\", \"ariaLabel\", \"headers\", \"expandRow\", 4, \"ngIf\"], [\"ibmTableRadio\", \"\", 3, \"selected\", \"label\", \"row\", \"skeleton\", \"headers\", \"change\", 4, \"ngIf\"], [4, \"ngFor\", \"ngForOf\"], [\"ibmTableExpandButton\", \"\", 1, \"bx--table-expand-v2\", 3, \"expanded\", \"expandable\", \"skeleton\", \"ariaLabel\", \"headers\", \"expandRow\"], [4, \"ngIf\", \"ngIfElse\"], [\"tableCheckboxTemplate\", \"\"], [\"ibmTableCheckbox\", \"\", 1, \"bx--table-column-checkbox\", 3, \"size\", \"selected\", \"label\", \"row\", \"skeleton\", \"headers\", \"change\"], [\"ibmTableRadio\", \"\", 3, \"selected\", \"label\", \"row\", \"skeleton\", \"headers\", \"change\"], [\"ibmTableData\", \"\", 3, \"headers\", \"item\", \"title\", \"class\", \"ngStyle\", \"skeleton\", \"click\", \"keydown.enter\", 4, \"ngIf\"], [\"ibmTableData\", \"\", 3, \"headers\", \"item\", \"title\", \"skeleton\", \"click\", \"keydown.enter\", 4, \"ngIf\"], [\"ibmTableData\", \"\", 3, \"headers\", \"item\", \"title\", \"ngStyle\", \"skeleton\", \"click\", \"keydown.enter\"], [\"ibmTableData\", \"\", 3, \"headers\", \"item\", \"title\", \"skeleton\", \"click\", \"keydown.enter\"]],\n    template: function TableRowComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, TableRowComponent_ng_container_0_Template, 5, 4, \"ng-container\", 0);\n        ɵngcc0.ɵɵprojection(1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.model);\n      }\n    },\n    directives: function () {\n      return [ɵngcc2.NgIf, TableExpandButton, TableCheckbox, TableRadio, ɵngcc2.NgForOf, TableData, ɵngcc2.NgStyle];\n    },\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableRowComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableExpandedRow = /*#__PURE__*/(() => {\n  class TableExpandedRow {\n    constructor() {\n      this.skeleton = false;\n      this.expandableRowClass = true;\n      this.dataChildRow = true;\n      this.expanded = false;\n    }\n\n    get displayStyle() {\n      return this.expanded ? null : \"none\";\n    }\n\n    firstExpandedTemplateInRow(row) {\n      const found = row.find(d => d.expandedTemplate);\n\n      if (found) {\n        return found.expandedTemplate;\n      }\n\n      return found;\n    }\n\n    firstExpandedDataInRow(row) {\n      const found = row.find(d => d.expandedData);\n\n      if (found) {\n        return found.expandedData;\n      }\n\n      return found;\n    }\n\n  }\n\n  TableExpandedRow.ɵfac = function TableExpandedRow_Factory(t) {\n    return new (t || TableExpandedRow)();\n  };\n\n  TableExpandedRow.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableExpandedRow,\n    selectors: [[\"\", \"ibmTableExpandedRow\", \"\"]],\n    hostVars: 5,\n    hostBindings: function TableExpandedRow_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-child-row\", ctx.dataChildRow);\n        ɵngcc0.ɵɵstyleProp(\"display\", ctx.displayStyle);\n        ɵngcc0.ɵɵclassProp(\"bx--expandable-row\", ctx.expandableRowClass);\n      }\n    },\n    inputs: {\n      skeleton: \"skeleton\",\n      expanded: \"expanded\",\n      row: \"row\"\n    },\n    attrs: _c22,\n    decls: 3,\n    vars: 6,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function TableExpandedRow_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"td\");\n        ɵngcc0.ɵɵtemplate(1, TableExpandedRow_ng_container_1_Template, 2, 1, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(2, TableExpandedRow_ng_template_2_Template, 0, 0, \"ng-template\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"colspan\", ctx.row.length + 2);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.firstExpandedTemplateInRow(ctx.row));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx.firstExpandedTemplateInRow(ctx.row))(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(4, _c14, ctx.firstExpandedDataInRow(ctx.row)));\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return TableExpandedRow;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableData = /*#__PURE__*/(() => {\n  class TableData {\n    constructor() {\n      this.skeleton = false;\n    }\n\n  }\n\n  TableData.ɵfac = function TableData_Factory(t) {\n    return new (t || TableData)();\n  };\n\n  TableData.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableData,\n    selectors: [[\"\", \"ibmTableData\", \"\"]],\n    inputs: {\n      skeleton: \"skeleton\",\n      item: \"item\"\n    },\n    attrs: _c23,\n    decls: 2,\n    vars: 2,\n    consts: [[4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n    template: function TableData_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TableData_ng_container_0_Template, 2, 1, \"ng-container\", 0);\n        ɵngcc0.ɵɵtemplate(1, TableData_1_Template, 1, 4, null, 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton && !ctx.item.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet],\n    encapsulation: 2\n  });\n  return TableData;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableCheckbox = /*#__PURE__*/(() => {\n  class TableCheckbox {\n    constructor(i18n) {\n      this.i18n = i18n;\n      this.selected = false;\n      this.name = \"\";\n      /**\n       * Size of the table rows.\n       */\n\n      this.size = \"md\";\n      this.skeleton = false;\n      /**\n       * Emits if a single row is selected.\n       */\n\n      this.change = new EventEmitter();\n      this._label = this.i18n.getOverridable(\"TABLE.CHECKBOX_ROW\");\n    }\n\n    get disabled() {\n      return this.row ? !!this.row.disabled : false;\n    }\n\n    set label(value) {\n      this._label.override(value);\n    }\n\n    get label() {\n      return this._label.value;\n    }\n\n    getSelectionLabelValue(row) {\n      if (!this.selectionLabelColumn) {\n        return {\n          value: this.i18n.get().TABLE.ROW\n        };\n      }\n\n      return {\n        value: row[this.selectionLabelColumn].data\n      };\n    }\n\n    getLabel() {\n      return this._label.subject;\n    }\n\n  }\n\n  TableCheckbox.ɵfac = function TableCheckbox_Factory(t) {\n    return new (t || TableCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableCheckbox.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableCheckbox,\n    selectors: [[\"\", \"ibmTableCheckbox\", \"\"]],\n    inputs: {\n      selected: \"selected\",\n      name: \"name\",\n      size: \"size\",\n      skeleton: \"skeleton\",\n      label: \"label\",\n      row: \"row\",\n      selectionLabelColumn: \"selectionLabelColumn\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    attrs: _c24,\n    decls: 1,\n    vars: 1,\n    consts: [[\"inline\", \"true\", 3, \"name\", \"aria-label\", \"size\", \"checked\", \"disabled\", \"change\", 4, \"ngIf\"], [\"inline\", \"true\", 3, \"name\", \"aria-label\", \"size\", \"checked\", \"disabled\", \"change\"]],\n    template: function TableCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TableCheckbox_ibm_checkbox_0_Template, 3, 10, \"ibm-checkbox\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc6.Checkbox],\n    pipes: [ɵngcc2.AsyncPipe, ɵngcc1.ReplacePipe],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableCheckbox;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableRadio = /*#__PURE__*/(() => {\n  class TableRadio {\n    constructor(i18n) {\n      this.i18n = i18n;\n      this.selected = false;\n      this.skeleton = false;\n      /**\n       * Emits if a single row is selected.\n       */\n\n      this.change = new EventEmitter();\n      this._label = this.i18n.getOverridable(\"TABLE.CHECKBOX_ROW\");\n    }\n\n    set label(value) {\n      this._label.override(value);\n    }\n\n    get label() {\n      return this._label.value;\n    }\n\n    getSelectionLabelValue(row) {\n      if (!this.selectionLabelColumn) {\n        return {\n          value: this.i18n.get().TABLE.ROW\n        };\n      }\n\n      return {\n        value: row[this.selectionLabelColumn].data\n      };\n    }\n\n    getLabel() {\n      return this._label.subject;\n    }\n\n  }\n\n  TableRadio.ɵfac = function TableRadio_Factory(t) {\n    return new (t || TableRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableRadio.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableRadio,\n    selectors: [[\"\", \"ibmTableRadio\", \"\"]],\n    inputs: {\n      selected: \"selected\",\n      skeleton: \"skeleton\",\n      label: \"label\",\n      row: \"row\",\n      selectionLabelColumn: \"selectionLabelColumn\"\n    },\n    outputs: {\n      change: \"change\"\n    },\n    attrs: _c25,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"ariaLabel\", \"checked\", \"change\", 4, \"ngIf\"], [3, \"ariaLabel\", \"checked\", \"change\"]],\n    template: function TableRadio_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TableRadio_ibm_radio_0_Template, 5, 13, \"ibm-radio\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.skeleton);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc7.Radio],\n    pipes: [ɵngcc2.AsyncPipe, ɵngcc1.ReplacePipe],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableRadio;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TableExpandButton = /*#__PURE__*/(() => {\n  class TableExpandButton {\n    constructor(i18n) {\n      this.i18n = i18n;\n      /**\n       * Set to true to indicate the row has expanded\n       */\n\n      this.expanded = false;\n      /**\n       * Set to true to indicate the row can be expanded.\n       * Defaults to false to allow for correct column alignment\n       */\n\n      this.expandable = false;\n      this.skeleton = false;\n      this.expandClass = true;\n      this.expandRow = new EventEmitter();\n      this._ariaLabel = this.i18n.getOverridable(\"TABLE.EXPAND_BUTTON\");\n    }\n\n    set ariaLabel(value) {\n      this._ariaLabel.override(value);\n    }\n\n    get ariaLabel() {\n      return this._ariaLabel.value;\n    }\n\n    get previousValue() {\n      return this.expanded ? \"collapsed\" : null;\n    }\n\n    getAriaLabel() {\n      return this._ariaLabel.subject;\n    }\n\n  }\n\n  TableExpandButton.ɵfac = function TableExpandButton_Factory(t) {\n    return new (t || TableExpandButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.I18n));\n  };\n\n  TableExpandButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: TableExpandButton,\n    selectors: [[\"\", \"ibmTableExpandButton\", \"\"]],\n    hostVars: 3,\n    hostBindings: function TableExpandButton_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-previous-value\", ctx.previousValue);\n        ɵngcc0.ɵɵclassProp(\"bx--table-expand\", ctx.expandClass);\n      }\n    },\n    inputs: {\n      expanded: \"expanded\",\n      expandable: \"expandable\",\n      skeleton: \"skeleton\",\n      ariaLabel: \"ariaLabel\"\n    },\n    outputs: {\n      expandRow: \"expandRow\"\n    },\n    attrs: _c26,\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"bx--table-expand__button\", 3, \"click\", 4, \"ngIf\"], [1, \"bx--table-expand__button\", 3, \"click\"], [\"ibmIcon\", \"chevron--right\", \"size\", \"16\", 1, \"bx--table-expand__svg\"]],\n    template: function TableExpandButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, TableExpandButton_button_0_Template, 3, 3, \"button\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.expandable);\n      }\n    },\n    directives: [ɵngcc2.NgIf, ɵngcc4.IconDirective],\n    pipes: [ɵngcc2.AsyncPipe],\n    encapsulation: 2\n  });\n  /** @nocollapse */\n\n  return TableExpandButton;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Represents a table row, which is essentially an array of TableItem.\n */\n\n\nclass TableRow extends Array {\n  constructor() {\n    super(...arguments);\n    /**\n     * Whether row is disabled or not.\n     */\n\n    this.disabled = false;\n  }\n\n} // modules\n\n\nlet TableModule = /*#__PURE__*/(() => {\n  class TableModule {}\n\n  TableModule.ɵfac = function TableModule_Factory(t) {\n    return new (t || TableModule)();\n  };\n\n  TableModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: TableModule\n  });\n  TableModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, NFormsModule, FormsModule, DialogModule, ButtonModule, SearchModule, I18nModule, IconModule]]\n  });\n  return TableModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TableModule, {\n    declarations: function () {\n      return [TableToolbar, TableContainer, TableHeader, TableHeaderTitle, TableHeaderDescription, TableHeadCellLabel, TableToolbarActions, TableToolbarSearch, TableToolbarContent, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton];\n    },\n    imports: function () {\n      return [CommonModule, NFormsModule, FormsModule, DialogModule, ButtonModule, SearchModule, I18nModule, IconModule];\n    },\n    exports: function () {\n      return [TableToolbar, TableContainer, TableHeader, TableHeaderTitle, TableHeaderDescription, TableHeadCellLabel, TableToolbarActions, TableToolbarSearch, TableToolbarContent, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton];\n    }\n  });\n})(); // table utilities/toolbar imports\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { TableToolbar, TableToolbarActions, TableToolbarSearch, TableToolbarContent, TableContainer, TableHeader, TableHeaderTitle, TableHeadCellLabel, TableHeaderDescription, ExpandedRowHover, Table, TableDirective, TableHead, TableHeadCell, TableHeadCheckbox, TableHeadExpand, TableBody, TableRowComponent, TableExpandedRow, TableData, TableCheckbox, TableRadio, TableExpandButton, TableModel, TableItem, TableHeaderItem, TableCellAdapter, TableRowAdapter, TableAdapter, TableDomAdapter, DataGridInteractionModel, TableModule, TableRow }; //# sourceMappingURL=carbon-components-angular-table.js.map","map":null,"metadata":{},"sourceType":"module"}