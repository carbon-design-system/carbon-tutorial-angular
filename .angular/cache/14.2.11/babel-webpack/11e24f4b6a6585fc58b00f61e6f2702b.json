{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { visit } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { getFragmentDefinitions } from \"../../utilities/index.js\";\nexport function createFragmentRegistry() {\n  var fragments = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    fragments[_i] = arguments[_i];\n  }\n\n  return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();\n}\nvar arrayLikeForEach = Array.prototype.forEach;\n\nvar FragmentRegistry = function () {\n  function FragmentRegistry() {\n    var fragments = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      fragments[_i] = arguments[_i];\n    }\n\n    this.registry = Object.create(null);\n    this.resetCaches();\n\n    if (fragments.length) {\n      this.register.apply(this, fragments);\n    }\n  }\n\n  FragmentRegistry.prototype.register = function () {\n    var _this = this;\n\n    var definitions = new Map();\n    arrayLikeForEach.call(arguments, function (doc) {\n      getFragmentDefinitions(doc).forEach(function (node) {\n        definitions.set(node.name.value, node);\n      });\n    });\n    definitions.forEach(function (node, name) {\n      if (node !== _this.registry[name]) {\n        _this.registry[name] = node;\n\n        _this.invalidate(name);\n      }\n    });\n    return this;\n  };\n\n  FragmentRegistry.prototype.invalidate = function (name) {};\n\n  FragmentRegistry.prototype.resetCaches = function () {\n    this.invalidate = (this.lookup = this.cacheUnaryMethod(\"lookup\")).dirty;\n    this.transform = this.cacheUnaryMethod(\"transform\");\n    this.findFragmentSpreads = this.cacheUnaryMethod(\"findFragmentSpreads\");\n  };\n\n  FragmentRegistry.prototype.cacheUnaryMethod = function (name) {\n    var registry = this;\n    var originalMethod = FragmentRegistry.prototype[name];\n    return wrap(function () {\n      return originalMethod.apply(registry, arguments);\n    }, {\n      makeCacheKey: function (arg) {\n        return arg;\n      }\n    });\n  };\n\n  FragmentRegistry.prototype.lookup = function (fragmentName) {\n    return this.registry[fragmentName] || null;\n  };\n\n  FragmentRegistry.prototype.transform = function (document) {\n    var _this = this;\n\n    var defined = new Map();\n    getFragmentDefinitions(document).forEach(function (def) {\n      defined.set(def.name.value, def);\n    });\n    var unbound = new Set();\n\n    var enqueue = function (spreadName) {\n      if (!defined.has(spreadName)) {\n        unbound.add(spreadName);\n      }\n    };\n\n    var enqueueChildSpreads = function (node) {\n      return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue);\n    };\n\n    enqueueChildSpreads(document);\n    var missing = [];\n    var map = Object.create(null);\n    unbound.forEach(function (fragmentName) {\n      var knownFragmentDef = defined.get(fragmentName);\n\n      if (knownFragmentDef) {\n        enqueueChildSpreads(map[fragmentName] = knownFragmentDef);\n      } else {\n        missing.push(fragmentName);\n\n        var def = _this.lookup(fragmentName);\n\n        if (def) {\n          enqueueChildSpreads(map[fragmentName] = def);\n        }\n      }\n    });\n\n    if (missing.length) {\n      var defsToAppend_1 = [];\n      missing.forEach(function (name) {\n        var def = map[name];\n\n        if (def) {\n          defsToAppend_1.push(def);\n        }\n      });\n\n      if (defsToAppend_1.length) {\n        document = __assign(__assign({}, document), {\n          definitions: document.definitions.concat(defsToAppend_1)\n        });\n      }\n    }\n\n    return document;\n  };\n\n  FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n    var spreads = Object.create(null);\n    visit(root, {\n      FragmentSpread: function (node) {\n        spreads[node.name.value] = node;\n      }\n    });\n    return spreads;\n  };\n\n  return FragmentRegistry;\n}(); //# sourceMappingURL=fragmentRegistry.js.map","map":null,"metadata":{},"sourceType":"module"}